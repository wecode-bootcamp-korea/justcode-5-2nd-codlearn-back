
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/index';
declare const prisma: unique symbol
export type PrismaPromise<A> = Promise<A> & {[prisma]: true}
type UnwrapPromise<P extends any> = P extends Promise<infer R> ? R : P
type UnwrapTuple<Tuple extends readonly unknown[]> = {
  [K in keyof Tuple]: K extends `${number}` ? Tuple[K] extends PrismaPromise<infer X> ? X : UnwrapPromise<Tuple[K]> : UnwrapPromise<Tuple[K]>
};


/**
 * Model users
 * 
 */
export type users = {
  id: number
  name: string | null
  email: string
  password: string
  img: string | null
  created_at: Date | null
  updated_at: Date | null
}

/**
 * Model category
 * 
 */
export type category = {
  id: number
  name: string
  depth: number | null
  parent_id: number | null
}

/**
 * Model class_img
 * 
 */
export type class_img = {
  id: number
  url: string
  class_id: number
}

/**
 * Model classes
 * 
 */
export type classes = {
  id: number
  name: string
  instructor_id: number
  price: number | null
  img: string | null
  rate: number | null
  description: string | null
  students: number | null
  sessions: number | null
  price_scope: number | null
  category1_id: number | null
  category2_id: number | null
  category3_id: number | null
  level_id: number | null
  created_at: Date | null
  updated_at: Date | null
}

/**
 * Model contents
 * 
 */
export type contents = {
  id: number
  class_id: number
  content: string | null
}

/**
 * Model instructor
 * 
 */
export type instructor = {
  id: number
  name: string
}

/**
 * Model level
 * 
 */
export type level = {
  id: number
  level: string
}

/**
 * Model my_classes
 * 
 */
export type my_classes = {
  id: number
  user_id: number
  class_id: number
  progress: number
}

/**
 * Model price_scope
 * 
 */
export type price_scope = {
  id: number
  scope: string | null
}

/**
 * Model review
 * 
 */
export type review = {
  id: number
  user_id: number
  rate: number
  class_id: number
}

/**
 * Model wishlist
 * 
 */
export type wishlist = {
  id: number
  user_id: number
  class_id: number
}


/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.users.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  GlobalReject = 'rejectOnNotFound' extends keyof T
    ? T['rejectOnNotFound']
    : false
      > {
      /**
       * @private
       */
      private fetcher;
      /**
       * @private
       */
      private readonly dmmf;
      /**
       * @private
       */
      private connectionPromise?;
      /**
       * @private
       */
      private disconnectionPromise?;
      /**
       * @private
       */
      private readonly engineConfig;
      /**
       * @private
       */
      private readonly measurePerformance;

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.users.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends (U | 'beforeExit')>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : V extends 'beforeExit' ? () => Promise<void> : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): Promise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): Promise<void>;

  /**
   * Add a middleware
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends PrismaPromise<any>[]>(arg: [...P]): Promise<UnwrapTuple<P>>;

      /**
   * `prisma.users`: Exposes CRUD operations for the **users** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.users.findMany()
    * ```
    */
  get users(): Prisma.usersDelegate<GlobalReject>;

  /**
   * `prisma.category`: Exposes CRUD operations for the **category** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Categories
    * const categories = await prisma.category.findMany()
    * ```
    */
  get category(): Prisma.categoryDelegate<GlobalReject>;

  /**
   * `prisma.class_img`: Exposes CRUD operations for the **class_img** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Class_imgs
    * const class_imgs = await prisma.class_img.findMany()
    * ```
    */
  get class_img(): Prisma.class_imgDelegate<GlobalReject>;

  /**
   * `prisma.classes`: Exposes CRUD operations for the **classes** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Classes
    * const classes = await prisma.classes.findMany()
    * ```
    */
  get classes(): Prisma.classesDelegate<GlobalReject>;

  /**
   * `prisma.contents`: Exposes CRUD operations for the **contents** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Contents
    * const contents = await prisma.contents.findMany()
    * ```
    */
  get contents(): Prisma.contentsDelegate<GlobalReject>;

  /**
   * `prisma.instructor`: Exposes CRUD operations for the **instructor** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Instructors
    * const instructors = await prisma.instructor.findMany()
    * ```
    */
  get instructor(): Prisma.instructorDelegate<GlobalReject>;

  /**
   * `prisma.level`: Exposes CRUD operations for the **level** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Levels
    * const levels = await prisma.level.findMany()
    * ```
    */
  get level(): Prisma.levelDelegate<GlobalReject>;

  /**
   * `prisma.my_classes`: Exposes CRUD operations for the **my_classes** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more My_classes
    * const my_classes = await prisma.my_classes.findMany()
    * ```
    */
  get my_classes(): Prisma.my_classesDelegate<GlobalReject>;

  /**
   * `prisma.price_scope`: Exposes CRUD operations for the **price_scope** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Price_scopes
    * const price_scopes = await prisma.price_scope.findMany()
    * ```
    */
  get price_scope(): Prisma.price_scopeDelegate<GlobalReject>;

  /**
   * `prisma.review`: Exposes CRUD operations for the **review** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Reviews
    * const reviews = await prisma.review.findMany()
    * ```
    */
  get review(): Prisma.reviewDelegate<GlobalReject>;

  /**
   * `prisma.wishlist`: Exposes CRUD operations for the **wishlist** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Wishlists
    * const wishlists = await prisma.wishlist.findMany()
    * ```
    */
  get wishlist(): Prisma.wishlistDelegate<GlobalReject>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export import Metrics = runtime.Metrics
  export import Metric = runtime.Metric
  export import MetricHistogram = runtime.MetricHistogram
  export import MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
   * Prisma Client JS version: 4.0.0
   * Query Engine version: da41d2bb3406da22087b849f0e911199ba4fbf11
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }
  type HasSelect = {
    select: any
  }
  type HasInclude = {
    include: any
  }
  type CheckSelect<T, S, U> = T extends SelectAndInclude
    ? 'Please either choose `select` or `include`'
    : T extends HasSelect
    ? U
    : T extends HasInclude
    ? U
    : S

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => Promise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = {
    [key in keyof T]: T[key] extends false | undefined | null ? never : key
  }[keyof T]

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Buffer
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Exact<A, W = unknown> = 
  W extends unknown ? A extends Narrowable ? Cast<A, W> : Cast<
  {[K in keyof A]: K extends keyof W ? Exact<A[K], W[K]> : never},
  {[K in keyof W]: K extends keyof A ? Exact<A[K], W[K]> : W[K]}>
  : never;

  type Narrowable = string | number | boolean | bigint;

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;

  export function validator<V>(): <S>(select: Exact<S, V>) => S;

  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but with an array
   */
  type PickArray<T, K extends Array<keyof T>> = Prisma__Pick<T, TupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T

  class PrismaClientFetcher {
    private readonly prisma;
    private readonly debug;
    private readonly hooks?;
    constructor(prisma: PrismaClient<any, any>, debug?: boolean, hooks?: Hooks | undefined);
    request<T>(document: any, dataPath?: string[], rootField?: string, typeName?: string, isList?: boolean, callsite?: string): Promise<T>;
    sanitizeMessage(message: string): string;
    protected unpack(document: any, data: any, path: string[], rootField?: string, isList?: boolean): any;
  }

  export const ModelName: {
    users: 'users',
    category: 'category',
    class_img: 'class_img',
    classes: 'classes',
    contents: 'contents',
    instructor: 'instructor',
    level: 'level',
    my_classes: 'my_classes',
    price_scope: 'price_scope',
    review: 'review',
    wishlist: 'wishlist'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  export type RejectOnNotFound = boolean | ((error: Error) => Error)
  export type RejectPerModel = { [P in ModelName]?: RejectOnNotFound }
  export type RejectPerOperation =  { [P in "findUnique" | "findFirst"]?: RejectPerModel | RejectOnNotFound } 
  type IsReject<T> = T extends true ? True : T extends (err: Error) => Error ? True : False
  export type HasReject<
    GlobalRejectSettings extends Prisma.PrismaClientOptions['rejectOnNotFound'],
    LocalRejectSettings,
    Action extends PrismaAction,
    Model extends ModelName
  > = LocalRejectSettings extends RejectOnNotFound
    ? IsReject<LocalRejectSettings>
    : GlobalRejectSettings extends RejectPerOperation
    ? Action extends keyof GlobalRejectSettings
      ? GlobalRejectSettings[Action] extends RejectOnNotFound
        ? IsReject<GlobalRejectSettings[Action]>
        : GlobalRejectSettings[Action] extends RejectPerModel
        ? Model extends keyof GlobalRejectSettings[Action]
          ? IsReject<GlobalRejectSettings[Action][Model]>
          : False
        : False
      : False
    : IsReject<GlobalRejectSettings>
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'

  export interface PrismaClientOptions {
    /**
     * Configure findUnique/findFirst to throw an error if the query returns null. 
     * @deprecated since 4.0.0. Use `findUniqueOrThrow`/`findFirstOrThrow` methods instead.
     * @example
     * ```
     * // Reject on both findUnique/findFirst
     * rejectOnNotFound: true
     * // Reject only on findFirst with a custom error
     * rejectOnNotFound: { findFirst: (err) => new Error("Custom Error")}
     * // Reject on user.findUnique with a custom error
     * rejectOnNotFound: { findUnique: {User: (err) => new Error("User not found")}}
     * ```
     */
    rejectOnNotFound?: RejectOnNotFound | RejectPerOperation
    /**
     * Overwrites the datasource url from your prisma.schema file
     */
    datasources?: Datasources

    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat

    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: Array<LogLevel | LogDefinition>
  }

  export type Hooks = {
    beforeRequest?: (options: { query: string, path: string[], rootField?: string, typeName?: string, document: any }) => any
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findMany'
    | 'findFirst'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'

  /**
   * These options are being passed in to the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => Promise<T>,
  ) => Promise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UsersCountOutputType
   */


  export type UsersCountOutputType = {
    my_classes: number
    review: number
    wishlist: number
  }

  export type UsersCountOutputTypeSelect = {
    my_classes?: boolean
    review?: boolean
    wishlist?: boolean
  }

  export type UsersCountOutputTypeGetPayload<
    S extends boolean | null | undefined | UsersCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? UsersCountOutputType
    : S extends undefined
    ? never
    : S extends UsersCountOutputTypeArgs
    ?'include' extends U
    ? UsersCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof UsersCountOutputType ? UsersCountOutputType[P] : never
  } 
    : UsersCountOutputType
  : UsersCountOutputType




  // Custom InputTypes

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the UsersCountOutputType
     * 
    **/
    select?: UsersCountOutputTypeSelect | null
  }



  /**
   * Count Type CategoryCountOutputType
   */


  export type CategoryCountOutputType = {
    classes_categoryToclasses_category1_id: number
    classes_categoryToclasses_category2_id: number
    classes_categoryToclasses_category3_id: number
  }

  export type CategoryCountOutputTypeSelect = {
    classes_categoryToclasses_category1_id?: boolean
    classes_categoryToclasses_category2_id?: boolean
    classes_categoryToclasses_category3_id?: boolean
  }

  export type CategoryCountOutputTypeGetPayload<
    S extends boolean | null | undefined | CategoryCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? CategoryCountOutputType
    : S extends undefined
    ? never
    : S extends CategoryCountOutputTypeArgs
    ?'include' extends U
    ? CategoryCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof CategoryCountOutputType ? CategoryCountOutputType[P] : never
  } 
    : CategoryCountOutputType
  : CategoryCountOutputType




  // Custom InputTypes

  /**
   * CategoryCountOutputType without action
   */
  export type CategoryCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the CategoryCountOutputType
     * 
    **/
    select?: CategoryCountOutputTypeSelect | null
  }



  /**
   * Count Type ClassesCountOutputType
   */


  export type ClassesCountOutputType = {
    class_img: number
    contents: number
    my_classes: number
    review: number
    wishlist: number
  }

  export type ClassesCountOutputTypeSelect = {
    class_img?: boolean
    contents?: boolean
    my_classes?: boolean
    review?: boolean
    wishlist?: boolean
  }

  export type ClassesCountOutputTypeGetPayload<
    S extends boolean | null | undefined | ClassesCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? ClassesCountOutputType
    : S extends undefined
    ? never
    : S extends ClassesCountOutputTypeArgs
    ?'include' extends U
    ? ClassesCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof ClassesCountOutputType ? ClassesCountOutputType[P] : never
  } 
    : ClassesCountOutputType
  : ClassesCountOutputType




  // Custom InputTypes

  /**
   * ClassesCountOutputType without action
   */
  export type ClassesCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the ClassesCountOutputType
     * 
    **/
    select?: ClassesCountOutputTypeSelect | null
  }



  /**
   * Count Type InstructorCountOutputType
   */


  export type InstructorCountOutputType = {
    classes: number
  }

  export type InstructorCountOutputTypeSelect = {
    classes?: boolean
  }

  export type InstructorCountOutputTypeGetPayload<
    S extends boolean | null | undefined | InstructorCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? InstructorCountOutputType
    : S extends undefined
    ? never
    : S extends InstructorCountOutputTypeArgs
    ?'include' extends U
    ? InstructorCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof InstructorCountOutputType ? InstructorCountOutputType[P] : never
  } 
    : InstructorCountOutputType
  : InstructorCountOutputType




  // Custom InputTypes

  /**
   * InstructorCountOutputType without action
   */
  export type InstructorCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the InstructorCountOutputType
     * 
    **/
    select?: InstructorCountOutputTypeSelect | null
  }



  /**
   * Count Type LevelCountOutputType
   */


  export type LevelCountOutputType = {
    classes: number
  }

  export type LevelCountOutputTypeSelect = {
    classes?: boolean
  }

  export type LevelCountOutputTypeGetPayload<
    S extends boolean | null | undefined | LevelCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? LevelCountOutputType
    : S extends undefined
    ? never
    : S extends LevelCountOutputTypeArgs
    ?'include' extends U
    ? LevelCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof LevelCountOutputType ? LevelCountOutputType[P] : never
  } 
    : LevelCountOutputType
  : LevelCountOutputType




  // Custom InputTypes

  /**
   * LevelCountOutputType without action
   */
  export type LevelCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the LevelCountOutputType
     * 
    **/
    select?: LevelCountOutputTypeSelect | null
  }



  /**
   * Count Type Price_scopeCountOutputType
   */


  export type Price_scopeCountOutputType = {
    classes: number
  }

  export type Price_scopeCountOutputTypeSelect = {
    classes?: boolean
  }

  export type Price_scopeCountOutputTypeGetPayload<
    S extends boolean | null | undefined | Price_scopeCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? Price_scopeCountOutputType
    : S extends undefined
    ? never
    : S extends Price_scopeCountOutputTypeArgs
    ?'include' extends U
    ? Price_scopeCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof Price_scopeCountOutputType ? Price_scopeCountOutputType[P] : never
  } 
    : Price_scopeCountOutputType
  : Price_scopeCountOutputType




  // Custom InputTypes

  /**
   * Price_scopeCountOutputType without action
   */
  export type Price_scopeCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the Price_scopeCountOutputType
     * 
    **/
    select?: Price_scopeCountOutputTypeSelect | null
  }



  /**
   * Models
   */

  /**
   * Model users
   */


  export type AggregateUsers = {
    _count: UsersCountAggregateOutputType | null
    _avg: UsersAvgAggregateOutputType | null
    _sum: UsersSumAggregateOutputType | null
    _min: UsersMinAggregateOutputType | null
    _max: UsersMaxAggregateOutputType | null
  }

  export type UsersAvgAggregateOutputType = {
    id: number | null
  }

  export type UsersSumAggregateOutputType = {
    id: number | null
  }

  export type UsersMinAggregateOutputType = {
    id: number | null
    name: string | null
    email: string | null
    password: string | null
    img: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type UsersMaxAggregateOutputType = {
    id: number | null
    name: string | null
    email: string | null
    password: string | null
    img: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type UsersCountAggregateOutputType = {
    id: number
    name: number
    email: number
    password: number
    img: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type UsersAvgAggregateInputType = {
    id?: true
  }

  export type UsersSumAggregateInputType = {
    id?: true
  }

  export type UsersMinAggregateInputType = {
    id?: true
    name?: true
    email?: true
    password?: true
    img?: true
    created_at?: true
    updated_at?: true
  }

  export type UsersMaxAggregateInputType = {
    id?: true
    name?: true
    email?: true
    password?: true
    img?: true
    created_at?: true
    updated_at?: true
  }

  export type UsersCountAggregateInputType = {
    id?: true
    name?: true
    email?: true
    password?: true
    img?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type UsersAggregateArgs = {
    /**
     * Filter which users to aggregate.
     * 
    **/
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     * 
    **/
    orderBy?: Enumerable<usersOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned users
    **/
    _count?: true | UsersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UsersAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UsersSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UsersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UsersMaxAggregateInputType
  }

  export type GetUsersAggregateType<T extends UsersAggregateArgs> = {
        [P in keyof T & keyof AggregateUsers]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUsers[P]>
      : GetScalarType<T[P], AggregateUsers[P]>
  }




  export type UsersGroupByArgs = {
    where?: usersWhereInput
    orderBy?: Enumerable<usersOrderByWithAggregationInput>
    by: Array<UsersScalarFieldEnum>
    having?: usersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UsersCountAggregateInputType | true
    _avg?: UsersAvgAggregateInputType
    _sum?: UsersSumAggregateInputType
    _min?: UsersMinAggregateInputType
    _max?: UsersMaxAggregateInputType
  }


  export type UsersGroupByOutputType = {
    id: number
    name: string | null
    email: string
    password: string
    img: string | null
    created_at: Date | null
    updated_at: Date | null
    _count: UsersCountAggregateOutputType | null
    _avg: UsersAvgAggregateOutputType | null
    _sum: UsersSumAggregateOutputType | null
    _min: UsersMinAggregateOutputType | null
    _max: UsersMaxAggregateOutputType | null
  }

  type GetUsersGroupByPayload<T extends UsersGroupByArgs> = PrismaPromise<
    Array<
      PickArray<UsersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UsersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UsersGroupByOutputType[P]>
            : GetScalarType<T[P], UsersGroupByOutputType[P]>
        }
      >
    >


  export type usersSelect = {
    id?: boolean
    name?: boolean
    email?: boolean
    password?: boolean
    img?: boolean
    created_at?: boolean
    updated_at?: boolean
    my_classes?: boolean | my_classesFindManyArgs
    review?: boolean | reviewFindManyArgs
    wishlist?: boolean | wishlistFindManyArgs
    _count?: boolean | UsersCountOutputTypeArgs
  }

  export type usersInclude = {
    my_classes?: boolean | my_classesFindManyArgs
    review?: boolean | reviewFindManyArgs
    wishlist?: boolean | wishlistFindManyArgs
    _count?: boolean | UsersCountOutputTypeArgs
  }

  export type usersGetPayload<
    S extends boolean | null | undefined | usersArgs,
    U = keyof S
      > = S extends true
        ? users
    : S extends undefined
    ? never
    : S extends usersArgs | usersFindManyArgs
    ?'include' extends U
    ? users  & {
    [P in TrueKeys<S['include']>]:
        P extends 'my_classes' ? Array < my_classesGetPayload<S['include'][P]>>  :
        P extends 'review' ? Array < reviewGetPayload<S['include'][P]>>  :
        P extends 'wishlist' ? Array < wishlistGetPayload<S['include'][P]>>  :
        P extends '_count' ? UsersCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'my_classes' ? Array < my_classesGetPayload<S['select'][P]>>  :
        P extends 'review' ? Array < reviewGetPayload<S['select'][P]>>  :
        P extends 'wishlist' ? Array < wishlistGetPayload<S['select'][P]>>  :
        P extends '_count' ? UsersCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof users ? users[P] : never
  } 
    : users
  : users


  type usersCountArgs = Merge<
    Omit<usersFindManyArgs, 'select' | 'include'> & {
      select?: UsersCountAggregateInputType | true
    }
  >

  export interface usersDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Users that matches the filter.
     * @param {usersFindUniqueArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends usersFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, usersFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'users'> extends True ? CheckSelect<T, Prisma__usersClient<users>, Prisma__usersClient<usersGetPayload<T>>> : CheckSelect<T, Prisma__usersClient<users | null >, Prisma__usersClient<usersGetPayload<T> | null >>

    /**
     * Find the first Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersFindFirstArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends usersFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, usersFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'users'> extends True ? CheckSelect<T, Prisma__usersClient<users>, Prisma__usersClient<usersGetPayload<T>>> : CheckSelect<T, Prisma__usersClient<users | null >, Prisma__usersClient<usersGetPayload<T> | null >>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.users.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.users.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const usersWithIdOnly = await prisma.users.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends usersFindManyArgs>(
      args?: SelectSubset<T, usersFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<users>>, PrismaPromise<Array<usersGetPayload<T>>>>

    /**
     * Create a Users.
     * @param {usersCreateArgs} args - Arguments to create a Users.
     * @example
     * // Create one Users
     * const Users = await prisma.users.create({
     *   data: {
     *     // ... data to create a Users
     *   }
     * })
     * 
    **/
    create<T extends usersCreateArgs>(
      args: SelectSubset<T, usersCreateArgs>
    ): CheckSelect<T, Prisma__usersClient<users>, Prisma__usersClient<usersGetPayload<T>>>

    /**
     * Create many Users.
     *     @param {usersCreateManyArgs} args - Arguments to create many Users.
     *     @example
     *     // Create many Users
     *     const users = await prisma.users.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends usersCreateManyArgs>(
      args?: SelectSubset<T, usersCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Users.
     * @param {usersDeleteArgs} args - Arguments to delete one Users.
     * @example
     * // Delete one Users
     * const Users = await prisma.users.delete({
     *   where: {
     *     // ... filter to delete one Users
     *   }
     * })
     * 
    **/
    delete<T extends usersDeleteArgs>(
      args: SelectSubset<T, usersDeleteArgs>
    ): CheckSelect<T, Prisma__usersClient<users>, Prisma__usersClient<usersGetPayload<T>>>

    /**
     * Update one Users.
     * @param {usersUpdateArgs} args - Arguments to update one Users.
     * @example
     * // Update one Users
     * const users = await prisma.users.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends usersUpdateArgs>(
      args: SelectSubset<T, usersUpdateArgs>
    ): CheckSelect<T, Prisma__usersClient<users>, Prisma__usersClient<usersGetPayload<T>>>

    /**
     * Delete zero or more Users.
     * @param {usersDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.users.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends usersDeleteManyArgs>(
      args?: SelectSubset<T, usersDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const users = await prisma.users.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends usersUpdateManyArgs>(
      args: SelectSubset<T, usersUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Users.
     * @param {usersUpsertArgs} args - Arguments to update or create a Users.
     * @example
     * // Update or create a Users
     * const users = await prisma.users.upsert({
     *   create: {
     *     // ... data to create a Users
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Users we want to update
     *   }
     * })
    **/
    upsert<T extends usersUpsertArgs>(
      args: SelectSubset<T, usersUpsertArgs>
    ): CheckSelect<T, Prisma__usersClient<users>, Prisma__usersClient<usersGetPayload<T>>>

    /**
     * Find one Users that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {usersFindUniqueOrThrowArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends usersFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, usersFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__usersClient<users>, Prisma__usersClient<usersGetPayload<T>>>

    /**
     * Find the first Users that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersFindFirstOrThrowArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends usersFindFirstOrThrowArgs>(
      args?: SelectSubset<T, usersFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__usersClient<users>, Prisma__usersClient<usersGetPayload<T>>>

    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.users.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends usersCountArgs>(
      args?: Subset<T, usersCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UsersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UsersAggregateArgs>(args: Subset<T, UsersAggregateArgs>): PrismaPromise<GetUsersAggregateType<T>>

    /**
     * Group by Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UsersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UsersGroupByArgs['orderBy'] }
        : { orderBy?: UsersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UsersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUsersGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for users.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__usersClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    my_classes<T extends my_classesFindManyArgs = {}>(args?: Subset<T, my_classesFindManyArgs>): CheckSelect<T, PrismaPromise<Array<my_classes>>, PrismaPromise<Array<my_classesGetPayload<T>>>>;

    review<T extends reviewFindManyArgs = {}>(args?: Subset<T, reviewFindManyArgs>): CheckSelect<T, PrismaPromise<Array<review>>, PrismaPromise<Array<reviewGetPayload<T>>>>;

    wishlist<T extends wishlistFindManyArgs = {}>(args?: Subset<T, wishlistFindManyArgs>): CheckSelect<T, PrismaPromise<Array<wishlist>>, PrismaPromise<Array<wishlistGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * users base type for findUnique actions
   */
  export type usersFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the users
     * 
    **/
    select?: usersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: usersInclude | null
    /**
     * Filter, which users to fetch.
     * 
    **/
    where: usersWhereUniqueInput
  }

  /**
   * users: findUnique
   */
  export interface usersFindUniqueArgs extends usersFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * users base type for findFirst actions
   */
  export type usersFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the users
     * 
    **/
    select?: usersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: usersInclude | null
    /**
     * Filter, which users to fetch.
     * 
    **/
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     * 
    **/
    orderBy?: Enumerable<usersOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users.
     * 
    **/
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of users.
     * 
    **/
    distinct?: Enumerable<UsersScalarFieldEnum>
  }

  /**
   * users: findFirst
   */
  export interface usersFindFirstArgs extends usersFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * users findMany
   */
  export type usersFindManyArgs = {
    /**
     * Select specific fields to fetch from the users
     * 
    **/
    select?: usersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: usersInclude | null
    /**
     * Filter, which users to fetch.
     * 
    **/
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     * 
    **/
    orderBy?: Enumerable<usersOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing users.
     * 
    **/
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     * 
    **/
    skip?: number
    distinct?: Enumerable<UsersScalarFieldEnum>
  }


  /**
   * users create
   */
  export type usersCreateArgs = {
    /**
     * Select specific fields to fetch from the users
     * 
    **/
    select?: usersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: usersInclude | null
    /**
     * The data needed to create a users.
     * 
    **/
    data: XOR<usersCreateInput, usersUncheckedCreateInput>
  }


  /**
   * users createMany
   */
  export type usersCreateManyArgs = {
    /**
     * The data used to create many users.
     * 
    **/
    data: Enumerable<usersCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * users update
   */
  export type usersUpdateArgs = {
    /**
     * Select specific fields to fetch from the users
     * 
    **/
    select?: usersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: usersInclude | null
    /**
     * The data needed to update a users.
     * 
    **/
    data: XOR<usersUpdateInput, usersUncheckedUpdateInput>
    /**
     * Choose, which users to update.
     * 
    **/
    where: usersWhereUniqueInput
  }


  /**
   * users updateMany
   */
  export type usersUpdateManyArgs = {
    /**
     * The data used to update users.
     * 
    **/
    data: XOR<usersUpdateManyMutationInput, usersUncheckedUpdateManyInput>
    /**
     * Filter which users to update
     * 
    **/
    where?: usersWhereInput
  }


  /**
   * users upsert
   */
  export type usersUpsertArgs = {
    /**
     * Select specific fields to fetch from the users
     * 
    **/
    select?: usersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: usersInclude | null
    /**
     * The filter to search for the users to update in case it exists.
     * 
    **/
    where: usersWhereUniqueInput
    /**
     * In case the users found by the `where` argument doesn't exist, create a new users with this data.
     * 
    **/
    create: XOR<usersCreateInput, usersUncheckedCreateInput>
    /**
     * In case the users was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<usersUpdateInput, usersUncheckedUpdateInput>
  }


  /**
   * users delete
   */
  export type usersDeleteArgs = {
    /**
     * Select specific fields to fetch from the users
     * 
    **/
    select?: usersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: usersInclude | null
    /**
     * Filter which users to delete.
     * 
    **/
    where: usersWhereUniqueInput
  }


  /**
   * users deleteMany
   */
  export type usersDeleteManyArgs = {
    /**
     * Filter which users to delete
     * 
    **/
    where?: usersWhereInput
  }


  /**
   * users: findUniqueOrThrow
   */
  export type usersFindUniqueOrThrowArgs = usersFindUniqueArgsBase
      

  /**
   * users: findFirstOrThrow
   */
  export type usersFindFirstOrThrowArgs = usersFindFirstArgsBase
      

  /**
   * users without action
   */
  export type usersArgs = {
    /**
     * Select specific fields to fetch from the users
     * 
    **/
    select?: usersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: usersInclude | null
  }



  /**
   * Model category
   */


  export type AggregateCategory = {
    _count: CategoryCountAggregateOutputType | null
    _avg: CategoryAvgAggregateOutputType | null
    _sum: CategorySumAggregateOutputType | null
    _min: CategoryMinAggregateOutputType | null
    _max: CategoryMaxAggregateOutputType | null
  }

  export type CategoryAvgAggregateOutputType = {
    id: number | null
    depth: number | null
    parent_id: number | null
  }

  export type CategorySumAggregateOutputType = {
    id: number | null
    depth: number | null
    parent_id: number | null
  }

  export type CategoryMinAggregateOutputType = {
    id: number | null
    name: string | null
    depth: number | null
    parent_id: number | null
  }

  export type CategoryMaxAggregateOutputType = {
    id: number | null
    name: string | null
    depth: number | null
    parent_id: number | null
  }

  export type CategoryCountAggregateOutputType = {
    id: number
    name: number
    depth: number
    parent_id: number
    _all: number
  }


  export type CategoryAvgAggregateInputType = {
    id?: true
    depth?: true
    parent_id?: true
  }

  export type CategorySumAggregateInputType = {
    id?: true
    depth?: true
    parent_id?: true
  }

  export type CategoryMinAggregateInputType = {
    id?: true
    name?: true
    depth?: true
    parent_id?: true
  }

  export type CategoryMaxAggregateInputType = {
    id?: true
    name?: true
    depth?: true
    parent_id?: true
  }

  export type CategoryCountAggregateInputType = {
    id?: true
    name?: true
    depth?: true
    parent_id?: true
    _all?: true
  }

  export type CategoryAggregateArgs = {
    /**
     * Filter which category to aggregate.
     * 
    **/
    where?: categoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of categories to fetch.
     * 
    **/
    orderBy?: Enumerable<categoryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: categoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` categories from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` categories.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned categories
    **/
    _count?: true | CategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CategoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CategorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CategoryMaxAggregateInputType
  }

  export type GetCategoryAggregateType<T extends CategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCategory[P]>
      : GetScalarType<T[P], AggregateCategory[P]>
  }




  export type CategoryGroupByArgs = {
    where?: categoryWhereInput
    orderBy?: Enumerable<categoryOrderByWithAggregationInput>
    by: Array<CategoryScalarFieldEnum>
    having?: categoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CategoryCountAggregateInputType | true
    _avg?: CategoryAvgAggregateInputType
    _sum?: CategorySumAggregateInputType
    _min?: CategoryMinAggregateInputType
    _max?: CategoryMaxAggregateInputType
  }


  export type CategoryGroupByOutputType = {
    id: number
    name: string
    depth: number | null
    parent_id: number | null
    _count: CategoryCountAggregateOutputType | null
    _avg: CategoryAvgAggregateOutputType | null
    _sum: CategorySumAggregateOutputType | null
    _min: CategoryMinAggregateOutputType | null
    _max: CategoryMaxAggregateOutputType | null
  }

  type GetCategoryGroupByPayload<T extends CategoryGroupByArgs> = PrismaPromise<
    Array<
      PickArray<CategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CategoryGroupByOutputType[P]>
            : GetScalarType<T[P], CategoryGroupByOutputType[P]>
        }
      >
    >


  export type categorySelect = {
    id?: boolean
    name?: boolean
    depth?: boolean
    parent_id?: boolean
    classes_categoryToclasses_category1_id?: boolean | classesFindManyArgs
    classes_categoryToclasses_category2_id?: boolean | classesFindManyArgs
    classes_categoryToclasses_category3_id?: boolean | classesFindManyArgs
    _count?: boolean | CategoryCountOutputTypeArgs
  }

  export type categoryInclude = {
    classes_categoryToclasses_category1_id?: boolean | classesFindManyArgs
    classes_categoryToclasses_category2_id?: boolean | classesFindManyArgs
    classes_categoryToclasses_category3_id?: boolean | classesFindManyArgs
    _count?: boolean | CategoryCountOutputTypeArgs
  }

  export type categoryGetPayload<
    S extends boolean | null | undefined | categoryArgs,
    U = keyof S
      > = S extends true
        ? category
    : S extends undefined
    ? never
    : S extends categoryArgs | categoryFindManyArgs
    ?'include' extends U
    ? category  & {
    [P in TrueKeys<S['include']>]:
        P extends 'classes_categoryToclasses_category1_id' ? Array < classesGetPayload<S['include'][P]>>  :
        P extends 'classes_categoryToclasses_category2_id' ? Array < classesGetPayload<S['include'][P]>>  :
        P extends 'classes_categoryToclasses_category3_id' ? Array < classesGetPayload<S['include'][P]>>  :
        P extends '_count' ? CategoryCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'classes_categoryToclasses_category1_id' ? Array < classesGetPayload<S['select'][P]>>  :
        P extends 'classes_categoryToclasses_category2_id' ? Array < classesGetPayload<S['select'][P]>>  :
        P extends 'classes_categoryToclasses_category3_id' ? Array < classesGetPayload<S['select'][P]>>  :
        P extends '_count' ? CategoryCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof category ? category[P] : never
  } 
    : category
  : category


  type categoryCountArgs = Merge<
    Omit<categoryFindManyArgs, 'select' | 'include'> & {
      select?: CategoryCountAggregateInputType | true
    }
  >

  export interface categoryDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Category that matches the filter.
     * @param {categoryFindUniqueArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends categoryFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, categoryFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'category'> extends True ? CheckSelect<T, Prisma__categoryClient<category>, Prisma__categoryClient<categoryGetPayload<T>>> : CheckSelect<T, Prisma__categoryClient<category | null >, Prisma__categoryClient<categoryGetPayload<T> | null >>

    /**
     * Find the first Category that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {categoryFindFirstArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends categoryFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, categoryFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'category'> extends True ? CheckSelect<T, Prisma__categoryClient<category>, Prisma__categoryClient<categoryGetPayload<T>>> : CheckSelect<T, Prisma__categoryClient<category | null >, Prisma__categoryClient<categoryGetPayload<T> | null >>

    /**
     * Find zero or more Categories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {categoryFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Categories
     * const categories = await prisma.category.findMany()
     * 
     * // Get first 10 Categories
     * const categories = await prisma.category.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const categoryWithIdOnly = await prisma.category.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends categoryFindManyArgs>(
      args?: SelectSubset<T, categoryFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<category>>, PrismaPromise<Array<categoryGetPayload<T>>>>

    /**
     * Create a Category.
     * @param {categoryCreateArgs} args - Arguments to create a Category.
     * @example
     * // Create one Category
     * const Category = await prisma.category.create({
     *   data: {
     *     // ... data to create a Category
     *   }
     * })
     * 
    **/
    create<T extends categoryCreateArgs>(
      args: SelectSubset<T, categoryCreateArgs>
    ): CheckSelect<T, Prisma__categoryClient<category>, Prisma__categoryClient<categoryGetPayload<T>>>

    /**
     * Create many Categories.
     *     @param {categoryCreateManyArgs} args - Arguments to create many Categories.
     *     @example
     *     // Create many Categories
     *     const category = await prisma.category.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends categoryCreateManyArgs>(
      args?: SelectSubset<T, categoryCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Category.
     * @param {categoryDeleteArgs} args - Arguments to delete one Category.
     * @example
     * // Delete one Category
     * const Category = await prisma.category.delete({
     *   where: {
     *     // ... filter to delete one Category
     *   }
     * })
     * 
    **/
    delete<T extends categoryDeleteArgs>(
      args: SelectSubset<T, categoryDeleteArgs>
    ): CheckSelect<T, Prisma__categoryClient<category>, Prisma__categoryClient<categoryGetPayload<T>>>

    /**
     * Update one Category.
     * @param {categoryUpdateArgs} args - Arguments to update one Category.
     * @example
     * // Update one Category
     * const category = await prisma.category.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends categoryUpdateArgs>(
      args: SelectSubset<T, categoryUpdateArgs>
    ): CheckSelect<T, Prisma__categoryClient<category>, Prisma__categoryClient<categoryGetPayload<T>>>

    /**
     * Delete zero or more Categories.
     * @param {categoryDeleteManyArgs} args - Arguments to filter Categories to delete.
     * @example
     * // Delete a few Categories
     * const { count } = await prisma.category.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends categoryDeleteManyArgs>(
      args?: SelectSubset<T, categoryDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {categoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Categories
     * const category = await prisma.category.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends categoryUpdateManyArgs>(
      args: SelectSubset<T, categoryUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Category.
     * @param {categoryUpsertArgs} args - Arguments to update or create a Category.
     * @example
     * // Update or create a Category
     * const category = await prisma.category.upsert({
     *   create: {
     *     // ... data to create a Category
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Category we want to update
     *   }
     * })
    **/
    upsert<T extends categoryUpsertArgs>(
      args: SelectSubset<T, categoryUpsertArgs>
    ): CheckSelect<T, Prisma__categoryClient<category>, Prisma__categoryClient<categoryGetPayload<T>>>

    /**
     * Find one Category that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {categoryFindUniqueOrThrowArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends categoryFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, categoryFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__categoryClient<category>, Prisma__categoryClient<categoryGetPayload<T>>>

    /**
     * Find the first Category that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {categoryFindFirstOrThrowArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends categoryFindFirstOrThrowArgs>(
      args?: SelectSubset<T, categoryFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__categoryClient<category>, Prisma__categoryClient<categoryGetPayload<T>>>

    /**
     * Count the number of Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {categoryCountArgs} args - Arguments to filter Categories to count.
     * @example
     * // Count the number of Categories
     * const count = await prisma.category.count({
     *   where: {
     *     // ... the filter for the Categories we want to count
     *   }
     * })
    **/
    count<T extends categoryCountArgs>(
      args?: Subset<T, categoryCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Category.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CategoryAggregateArgs>(args: Subset<T, CategoryAggregateArgs>): PrismaPromise<GetCategoryAggregateType<T>>

    /**
     * Group by Category.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CategoryGroupByArgs['orderBy'] }
        : { orderBy?: CategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCategoryGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for category.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__categoryClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    classes_categoryToclasses_category1_id<T extends classesFindManyArgs = {}>(args?: Subset<T, classesFindManyArgs>): CheckSelect<T, PrismaPromise<Array<classes>>, PrismaPromise<Array<classesGetPayload<T>>>>;

    classes_categoryToclasses_category2_id<T extends classesFindManyArgs = {}>(args?: Subset<T, classesFindManyArgs>): CheckSelect<T, PrismaPromise<Array<classes>>, PrismaPromise<Array<classesGetPayload<T>>>>;

    classes_categoryToclasses_category3_id<T extends classesFindManyArgs = {}>(args?: Subset<T, classesFindManyArgs>): CheckSelect<T, PrismaPromise<Array<classes>>, PrismaPromise<Array<classesGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * category base type for findUnique actions
   */
  export type categoryFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the category
     * 
    **/
    select?: categorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: categoryInclude | null
    /**
     * Filter, which category to fetch.
     * 
    **/
    where: categoryWhereUniqueInput
  }

  /**
   * category: findUnique
   */
  export interface categoryFindUniqueArgs extends categoryFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * category base type for findFirst actions
   */
  export type categoryFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the category
     * 
    **/
    select?: categorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: categoryInclude | null
    /**
     * Filter, which category to fetch.
     * 
    **/
    where?: categoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of categories to fetch.
     * 
    **/
    orderBy?: Enumerable<categoryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for categories.
     * 
    **/
    cursor?: categoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` categories from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` categories.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of categories.
     * 
    **/
    distinct?: Enumerable<CategoryScalarFieldEnum>
  }

  /**
   * category: findFirst
   */
  export interface categoryFindFirstArgs extends categoryFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * category findMany
   */
  export type categoryFindManyArgs = {
    /**
     * Select specific fields to fetch from the category
     * 
    **/
    select?: categorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: categoryInclude | null
    /**
     * Filter, which categories to fetch.
     * 
    **/
    where?: categoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of categories to fetch.
     * 
    **/
    orderBy?: Enumerable<categoryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing categories.
     * 
    **/
    cursor?: categoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` categories from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` categories.
     * 
    **/
    skip?: number
    distinct?: Enumerable<CategoryScalarFieldEnum>
  }


  /**
   * category create
   */
  export type categoryCreateArgs = {
    /**
     * Select specific fields to fetch from the category
     * 
    **/
    select?: categorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: categoryInclude | null
    /**
     * The data needed to create a category.
     * 
    **/
    data: XOR<categoryCreateInput, categoryUncheckedCreateInput>
  }


  /**
   * category createMany
   */
  export type categoryCreateManyArgs = {
    /**
     * The data used to create many categories.
     * 
    **/
    data: Enumerable<categoryCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * category update
   */
  export type categoryUpdateArgs = {
    /**
     * Select specific fields to fetch from the category
     * 
    **/
    select?: categorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: categoryInclude | null
    /**
     * The data needed to update a category.
     * 
    **/
    data: XOR<categoryUpdateInput, categoryUncheckedUpdateInput>
    /**
     * Choose, which category to update.
     * 
    **/
    where: categoryWhereUniqueInput
  }


  /**
   * category updateMany
   */
  export type categoryUpdateManyArgs = {
    /**
     * The data used to update categories.
     * 
    **/
    data: XOR<categoryUpdateManyMutationInput, categoryUncheckedUpdateManyInput>
    /**
     * Filter which categories to update
     * 
    **/
    where?: categoryWhereInput
  }


  /**
   * category upsert
   */
  export type categoryUpsertArgs = {
    /**
     * Select specific fields to fetch from the category
     * 
    **/
    select?: categorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: categoryInclude | null
    /**
     * The filter to search for the category to update in case it exists.
     * 
    **/
    where: categoryWhereUniqueInput
    /**
     * In case the category found by the `where` argument doesn't exist, create a new category with this data.
     * 
    **/
    create: XOR<categoryCreateInput, categoryUncheckedCreateInput>
    /**
     * In case the category was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<categoryUpdateInput, categoryUncheckedUpdateInput>
  }


  /**
   * category delete
   */
  export type categoryDeleteArgs = {
    /**
     * Select specific fields to fetch from the category
     * 
    **/
    select?: categorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: categoryInclude | null
    /**
     * Filter which category to delete.
     * 
    **/
    where: categoryWhereUniqueInput
  }


  /**
   * category deleteMany
   */
  export type categoryDeleteManyArgs = {
    /**
     * Filter which categories to delete
     * 
    **/
    where?: categoryWhereInput
  }


  /**
   * category: findUniqueOrThrow
   */
  export type categoryFindUniqueOrThrowArgs = categoryFindUniqueArgsBase
      

  /**
   * category: findFirstOrThrow
   */
  export type categoryFindFirstOrThrowArgs = categoryFindFirstArgsBase
      

  /**
   * category without action
   */
  export type categoryArgs = {
    /**
     * Select specific fields to fetch from the category
     * 
    **/
    select?: categorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: categoryInclude | null
  }



  /**
   * Model class_img
   */


  export type AggregateClass_img = {
    _count: Class_imgCountAggregateOutputType | null
    _avg: Class_imgAvgAggregateOutputType | null
    _sum: Class_imgSumAggregateOutputType | null
    _min: Class_imgMinAggregateOutputType | null
    _max: Class_imgMaxAggregateOutputType | null
  }

  export type Class_imgAvgAggregateOutputType = {
    id: number | null
    class_id: number | null
  }

  export type Class_imgSumAggregateOutputType = {
    id: number | null
    class_id: number | null
  }

  export type Class_imgMinAggregateOutputType = {
    id: number | null
    url: string | null
    class_id: number | null
  }

  export type Class_imgMaxAggregateOutputType = {
    id: number | null
    url: string | null
    class_id: number | null
  }

  export type Class_imgCountAggregateOutputType = {
    id: number
    url: number
    class_id: number
    _all: number
  }


  export type Class_imgAvgAggregateInputType = {
    id?: true
    class_id?: true
  }

  export type Class_imgSumAggregateInputType = {
    id?: true
    class_id?: true
  }

  export type Class_imgMinAggregateInputType = {
    id?: true
    url?: true
    class_id?: true
  }

  export type Class_imgMaxAggregateInputType = {
    id?: true
    url?: true
    class_id?: true
  }

  export type Class_imgCountAggregateInputType = {
    id?: true
    url?: true
    class_id?: true
    _all?: true
  }

  export type Class_imgAggregateArgs = {
    /**
     * Filter which class_img to aggregate.
     * 
    **/
    where?: class_imgWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of class_imgs to fetch.
     * 
    **/
    orderBy?: Enumerable<class_imgOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: class_imgWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` class_imgs from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` class_imgs.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned class_imgs
    **/
    _count?: true | Class_imgCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Class_imgAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Class_imgSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Class_imgMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Class_imgMaxAggregateInputType
  }

  export type GetClass_imgAggregateType<T extends Class_imgAggregateArgs> = {
        [P in keyof T & keyof AggregateClass_img]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClass_img[P]>
      : GetScalarType<T[P], AggregateClass_img[P]>
  }




  export type Class_imgGroupByArgs = {
    where?: class_imgWhereInput
    orderBy?: Enumerable<class_imgOrderByWithAggregationInput>
    by: Array<Class_imgScalarFieldEnum>
    having?: class_imgScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Class_imgCountAggregateInputType | true
    _avg?: Class_imgAvgAggregateInputType
    _sum?: Class_imgSumAggregateInputType
    _min?: Class_imgMinAggregateInputType
    _max?: Class_imgMaxAggregateInputType
  }


  export type Class_imgGroupByOutputType = {
    id: number
    url: string
    class_id: number
    _count: Class_imgCountAggregateOutputType | null
    _avg: Class_imgAvgAggregateOutputType | null
    _sum: Class_imgSumAggregateOutputType | null
    _min: Class_imgMinAggregateOutputType | null
    _max: Class_imgMaxAggregateOutputType | null
  }

  type GetClass_imgGroupByPayload<T extends Class_imgGroupByArgs> = PrismaPromise<
    Array<
      PickArray<Class_imgGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Class_imgGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Class_imgGroupByOutputType[P]>
            : GetScalarType<T[P], Class_imgGroupByOutputType[P]>
        }
      >
    >


  export type class_imgSelect = {
    id?: boolean
    url?: boolean
    class_id?: boolean
    classes?: boolean | classesArgs
  }

  export type class_imgInclude = {
    classes?: boolean | classesArgs
  }

  export type class_imgGetPayload<
    S extends boolean | null | undefined | class_imgArgs,
    U = keyof S
      > = S extends true
        ? class_img
    : S extends undefined
    ? never
    : S extends class_imgArgs | class_imgFindManyArgs
    ?'include' extends U
    ? class_img  & {
    [P in TrueKeys<S['include']>]:
        P extends 'classes' ? classesGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'classes' ? classesGetPayload<S['select'][P]> :  P extends keyof class_img ? class_img[P] : never
  } 
    : class_img
  : class_img


  type class_imgCountArgs = Merge<
    Omit<class_imgFindManyArgs, 'select' | 'include'> & {
      select?: Class_imgCountAggregateInputType | true
    }
  >

  export interface class_imgDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Class_img that matches the filter.
     * @param {class_imgFindUniqueArgs} args - Arguments to find a Class_img
     * @example
     * // Get one Class_img
     * const class_img = await prisma.class_img.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends class_imgFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, class_imgFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'class_img'> extends True ? CheckSelect<T, Prisma__class_imgClient<class_img>, Prisma__class_imgClient<class_imgGetPayload<T>>> : CheckSelect<T, Prisma__class_imgClient<class_img | null >, Prisma__class_imgClient<class_imgGetPayload<T> | null >>

    /**
     * Find the first Class_img that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {class_imgFindFirstArgs} args - Arguments to find a Class_img
     * @example
     * // Get one Class_img
     * const class_img = await prisma.class_img.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends class_imgFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, class_imgFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'class_img'> extends True ? CheckSelect<T, Prisma__class_imgClient<class_img>, Prisma__class_imgClient<class_imgGetPayload<T>>> : CheckSelect<T, Prisma__class_imgClient<class_img | null >, Prisma__class_imgClient<class_imgGetPayload<T> | null >>

    /**
     * Find zero or more Class_imgs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {class_imgFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Class_imgs
     * const class_imgs = await prisma.class_img.findMany()
     * 
     * // Get first 10 Class_imgs
     * const class_imgs = await prisma.class_img.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const class_imgWithIdOnly = await prisma.class_img.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends class_imgFindManyArgs>(
      args?: SelectSubset<T, class_imgFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<class_img>>, PrismaPromise<Array<class_imgGetPayload<T>>>>

    /**
     * Create a Class_img.
     * @param {class_imgCreateArgs} args - Arguments to create a Class_img.
     * @example
     * // Create one Class_img
     * const Class_img = await prisma.class_img.create({
     *   data: {
     *     // ... data to create a Class_img
     *   }
     * })
     * 
    **/
    create<T extends class_imgCreateArgs>(
      args: SelectSubset<T, class_imgCreateArgs>
    ): CheckSelect<T, Prisma__class_imgClient<class_img>, Prisma__class_imgClient<class_imgGetPayload<T>>>

    /**
     * Create many Class_imgs.
     *     @param {class_imgCreateManyArgs} args - Arguments to create many Class_imgs.
     *     @example
     *     // Create many Class_imgs
     *     const class_img = await prisma.class_img.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends class_imgCreateManyArgs>(
      args?: SelectSubset<T, class_imgCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Class_img.
     * @param {class_imgDeleteArgs} args - Arguments to delete one Class_img.
     * @example
     * // Delete one Class_img
     * const Class_img = await prisma.class_img.delete({
     *   where: {
     *     // ... filter to delete one Class_img
     *   }
     * })
     * 
    **/
    delete<T extends class_imgDeleteArgs>(
      args: SelectSubset<T, class_imgDeleteArgs>
    ): CheckSelect<T, Prisma__class_imgClient<class_img>, Prisma__class_imgClient<class_imgGetPayload<T>>>

    /**
     * Update one Class_img.
     * @param {class_imgUpdateArgs} args - Arguments to update one Class_img.
     * @example
     * // Update one Class_img
     * const class_img = await prisma.class_img.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends class_imgUpdateArgs>(
      args: SelectSubset<T, class_imgUpdateArgs>
    ): CheckSelect<T, Prisma__class_imgClient<class_img>, Prisma__class_imgClient<class_imgGetPayload<T>>>

    /**
     * Delete zero or more Class_imgs.
     * @param {class_imgDeleteManyArgs} args - Arguments to filter Class_imgs to delete.
     * @example
     * // Delete a few Class_imgs
     * const { count } = await prisma.class_img.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends class_imgDeleteManyArgs>(
      args?: SelectSubset<T, class_imgDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Class_imgs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {class_imgUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Class_imgs
     * const class_img = await prisma.class_img.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends class_imgUpdateManyArgs>(
      args: SelectSubset<T, class_imgUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Class_img.
     * @param {class_imgUpsertArgs} args - Arguments to update or create a Class_img.
     * @example
     * // Update or create a Class_img
     * const class_img = await prisma.class_img.upsert({
     *   create: {
     *     // ... data to create a Class_img
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Class_img we want to update
     *   }
     * })
    **/
    upsert<T extends class_imgUpsertArgs>(
      args: SelectSubset<T, class_imgUpsertArgs>
    ): CheckSelect<T, Prisma__class_imgClient<class_img>, Prisma__class_imgClient<class_imgGetPayload<T>>>

    /**
     * Find one Class_img that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {class_imgFindUniqueOrThrowArgs} args - Arguments to find a Class_img
     * @example
     * // Get one Class_img
     * const class_img = await prisma.class_img.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends class_imgFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, class_imgFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__class_imgClient<class_img>, Prisma__class_imgClient<class_imgGetPayload<T>>>

    /**
     * Find the first Class_img that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {class_imgFindFirstOrThrowArgs} args - Arguments to find a Class_img
     * @example
     * // Get one Class_img
     * const class_img = await prisma.class_img.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends class_imgFindFirstOrThrowArgs>(
      args?: SelectSubset<T, class_imgFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__class_imgClient<class_img>, Prisma__class_imgClient<class_imgGetPayload<T>>>

    /**
     * Count the number of Class_imgs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {class_imgCountArgs} args - Arguments to filter Class_imgs to count.
     * @example
     * // Count the number of Class_imgs
     * const count = await prisma.class_img.count({
     *   where: {
     *     // ... the filter for the Class_imgs we want to count
     *   }
     * })
    **/
    count<T extends class_imgCountArgs>(
      args?: Subset<T, class_imgCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Class_imgCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Class_img.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Class_imgAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Class_imgAggregateArgs>(args: Subset<T, Class_imgAggregateArgs>): PrismaPromise<GetClass_imgAggregateType<T>>

    /**
     * Group by Class_img.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Class_imgGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Class_imgGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Class_imgGroupByArgs['orderBy'] }
        : { orderBy?: Class_imgGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Class_imgGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClass_imgGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for class_img.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__class_imgClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    classes<T extends classesArgs = {}>(args?: Subset<T, classesArgs>): CheckSelect<T, Prisma__classesClient<classes | null >, Prisma__classesClient<classesGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * class_img base type for findUnique actions
   */
  export type class_imgFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the class_img
     * 
    **/
    select?: class_imgSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: class_imgInclude | null
    /**
     * Filter, which class_img to fetch.
     * 
    **/
    where: class_imgWhereUniqueInput
  }

  /**
   * class_img: findUnique
   */
  export interface class_imgFindUniqueArgs extends class_imgFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * class_img base type for findFirst actions
   */
  export type class_imgFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the class_img
     * 
    **/
    select?: class_imgSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: class_imgInclude | null
    /**
     * Filter, which class_img to fetch.
     * 
    **/
    where?: class_imgWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of class_imgs to fetch.
     * 
    **/
    orderBy?: Enumerable<class_imgOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for class_imgs.
     * 
    **/
    cursor?: class_imgWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` class_imgs from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` class_imgs.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of class_imgs.
     * 
    **/
    distinct?: Enumerable<Class_imgScalarFieldEnum>
  }

  /**
   * class_img: findFirst
   */
  export interface class_imgFindFirstArgs extends class_imgFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * class_img findMany
   */
  export type class_imgFindManyArgs = {
    /**
     * Select specific fields to fetch from the class_img
     * 
    **/
    select?: class_imgSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: class_imgInclude | null
    /**
     * Filter, which class_imgs to fetch.
     * 
    **/
    where?: class_imgWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of class_imgs to fetch.
     * 
    **/
    orderBy?: Enumerable<class_imgOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing class_imgs.
     * 
    **/
    cursor?: class_imgWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` class_imgs from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` class_imgs.
     * 
    **/
    skip?: number
    distinct?: Enumerable<Class_imgScalarFieldEnum>
  }


  /**
   * class_img create
   */
  export type class_imgCreateArgs = {
    /**
     * Select specific fields to fetch from the class_img
     * 
    **/
    select?: class_imgSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: class_imgInclude | null
    /**
     * The data needed to create a class_img.
     * 
    **/
    data: XOR<class_imgCreateInput, class_imgUncheckedCreateInput>
  }


  /**
   * class_img createMany
   */
  export type class_imgCreateManyArgs = {
    /**
     * The data used to create many class_imgs.
     * 
    **/
    data: Enumerable<class_imgCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * class_img update
   */
  export type class_imgUpdateArgs = {
    /**
     * Select specific fields to fetch from the class_img
     * 
    **/
    select?: class_imgSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: class_imgInclude | null
    /**
     * The data needed to update a class_img.
     * 
    **/
    data: XOR<class_imgUpdateInput, class_imgUncheckedUpdateInput>
    /**
     * Choose, which class_img to update.
     * 
    **/
    where: class_imgWhereUniqueInput
  }


  /**
   * class_img updateMany
   */
  export type class_imgUpdateManyArgs = {
    /**
     * The data used to update class_imgs.
     * 
    **/
    data: XOR<class_imgUpdateManyMutationInput, class_imgUncheckedUpdateManyInput>
    /**
     * Filter which class_imgs to update
     * 
    **/
    where?: class_imgWhereInput
  }


  /**
   * class_img upsert
   */
  export type class_imgUpsertArgs = {
    /**
     * Select specific fields to fetch from the class_img
     * 
    **/
    select?: class_imgSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: class_imgInclude | null
    /**
     * The filter to search for the class_img to update in case it exists.
     * 
    **/
    where: class_imgWhereUniqueInput
    /**
     * In case the class_img found by the `where` argument doesn't exist, create a new class_img with this data.
     * 
    **/
    create: XOR<class_imgCreateInput, class_imgUncheckedCreateInput>
    /**
     * In case the class_img was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<class_imgUpdateInput, class_imgUncheckedUpdateInput>
  }


  /**
   * class_img delete
   */
  export type class_imgDeleteArgs = {
    /**
     * Select specific fields to fetch from the class_img
     * 
    **/
    select?: class_imgSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: class_imgInclude | null
    /**
     * Filter which class_img to delete.
     * 
    **/
    where: class_imgWhereUniqueInput
  }


  /**
   * class_img deleteMany
   */
  export type class_imgDeleteManyArgs = {
    /**
     * Filter which class_imgs to delete
     * 
    **/
    where?: class_imgWhereInput
  }


  /**
   * class_img: findUniqueOrThrow
   */
  export type class_imgFindUniqueOrThrowArgs = class_imgFindUniqueArgsBase
      

  /**
   * class_img: findFirstOrThrow
   */
  export type class_imgFindFirstOrThrowArgs = class_imgFindFirstArgsBase
      

  /**
   * class_img without action
   */
  export type class_imgArgs = {
    /**
     * Select specific fields to fetch from the class_img
     * 
    **/
    select?: class_imgSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: class_imgInclude | null
  }



  /**
   * Model classes
   */


  export type AggregateClasses = {
    _count: ClassesCountAggregateOutputType | null
    _avg: ClassesAvgAggregateOutputType | null
    _sum: ClassesSumAggregateOutputType | null
    _min: ClassesMinAggregateOutputType | null
    _max: ClassesMaxAggregateOutputType | null
  }

  export type ClassesAvgAggregateOutputType = {
    id: number | null
    instructor_id: number | null
    price: number | null
    rate: number | null
    students: number | null
    sessions: number | null
    price_scope: number | null
    category1_id: number | null
    category2_id: number | null
    category3_id: number | null
    level_id: number | null
  }

  export type ClassesSumAggregateOutputType = {
    id: number | null
    instructor_id: number | null
    price: number | null
    rate: number | null
    students: number | null
    sessions: number | null
    price_scope: number | null
    category1_id: number | null
    category2_id: number | null
    category3_id: number | null
    level_id: number | null
  }

  export type ClassesMinAggregateOutputType = {
    id: number | null
    name: string | null
    instructor_id: number | null
    price: number | null
    img: string | null
    rate: number | null
    description: string | null
    students: number | null
    sessions: number | null
    price_scope: number | null
    category1_id: number | null
    category2_id: number | null
    category3_id: number | null
    level_id: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type ClassesMaxAggregateOutputType = {
    id: number | null
    name: string | null
    instructor_id: number | null
    price: number | null
    img: string | null
    rate: number | null
    description: string | null
    students: number | null
    sessions: number | null
    price_scope: number | null
    category1_id: number | null
    category2_id: number | null
    category3_id: number | null
    level_id: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type ClassesCountAggregateOutputType = {
    id: number
    name: number
    instructor_id: number
    price: number
    img: number
    rate: number
    description: number
    students: number
    sessions: number
    price_scope: number
    category1_id: number
    category2_id: number
    category3_id: number
    level_id: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type ClassesAvgAggregateInputType = {
    id?: true
    instructor_id?: true
    price?: true
    rate?: true
    students?: true
    sessions?: true
    price_scope?: true
    category1_id?: true
    category2_id?: true
    category3_id?: true
    level_id?: true
  }

  export type ClassesSumAggregateInputType = {
    id?: true
    instructor_id?: true
    price?: true
    rate?: true
    students?: true
    sessions?: true
    price_scope?: true
    category1_id?: true
    category2_id?: true
    category3_id?: true
    level_id?: true
  }

  export type ClassesMinAggregateInputType = {
    id?: true
    name?: true
    instructor_id?: true
    price?: true
    img?: true
    rate?: true
    description?: true
    students?: true
    sessions?: true
    price_scope?: true
    category1_id?: true
    category2_id?: true
    category3_id?: true
    level_id?: true
    created_at?: true
    updated_at?: true
  }

  export type ClassesMaxAggregateInputType = {
    id?: true
    name?: true
    instructor_id?: true
    price?: true
    img?: true
    rate?: true
    description?: true
    students?: true
    sessions?: true
    price_scope?: true
    category1_id?: true
    category2_id?: true
    category3_id?: true
    level_id?: true
    created_at?: true
    updated_at?: true
  }

  export type ClassesCountAggregateInputType = {
    id?: true
    name?: true
    instructor_id?: true
    price?: true
    img?: true
    rate?: true
    description?: true
    students?: true
    sessions?: true
    price_scope?: true
    category1_id?: true
    category2_id?: true
    category3_id?: true
    level_id?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type ClassesAggregateArgs = {
    /**
     * Filter which classes to aggregate.
     * 
    **/
    where?: classesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of classes to fetch.
     * 
    **/
    orderBy?: Enumerable<classesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: classesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` classes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` classes.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned classes
    **/
    _count?: true | ClassesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ClassesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ClassesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClassesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClassesMaxAggregateInputType
  }

  export type GetClassesAggregateType<T extends ClassesAggregateArgs> = {
        [P in keyof T & keyof AggregateClasses]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClasses[P]>
      : GetScalarType<T[P], AggregateClasses[P]>
  }




  export type ClassesGroupByArgs = {
    where?: classesWhereInput
    orderBy?: Enumerable<classesOrderByWithAggregationInput>
    by: Array<ClassesScalarFieldEnum>
    having?: classesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClassesCountAggregateInputType | true
    _avg?: ClassesAvgAggregateInputType
    _sum?: ClassesSumAggregateInputType
    _min?: ClassesMinAggregateInputType
    _max?: ClassesMaxAggregateInputType
  }


  export type ClassesGroupByOutputType = {
    id: number
    name: string
    instructor_id: number
    price: number | null
    img: string | null
    rate: number | null
    description: string | null
    students: number | null
    sessions: number | null
    price_scope: number | null
    category1_id: number | null
    category2_id: number | null
    category3_id: number | null
    level_id: number | null
    created_at: Date | null
    updated_at: Date | null
    _count: ClassesCountAggregateOutputType | null
    _avg: ClassesAvgAggregateOutputType | null
    _sum: ClassesSumAggregateOutputType | null
    _min: ClassesMinAggregateOutputType | null
    _max: ClassesMaxAggregateOutputType | null
  }

  type GetClassesGroupByPayload<T extends ClassesGroupByArgs> = PrismaPromise<
    Array<
      PickArray<ClassesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClassesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClassesGroupByOutputType[P]>
            : GetScalarType<T[P], ClassesGroupByOutputType[P]>
        }
      >
    >


  export type classesSelect = {
    id?: boolean
    name?: boolean
    instructor_id?: boolean
    price?: boolean
    img?: boolean
    rate?: boolean
    description?: boolean
    students?: boolean
    sessions?: boolean
    price_scope?: boolean
    category1_id?: boolean
    category2_id?: boolean
    category3_id?: boolean
    level_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    category_categoryToclasses_category1_id?: boolean | categoryArgs
    category_categoryToclasses_category2_id?: boolean | categoryArgs
    category_categoryToclasses_category3_id?: boolean | categoryArgs
    instructor?: boolean | instructorArgs
    level?: boolean | levelArgs
    price_scope_classesToprice_scope?: boolean | price_scopeArgs
    class_img?: boolean | class_imgFindManyArgs
    contents?: boolean | contentsFindManyArgs
    my_classes?: boolean | my_classesFindManyArgs
    review?: boolean | reviewFindManyArgs
    wishlist?: boolean | wishlistFindManyArgs
    _count?: boolean | ClassesCountOutputTypeArgs
  }

  export type classesInclude = {
    category_categoryToclasses_category1_id?: boolean | categoryArgs
    category_categoryToclasses_category2_id?: boolean | categoryArgs
    category_categoryToclasses_category3_id?: boolean | categoryArgs
    instructor?: boolean | instructorArgs
    level?: boolean | levelArgs
    price_scope_classesToprice_scope?: boolean | price_scopeArgs
    class_img?: boolean | class_imgFindManyArgs
    contents?: boolean | contentsFindManyArgs
    my_classes?: boolean | my_classesFindManyArgs
    review?: boolean | reviewFindManyArgs
    wishlist?: boolean | wishlistFindManyArgs
    _count?: boolean | ClassesCountOutputTypeArgs
  }

  export type classesGetPayload<
    S extends boolean | null | undefined | classesArgs,
    U = keyof S
      > = S extends true
        ? classes
    : S extends undefined
    ? never
    : S extends classesArgs | classesFindManyArgs
    ?'include' extends U
    ? classes  & {
    [P in TrueKeys<S['include']>]:
        P extends 'category_categoryToclasses_category1_id' ? categoryGetPayload<S['include'][P]> | null :
        P extends 'category_categoryToclasses_category2_id' ? categoryGetPayload<S['include'][P]> | null :
        P extends 'category_categoryToclasses_category3_id' ? categoryGetPayload<S['include'][P]> | null :
        P extends 'instructor' ? instructorGetPayload<S['include'][P]> :
        P extends 'level' ? levelGetPayload<S['include'][P]> | null :
        P extends 'price_scope_classesToprice_scope' ? price_scopeGetPayload<S['include'][P]> | null :
        P extends 'class_img' ? Array < class_imgGetPayload<S['include'][P]>>  :
        P extends 'contents' ? Array < contentsGetPayload<S['include'][P]>>  :
        P extends 'my_classes' ? Array < my_classesGetPayload<S['include'][P]>>  :
        P extends 'review' ? Array < reviewGetPayload<S['include'][P]>>  :
        P extends 'wishlist' ? Array < wishlistGetPayload<S['include'][P]>>  :
        P extends '_count' ? ClassesCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'category_categoryToclasses_category1_id' ? categoryGetPayload<S['select'][P]> | null :
        P extends 'category_categoryToclasses_category2_id' ? categoryGetPayload<S['select'][P]> | null :
        P extends 'category_categoryToclasses_category3_id' ? categoryGetPayload<S['select'][P]> | null :
        P extends 'instructor' ? instructorGetPayload<S['select'][P]> :
        P extends 'level' ? levelGetPayload<S['select'][P]> | null :
        P extends 'price_scope_classesToprice_scope' ? price_scopeGetPayload<S['select'][P]> | null :
        P extends 'class_img' ? Array < class_imgGetPayload<S['select'][P]>>  :
        P extends 'contents' ? Array < contentsGetPayload<S['select'][P]>>  :
        P extends 'my_classes' ? Array < my_classesGetPayload<S['select'][P]>>  :
        P extends 'review' ? Array < reviewGetPayload<S['select'][P]>>  :
        P extends 'wishlist' ? Array < wishlistGetPayload<S['select'][P]>>  :
        P extends '_count' ? ClassesCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof classes ? classes[P] : never
  } 
    : classes
  : classes


  type classesCountArgs = Merge<
    Omit<classesFindManyArgs, 'select' | 'include'> & {
      select?: ClassesCountAggregateInputType | true
    }
  >

  export interface classesDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Classes that matches the filter.
     * @param {classesFindUniqueArgs} args - Arguments to find a Classes
     * @example
     * // Get one Classes
     * const classes = await prisma.classes.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends classesFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, classesFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'classes'> extends True ? CheckSelect<T, Prisma__classesClient<classes>, Prisma__classesClient<classesGetPayload<T>>> : CheckSelect<T, Prisma__classesClient<classes | null >, Prisma__classesClient<classesGetPayload<T> | null >>

    /**
     * Find the first Classes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {classesFindFirstArgs} args - Arguments to find a Classes
     * @example
     * // Get one Classes
     * const classes = await prisma.classes.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends classesFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, classesFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'classes'> extends True ? CheckSelect<T, Prisma__classesClient<classes>, Prisma__classesClient<classesGetPayload<T>>> : CheckSelect<T, Prisma__classesClient<classes | null >, Prisma__classesClient<classesGetPayload<T> | null >>

    /**
     * Find zero or more Classes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {classesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Classes
     * const classes = await prisma.classes.findMany()
     * 
     * // Get first 10 Classes
     * const classes = await prisma.classes.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const classesWithIdOnly = await prisma.classes.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends classesFindManyArgs>(
      args?: SelectSubset<T, classesFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<classes>>, PrismaPromise<Array<classesGetPayload<T>>>>

    /**
     * Create a Classes.
     * @param {classesCreateArgs} args - Arguments to create a Classes.
     * @example
     * // Create one Classes
     * const Classes = await prisma.classes.create({
     *   data: {
     *     // ... data to create a Classes
     *   }
     * })
     * 
    **/
    create<T extends classesCreateArgs>(
      args: SelectSubset<T, classesCreateArgs>
    ): CheckSelect<T, Prisma__classesClient<classes>, Prisma__classesClient<classesGetPayload<T>>>

    /**
     * Create many Classes.
     *     @param {classesCreateManyArgs} args - Arguments to create many Classes.
     *     @example
     *     // Create many Classes
     *     const classes = await prisma.classes.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends classesCreateManyArgs>(
      args?: SelectSubset<T, classesCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Classes.
     * @param {classesDeleteArgs} args - Arguments to delete one Classes.
     * @example
     * // Delete one Classes
     * const Classes = await prisma.classes.delete({
     *   where: {
     *     // ... filter to delete one Classes
     *   }
     * })
     * 
    **/
    delete<T extends classesDeleteArgs>(
      args: SelectSubset<T, classesDeleteArgs>
    ): CheckSelect<T, Prisma__classesClient<classes>, Prisma__classesClient<classesGetPayload<T>>>

    /**
     * Update one Classes.
     * @param {classesUpdateArgs} args - Arguments to update one Classes.
     * @example
     * // Update one Classes
     * const classes = await prisma.classes.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends classesUpdateArgs>(
      args: SelectSubset<T, classesUpdateArgs>
    ): CheckSelect<T, Prisma__classesClient<classes>, Prisma__classesClient<classesGetPayload<T>>>

    /**
     * Delete zero or more Classes.
     * @param {classesDeleteManyArgs} args - Arguments to filter Classes to delete.
     * @example
     * // Delete a few Classes
     * const { count } = await prisma.classes.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends classesDeleteManyArgs>(
      args?: SelectSubset<T, classesDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Classes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {classesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Classes
     * const classes = await prisma.classes.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends classesUpdateManyArgs>(
      args: SelectSubset<T, classesUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Classes.
     * @param {classesUpsertArgs} args - Arguments to update or create a Classes.
     * @example
     * // Update or create a Classes
     * const classes = await prisma.classes.upsert({
     *   create: {
     *     // ... data to create a Classes
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Classes we want to update
     *   }
     * })
    **/
    upsert<T extends classesUpsertArgs>(
      args: SelectSubset<T, classesUpsertArgs>
    ): CheckSelect<T, Prisma__classesClient<classes>, Prisma__classesClient<classesGetPayload<T>>>

    /**
     * Find one Classes that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {classesFindUniqueOrThrowArgs} args - Arguments to find a Classes
     * @example
     * // Get one Classes
     * const classes = await prisma.classes.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends classesFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, classesFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__classesClient<classes>, Prisma__classesClient<classesGetPayload<T>>>

    /**
     * Find the first Classes that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {classesFindFirstOrThrowArgs} args - Arguments to find a Classes
     * @example
     * // Get one Classes
     * const classes = await prisma.classes.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends classesFindFirstOrThrowArgs>(
      args?: SelectSubset<T, classesFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__classesClient<classes>, Prisma__classesClient<classesGetPayload<T>>>

    /**
     * Count the number of Classes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {classesCountArgs} args - Arguments to filter Classes to count.
     * @example
     * // Count the number of Classes
     * const count = await prisma.classes.count({
     *   where: {
     *     // ... the filter for the Classes we want to count
     *   }
     * })
    **/
    count<T extends classesCountArgs>(
      args?: Subset<T, classesCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClassesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Classes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClassesAggregateArgs>(args: Subset<T, ClassesAggregateArgs>): PrismaPromise<GetClassesAggregateType<T>>

    /**
     * Group by Classes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClassesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClassesGroupByArgs['orderBy'] }
        : { orderBy?: ClassesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClassesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClassesGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for classes.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__classesClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    category_categoryToclasses_category1_id<T extends categoryArgs = {}>(args?: Subset<T, categoryArgs>): CheckSelect<T, Prisma__categoryClient<category | null >, Prisma__categoryClient<categoryGetPayload<T> | null >>;

    category_categoryToclasses_category2_id<T extends categoryArgs = {}>(args?: Subset<T, categoryArgs>): CheckSelect<T, Prisma__categoryClient<category | null >, Prisma__categoryClient<categoryGetPayload<T> | null >>;

    category_categoryToclasses_category3_id<T extends categoryArgs = {}>(args?: Subset<T, categoryArgs>): CheckSelect<T, Prisma__categoryClient<category | null >, Prisma__categoryClient<categoryGetPayload<T> | null >>;

    instructor<T extends instructorArgs = {}>(args?: Subset<T, instructorArgs>): CheckSelect<T, Prisma__instructorClient<instructor | null >, Prisma__instructorClient<instructorGetPayload<T> | null >>;

    level<T extends levelArgs = {}>(args?: Subset<T, levelArgs>): CheckSelect<T, Prisma__levelClient<level | null >, Prisma__levelClient<levelGetPayload<T> | null >>;

    price_scope_classesToprice_scope<T extends price_scopeArgs = {}>(args?: Subset<T, price_scopeArgs>): CheckSelect<T, Prisma__price_scopeClient<price_scope | null >, Prisma__price_scopeClient<price_scopeGetPayload<T> | null >>;

    class_img<T extends class_imgFindManyArgs = {}>(args?: Subset<T, class_imgFindManyArgs>): CheckSelect<T, PrismaPromise<Array<class_img>>, PrismaPromise<Array<class_imgGetPayload<T>>>>;

    contents<T extends contentsFindManyArgs = {}>(args?: Subset<T, contentsFindManyArgs>): CheckSelect<T, PrismaPromise<Array<contents>>, PrismaPromise<Array<contentsGetPayload<T>>>>;

    my_classes<T extends my_classesFindManyArgs = {}>(args?: Subset<T, my_classesFindManyArgs>): CheckSelect<T, PrismaPromise<Array<my_classes>>, PrismaPromise<Array<my_classesGetPayload<T>>>>;

    review<T extends reviewFindManyArgs = {}>(args?: Subset<T, reviewFindManyArgs>): CheckSelect<T, PrismaPromise<Array<review>>, PrismaPromise<Array<reviewGetPayload<T>>>>;

    wishlist<T extends wishlistFindManyArgs = {}>(args?: Subset<T, wishlistFindManyArgs>): CheckSelect<T, PrismaPromise<Array<wishlist>>, PrismaPromise<Array<wishlistGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * classes base type for findUnique actions
   */
  export type classesFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the classes
     * 
    **/
    select?: classesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: classesInclude | null
    /**
     * Filter, which classes to fetch.
     * 
    **/
    where: classesWhereUniqueInput
  }

  /**
   * classes: findUnique
   */
  export interface classesFindUniqueArgs extends classesFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * classes base type for findFirst actions
   */
  export type classesFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the classes
     * 
    **/
    select?: classesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: classesInclude | null
    /**
     * Filter, which classes to fetch.
     * 
    **/
    where?: classesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of classes to fetch.
     * 
    **/
    orderBy?: Enumerable<classesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for classes.
     * 
    **/
    cursor?: classesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` classes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` classes.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of classes.
     * 
    **/
    distinct?: Enumerable<ClassesScalarFieldEnum>
  }

  /**
   * classes: findFirst
   */
  export interface classesFindFirstArgs extends classesFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * classes findMany
   */
  export type classesFindManyArgs = {
    /**
     * Select specific fields to fetch from the classes
     * 
    **/
    select?: classesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: classesInclude | null
    /**
     * Filter, which classes to fetch.
     * 
    **/
    where?: classesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of classes to fetch.
     * 
    **/
    orderBy?: Enumerable<classesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing classes.
     * 
    **/
    cursor?: classesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` classes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` classes.
     * 
    **/
    skip?: number
    distinct?: Enumerable<ClassesScalarFieldEnum>
  }


  /**
   * classes create
   */
  export type classesCreateArgs = {
    /**
     * Select specific fields to fetch from the classes
     * 
    **/
    select?: classesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: classesInclude | null
    /**
     * The data needed to create a classes.
     * 
    **/
    data: XOR<classesCreateInput, classesUncheckedCreateInput>
  }


  /**
   * classes createMany
   */
  export type classesCreateManyArgs = {
    /**
     * The data used to create many classes.
     * 
    **/
    data: Enumerable<classesCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * classes update
   */
  export type classesUpdateArgs = {
    /**
     * Select specific fields to fetch from the classes
     * 
    **/
    select?: classesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: classesInclude | null
    /**
     * The data needed to update a classes.
     * 
    **/
    data: XOR<classesUpdateInput, classesUncheckedUpdateInput>
    /**
     * Choose, which classes to update.
     * 
    **/
    where: classesWhereUniqueInput
  }


  /**
   * classes updateMany
   */
  export type classesUpdateManyArgs = {
    /**
     * The data used to update classes.
     * 
    **/
    data: XOR<classesUpdateManyMutationInput, classesUncheckedUpdateManyInput>
    /**
     * Filter which classes to update
     * 
    **/
    where?: classesWhereInput
  }


  /**
   * classes upsert
   */
  export type classesUpsertArgs = {
    /**
     * Select specific fields to fetch from the classes
     * 
    **/
    select?: classesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: classesInclude | null
    /**
     * The filter to search for the classes to update in case it exists.
     * 
    **/
    where: classesWhereUniqueInput
    /**
     * In case the classes found by the `where` argument doesn't exist, create a new classes with this data.
     * 
    **/
    create: XOR<classesCreateInput, classesUncheckedCreateInput>
    /**
     * In case the classes was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<classesUpdateInput, classesUncheckedUpdateInput>
  }


  /**
   * classes delete
   */
  export type classesDeleteArgs = {
    /**
     * Select specific fields to fetch from the classes
     * 
    **/
    select?: classesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: classesInclude | null
    /**
     * Filter which classes to delete.
     * 
    **/
    where: classesWhereUniqueInput
  }


  /**
   * classes deleteMany
   */
  export type classesDeleteManyArgs = {
    /**
     * Filter which classes to delete
     * 
    **/
    where?: classesWhereInput
  }


  /**
   * classes: findUniqueOrThrow
   */
  export type classesFindUniqueOrThrowArgs = classesFindUniqueArgsBase
      

  /**
   * classes: findFirstOrThrow
   */
  export type classesFindFirstOrThrowArgs = classesFindFirstArgsBase
      

  /**
   * classes without action
   */
  export type classesArgs = {
    /**
     * Select specific fields to fetch from the classes
     * 
    **/
    select?: classesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: classesInclude | null
  }



  /**
   * Model contents
   */


  export type AggregateContents = {
    _count: ContentsCountAggregateOutputType | null
    _avg: ContentsAvgAggregateOutputType | null
    _sum: ContentsSumAggregateOutputType | null
    _min: ContentsMinAggregateOutputType | null
    _max: ContentsMaxAggregateOutputType | null
  }

  export type ContentsAvgAggregateOutputType = {
    id: number | null
    class_id: number | null
  }

  export type ContentsSumAggregateOutputType = {
    id: number | null
    class_id: number | null
  }

  export type ContentsMinAggregateOutputType = {
    id: number | null
    class_id: number | null
    content: string | null
  }

  export type ContentsMaxAggregateOutputType = {
    id: number | null
    class_id: number | null
    content: string | null
  }

  export type ContentsCountAggregateOutputType = {
    id: number
    class_id: number
    content: number
    _all: number
  }


  export type ContentsAvgAggregateInputType = {
    id?: true
    class_id?: true
  }

  export type ContentsSumAggregateInputType = {
    id?: true
    class_id?: true
  }

  export type ContentsMinAggregateInputType = {
    id?: true
    class_id?: true
    content?: true
  }

  export type ContentsMaxAggregateInputType = {
    id?: true
    class_id?: true
    content?: true
  }

  export type ContentsCountAggregateInputType = {
    id?: true
    class_id?: true
    content?: true
    _all?: true
  }

  export type ContentsAggregateArgs = {
    /**
     * Filter which contents to aggregate.
     * 
    **/
    where?: contentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of contents to fetch.
     * 
    **/
    orderBy?: Enumerable<contentsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: contentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` contents from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` contents.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned contents
    **/
    _count?: true | ContentsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ContentsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ContentsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ContentsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ContentsMaxAggregateInputType
  }

  export type GetContentsAggregateType<T extends ContentsAggregateArgs> = {
        [P in keyof T & keyof AggregateContents]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContents[P]>
      : GetScalarType<T[P], AggregateContents[P]>
  }




  export type ContentsGroupByArgs = {
    where?: contentsWhereInput
    orderBy?: Enumerable<contentsOrderByWithAggregationInput>
    by: Array<ContentsScalarFieldEnum>
    having?: contentsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ContentsCountAggregateInputType | true
    _avg?: ContentsAvgAggregateInputType
    _sum?: ContentsSumAggregateInputType
    _min?: ContentsMinAggregateInputType
    _max?: ContentsMaxAggregateInputType
  }


  export type ContentsGroupByOutputType = {
    id: number
    class_id: number
    content: string | null
    _count: ContentsCountAggregateOutputType | null
    _avg: ContentsAvgAggregateOutputType | null
    _sum: ContentsSumAggregateOutputType | null
    _min: ContentsMinAggregateOutputType | null
    _max: ContentsMaxAggregateOutputType | null
  }

  type GetContentsGroupByPayload<T extends ContentsGroupByArgs> = PrismaPromise<
    Array<
      PickArray<ContentsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ContentsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ContentsGroupByOutputType[P]>
            : GetScalarType<T[P], ContentsGroupByOutputType[P]>
        }
      >
    >


  export type contentsSelect = {
    id?: boolean
    class_id?: boolean
    content?: boolean
    classes?: boolean | classesArgs
  }

  export type contentsInclude = {
    classes?: boolean | classesArgs
  }

  export type contentsGetPayload<
    S extends boolean | null | undefined | contentsArgs,
    U = keyof S
      > = S extends true
        ? contents
    : S extends undefined
    ? never
    : S extends contentsArgs | contentsFindManyArgs
    ?'include' extends U
    ? contents  & {
    [P in TrueKeys<S['include']>]:
        P extends 'classes' ? classesGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'classes' ? classesGetPayload<S['select'][P]> :  P extends keyof contents ? contents[P] : never
  } 
    : contents
  : contents


  type contentsCountArgs = Merge<
    Omit<contentsFindManyArgs, 'select' | 'include'> & {
      select?: ContentsCountAggregateInputType | true
    }
  >

  export interface contentsDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Contents that matches the filter.
     * @param {contentsFindUniqueArgs} args - Arguments to find a Contents
     * @example
     * // Get one Contents
     * const contents = await prisma.contents.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends contentsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, contentsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'contents'> extends True ? CheckSelect<T, Prisma__contentsClient<contents>, Prisma__contentsClient<contentsGetPayload<T>>> : CheckSelect<T, Prisma__contentsClient<contents | null >, Prisma__contentsClient<contentsGetPayload<T> | null >>

    /**
     * Find the first Contents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {contentsFindFirstArgs} args - Arguments to find a Contents
     * @example
     * // Get one Contents
     * const contents = await prisma.contents.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends contentsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, contentsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'contents'> extends True ? CheckSelect<T, Prisma__contentsClient<contents>, Prisma__contentsClient<contentsGetPayload<T>>> : CheckSelect<T, Prisma__contentsClient<contents | null >, Prisma__contentsClient<contentsGetPayload<T> | null >>

    /**
     * Find zero or more Contents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {contentsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Contents
     * const contents = await prisma.contents.findMany()
     * 
     * // Get first 10 Contents
     * const contents = await prisma.contents.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const contentsWithIdOnly = await prisma.contents.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends contentsFindManyArgs>(
      args?: SelectSubset<T, contentsFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<contents>>, PrismaPromise<Array<contentsGetPayload<T>>>>

    /**
     * Create a Contents.
     * @param {contentsCreateArgs} args - Arguments to create a Contents.
     * @example
     * // Create one Contents
     * const Contents = await prisma.contents.create({
     *   data: {
     *     // ... data to create a Contents
     *   }
     * })
     * 
    **/
    create<T extends contentsCreateArgs>(
      args: SelectSubset<T, contentsCreateArgs>
    ): CheckSelect<T, Prisma__contentsClient<contents>, Prisma__contentsClient<contentsGetPayload<T>>>

    /**
     * Create many Contents.
     *     @param {contentsCreateManyArgs} args - Arguments to create many Contents.
     *     @example
     *     // Create many Contents
     *     const contents = await prisma.contents.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends contentsCreateManyArgs>(
      args?: SelectSubset<T, contentsCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Contents.
     * @param {contentsDeleteArgs} args - Arguments to delete one Contents.
     * @example
     * // Delete one Contents
     * const Contents = await prisma.contents.delete({
     *   where: {
     *     // ... filter to delete one Contents
     *   }
     * })
     * 
    **/
    delete<T extends contentsDeleteArgs>(
      args: SelectSubset<T, contentsDeleteArgs>
    ): CheckSelect<T, Prisma__contentsClient<contents>, Prisma__contentsClient<contentsGetPayload<T>>>

    /**
     * Update one Contents.
     * @param {contentsUpdateArgs} args - Arguments to update one Contents.
     * @example
     * // Update one Contents
     * const contents = await prisma.contents.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends contentsUpdateArgs>(
      args: SelectSubset<T, contentsUpdateArgs>
    ): CheckSelect<T, Prisma__contentsClient<contents>, Prisma__contentsClient<contentsGetPayload<T>>>

    /**
     * Delete zero or more Contents.
     * @param {contentsDeleteManyArgs} args - Arguments to filter Contents to delete.
     * @example
     * // Delete a few Contents
     * const { count } = await prisma.contents.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends contentsDeleteManyArgs>(
      args?: SelectSubset<T, contentsDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Contents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {contentsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Contents
     * const contents = await prisma.contents.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends contentsUpdateManyArgs>(
      args: SelectSubset<T, contentsUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Contents.
     * @param {contentsUpsertArgs} args - Arguments to update or create a Contents.
     * @example
     * // Update or create a Contents
     * const contents = await prisma.contents.upsert({
     *   create: {
     *     // ... data to create a Contents
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Contents we want to update
     *   }
     * })
    **/
    upsert<T extends contentsUpsertArgs>(
      args: SelectSubset<T, contentsUpsertArgs>
    ): CheckSelect<T, Prisma__contentsClient<contents>, Prisma__contentsClient<contentsGetPayload<T>>>

    /**
     * Find one Contents that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {contentsFindUniqueOrThrowArgs} args - Arguments to find a Contents
     * @example
     * // Get one Contents
     * const contents = await prisma.contents.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends contentsFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, contentsFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__contentsClient<contents>, Prisma__contentsClient<contentsGetPayload<T>>>

    /**
     * Find the first Contents that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {contentsFindFirstOrThrowArgs} args - Arguments to find a Contents
     * @example
     * // Get one Contents
     * const contents = await prisma.contents.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends contentsFindFirstOrThrowArgs>(
      args?: SelectSubset<T, contentsFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__contentsClient<contents>, Prisma__contentsClient<contentsGetPayload<T>>>

    /**
     * Count the number of Contents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {contentsCountArgs} args - Arguments to filter Contents to count.
     * @example
     * // Count the number of Contents
     * const count = await prisma.contents.count({
     *   where: {
     *     // ... the filter for the Contents we want to count
     *   }
     * })
    **/
    count<T extends contentsCountArgs>(
      args?: Subset<T, contentsCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ContentsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Contents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ContentsAggregateArgs>(args: Subset<T, ContentsAggregateArgs>): PrismaPromise<GetContentsAggregateType<T>>

    /**
     * Group by Contents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ContentsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ContentsGroupByArgs['orderBy'] }
        : { orderBy?: ContentsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ContentsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContentsGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for contents.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__contentsClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    classes<T extends classesArgs = {}>(args?: Subset<T, classesArgs>): CheckSelect<T, Prisma__classesClient<classes | null >, Prisma__classesClient<classesGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * contents base type for findUnique actions
   */
  export type contentsFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the contents
     * 
    **/
    select?: contentsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: contentsInclude | null
    /**
     * Filter, which contents to fetch.
     * 
    **/
    where: contentsWhereUniqueInput
  }

  /**
   * contents: findUnique
   */
  export interface contentsFindUniqueArgs extends contentsFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * contents base type for findFirst actions
   */
  export type contentsFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the contents
     * 
    **/
    select?: contentsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: contentsInclude | null
    /**
     * Filter, which contents to fetch.
     * 
    **/
    where?: contentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of contents to fetch.
     * 
    **/
    orderBy?: Enumerable<contentsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for contents.
     * 
    **/
    cursor?: contentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` contents from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` contents.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of contents.
     * 
    **/
    distinct?: Enumerable<ContentsScalarFieldEnum>
  }

  /**
   * contents: findFirst
   */
  export interface contentsFindFirstArgs extends contentsFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * contents findMany
   */
  export type contentsFindManyArgs = {
    /**
     * Select specific fields to fetch from the contents
     * 
    **/
    select?: contentsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: contentsInclude | null
    /**
     * Filter, which contents to fetch.
     * 
    **/
    where?: contentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of contents to fetch.
     * 
    **/
    orderBy?: Enumerable<contentsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing contents.
     * 
    **/
    cursor?: contentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` contents from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` contents.
     * 
    **/
    skip?: number
    distinct?: Enumerable<ContentsScalarFieldEnum>
  }


  /**
   * contents create
   */
  export type contentsCreateArgs = {
    /**
     * Select specific fields to fetch from the contents
     * 
    **/
    select?: contentsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: contentsInclude | null
    /**
     * The data needed to create a contents.
     * 
    **/
    data: XOR<contentsCreateInput, contentsUncheckedCreateInput>
  }


  /**
   * contents createMany
   */
  export type contentsCreateManyArgs = {
    /**
     * The data used to create many contents.
     * 
    **/
    data: Enumerable<contentsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * contents update
   */
  export type contentsUpdateArgs = {
    /**
     * Select specific fields to fetch from the contents
     * 
    **/
    select?: contentsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: contentsInclude | null
    /**
     * The data needed to update a contents.
     * 
    **/
    data: XOR<contentsUpdateInput, contentsUncheckedUpdateInput>
    /**
     * Choose, which contents to update.
     * 
    **/
    where: contentsWhereUniqueInput
  }


  /**
   * contents updateMany
   */
  export type contentsUpdateManyArgs = {
    /**
     * The data used to update contents.
     * 
    **/
    data: XOR<contentsUpdateManyMutationInput, contentsUncheckedUpdateManyInput>
    /**
     * Filter which contents to update
     * 
    **/
    where?: contentsWhereInput
  }


  /**
   * contents upsert
   */
  export type contentsUpsertArgs = {
    /**
     * Select specific fields to fetch from the contents
     * 
    **/
    select?: contentsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: contentsInclude | null
    /**
     * The filter to search for the contents to update in case it exists.
     * 
    **/
    where: contentsWhereUniqueInput
    /**
     * In case the contents found by the `where` argument doesn't exist, create a new contents with this data.
     * 
    **/
    create: XOR<contentsCreateInput, contentsUncheckedCreateInput>
    /**
     * In case the contents was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<contentsUpdateInput, contentsUncheckedUpdateInput>
  }


  /**
   * contents delete
   */
  export type contentsDeleteArgs = {
    /**
     * Select specific fields to fetch from the contents
     * 
    **/
    select?: contentsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: contentsInclude | null
    /**
     * Filter which contents to delete.
     * 
    **/
    where: contentsWhereUniqueInput
  }


  /**
   * contents deleteMany
   */
  export type contentsDeleteManyArgs = {
    /**
     * Filter which contents to delete
     * 
    **/
    where?: contentsWhereInput
  }


  /**
   * contents: findUniqueOrThrow
   */
  export type contentsFindUniqueOrThrowArgs = contentsFindUniqueArgsBase
      

  /**
   * contents: findFirstOrThrow
   */
  export type contentsFindFirstOrThrowArgs = contentsFindFirstArgsBase
      

  /**
   * contents without action
   */
  export type contentsArgs = {
    /**
     * Select specific fields to fetch from the contents
     * 
    **/
    select?: contentsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: contentsInclude | null
  }



  /**
   * Model instructor
   */


  export type AggregateInstructor = {
    _count: InstructorCountAggregateOutputType | null
    _avg: InstructorAvgAggregateOutputType | null
    _sum: InstructorSumAggregateOutputType | null
    _min: InstructorMinAggregateOutputType | null
    _max: InstructorMaxAggregateOutputType | null
  }

  export type InstructorAvgAggregateOutputType = {
    id: number | null
  }

  export type InstructorSumAggregateOutputType = {
    id: number | null
  }

  export type InstructorMinAggregateOutputType = {
    id: number | null
    name: string | null
  }

  export type InstructorMaxAggregateOutputType = {
    id: number | null
    name: string | null
  }

  export type InstructorCountAggregateOutputType = {
    id: number
    name: number
    _all: number
  }


  export type InstructorAvgAggregateInputType = {
    id?: true
  }

  export type InstructorSumAggregateInputType = {
    id?: true
  }

  export type InstructorMinAggregateInputType = {
    id?: true
    name?: true
  }

  export type InstructorMaxAggregateInputType = {
    id?: true
    name?: true
  }

  export type InstructorCountAggregateInputType = {
    id?: true
    name?: true
    _all?: true
  }

  export type InstructorAggregateArgs = {
    /**
     * Filter which instructor to aggregate.
     * 
    **/
    where?: instructorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of instructors to fetch.
     * 
    **/
    orderBy?: Enumerable<instructorOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: instructorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` instructors from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` instructors.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned instructors
    **/
    _count?: true | InstructorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InstructorAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InstructorSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InstructorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InstructorMaxAggregateInputType
  }

  export type GetInstructorAggregateType<T extends InstructorAggregateArgs> = {
        [P in keyof T & keyof AggregateInstructor]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInstructor[P]>
      : GetScalarType<T[P], AggregateInstructor[P]>
  }




  export type InstructorGroupByArgs = {
    where?: instructorWhereInput
    orderBy?: Enumerable<instructorOrderByWithAggregationInput>
    by: Array<InstructorScalarFieldEnum>
    having?: instructorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InstructorCountAggregateInputType | true
    _avg?: InstructorAvgAggregateInputType
    _sum?: InstructorSumAggregateInputType
    _min?: InstructorMinAggregateInputType
    _max?: InstructorMaxAggregateInputType
  }


  export type InstructorGroupByOutputType = {
    id: number
    name: string
    _count: InstructorCountAggregateOutputType | null
    _avg: InstructorAvgAggregateOutputType | null
    _sum: InstructorSumAggregateOutputType | null
    _min: InstructorMinAggregateOutputType | null
    _max: InstructorMaxAggregateOutputType | null
  }

  type GetInstructorGroupByPayload<T extends InstructorGroupByArgs> = PrismaPromise<
    Array<
      PickArray<InstructorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InstructorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InstructorGroupByOutputType[P]>
            : GetScalarType<T[P], InstructorGroupByOutputType[P]>
        }
      >
    >


  export type instructorSelect = {
    id?: boolean
    name?: boolean
    classes?: boolean | classesFindManyArgs
    _count?: boolean | InstructorCountOutputTypeArgs
  }

  export type instructorInclude = {
    classes?: boolean | classesFindManyArgs
    _count?: boolean | InstructorCountOutputTypeArgs
  }

  export type instructorGetPayload<
    S extends boolean | null | undefined | instructorArgs,
    U = keyof S
      > = S extends true
        ? instructor
    : S extends undefined
    ? never
    : S extends instructorArgs | instructorFindManyArgs
    ?'include' extends U
    ? instructor  & {
    [P in TrueKeys<S['include']>]:
        P extends 'classes' ? Array < classesGetPayload<S['include'][P]>>  :
        P extends '_count' ? InstructorCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'classes' ? Array < classesGetPayload<S['select'][P]>>  :
        P extends '_count' ? InstructorCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof instructor ? instructor[P] : never
  } 
    : instructor
  : instructor


  type instructorCountArgs = Merge<
    Omit<instructorFindManyArgs, 'select' | 'include'> & {
      select?: InstructorCountAggregateInputType | true
    }
  >

  export interface instructorDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Instructor that matches the filter.
     * @param {instructorFindUniqueArgs} args - Arguments to find a Instructor
     * @example
     * // Get one Instructor
     * const instructor = await prisma.instructor.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends instructorFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, instructorFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'instructor'> extends True ? CheckSelect<T, Prisma__instructorClient<instructor>, Prisma__instructorClient<instructorGetPayload<T>>> : CheckSelect<T, Prisma__instructorClient<instructor | null >, Prisma__instructorClient<instructorGetPayload<T> | null >>

    /**
     * Find the first Instructor that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {instructorFindFirstArgs} args - Arguments to find a Instructor
     * @example
     * // Get one Instructor
     * const instructor = await prisma.instructor.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends instructorFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, instructorFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'instructor'> extends True ? CheckSelect<T, Prisma__instructorClient<instructor>, Prisma__instructorClient<instructorGetPayload<T>>> : CheckSelect<T, Prisma__instructorClient<instructor | null >, Prisma__instructorClient<instructorGetPayload<T> | null >>

    /**
     * Find zero or more Instructors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {instructorFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Instructors
     * const instructors = await prisma.instructor.findMany()
     * 
     * // Get first 10 Instructors
     * const instructors = await prisma.instructor.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const instructorWithIdOnly = await prisma.instructor.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends instructorFindManyArgs>(
      args?: SelectSubset<T, instructorFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<instructor>>, PrismaPromise<Array<instructorGetPayload<T>>>>

    /**
     * Create a Instructor.
     * @param {instructorCreateArgs} args - Arguments to create a Instructor.
     * @example
     * // Create one Instructor
     * const Instructor = await prisma.instructor.create({
     *   data: {
     *     // ... data to create a Instructor
     *   }
     * })
     * 
    **/
    create<T extends instructorCreateArgs>(
      args: SelectSubset<T, instructorCreateArgs>
    ): CheckSelect<T, Prisma__instructorClient<instructor>, Prisma__instructorClient<instructorGetPayload<T>>>

    /**
     * Create many Instructors.
     *     @param {instructorCreateManyArgs} args - Arguments to create many Instructors.
     *     @example
     *     // Create many Instructors
     *     const instructor = await prisma.instructor.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends instructorCreateManyArgs>(
      args?: SelectSubset<T, instructorCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Instructor.
     * @param {instructorDeleteArgs} args - Arguments to delete one Instructor.
     * @example
     * // Delete one Instructor
     * const Instructor = await prisma.instructor.delete({
     *   where: {
     *     // ... filter to delete one Instructor
     *   }
     * })
     * 
    **/
    delete<T extends instructorDeleteArgs>(
      args: SelectSubset<T, instructorDeleteArgs>
    ): CheckSelect<T, Prisma__instructorClient<instructor>, Prisma__instructorClient<instructorGetPayload<T>>>

    /**
     * Update one Instructor.
     * @param {instructorUpdateArgs} args - Arguments to update one Instructor.
     * @example
     * // Update one Instructor
     * const instructor = await prisma.instructor.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends instructorUpdateArgs>(
      args: SelectSubset<T, instructorUpdateArgs>
    ): CheckSelect<T, Prisma__instructorClient<instructor>, Prisma__instructorClient<instructorGetPayload<T>>>

    /**
     * Delete zero or more Instructors.
     * @param {instructorDeleteManyArgs} args - Arguments to filter Instructors to delete.
     * @example
     * // Delete a few Instructors
     * const { count } = await prisma.instructor.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends instructorDeleteManyArgs>(
      args?: SelectSubset<T, instructorDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Instructors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {instructorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Instructors
     * const instructor = await prisma.instructor.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends instructorUpdateManyArgs>(
      args: SelectSubset<T, instructorUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Instructor.
     * @param {instructorUpsertArgs} args - Arguments to update or create a Instructor.
     * @example
     * // Update or create a Instructor
     * const instructor = await prisma.instructor.upsert({
     *   create: {
     *     // ... data to create a Instructor
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Instructor we want to update
     *   }
     * })
    **/
    upsert<T extends instructorUpsertArgs>(
      args: SelectSubset<T, instructorUpsertArgs>
    ): CheckSelect<T, Prisma__instructorClient<instructor>, Prisma__instructorClient<instructorGetPayload<T>>>

    /**
     * Find one Instructor that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {instructorFindUniqueOrThrowArgs} args - Arguments to find a Instructor
     * @example
     * // Get one Instructor
     * const instructor = await prisma.instructor.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends instructorFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, instructorFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__instructorClient<instructor>, Prisma__instructorClient<instructorGetPayload<T>>>

    /**
     * Find the first Instructor that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {instructorFindFirstOrThrowArgs} args - Arguments to find a Instructor
     * @example
     * // Get one Instructor
     * const instructor = await prisma.instructor.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends instructorFindFirstOrThrowArgs>(
      args?: SelectSubset<T, instructorFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__instructorClient<instructor>, Prisma__instructorClient<instructorGetPayload<T>>>

    /**
     * Count the number of Instructors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {instructorCountArgs} args - Arguments to filter Instructors to count.
     * @example
     * // Count the number of Instructors
     * const count = await prisma.instructor.count({
     *   where: {
     *     // ... the filter for the Instructors we want to count
     *   }
     * })
    **/
    count<T extends instructorCountArgs>(
      args?: Subset<T, instructorCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InstructorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Instructor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstructorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InstructorAggregateArgs>(args: Subset<T, InstructorAggregateArgs>): PrismaPromise<GetInstructorAggregateType<T>>

    /**
     * Group by Instructor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstructorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InstructorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InstructorGroupByArgs['orderBy'] }
        : { orderBy?: InstructorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InstructorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInstructorGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for instructor.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__instructorClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    classes<T extends classesFindManyArgs = {}>(args?: Subset<T, classesFindManyArgs>): CheckSelect<T, PrismaPromise<Array<classes>>, PrismaPromise<Array<classesGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * instructor base type for findUnique actions
   */
  export type instructorFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the instructor
     * 
    **/
    select?: instructorSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: instructorInclude | null
    /**
     * Filter, which instructor to fetch.
     * 
    **/
    where: instructorWhereUniqueInput
  }

  /**
   * instructor: findUnique
   */
  export interface instructorFindUniqueArgs extends instructorFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * instructor base type for findFirst actions
   */
  export type instructorFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the instructor
     * 
    **/
    select?: instructorSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: instructorInclude | null
    /**
     * Filter, which instructor to fetch.
     * 
    **/
    where?: instructorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of instructors to fetch.
     * 
    **/
    orderBy?: Enumerable<instructorOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for instructors.
     * 
    **/
    cursor?: instructorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` instructors from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` instructors.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of instructors.
     * 
    **/
    distinct?: Enumerable<InstructorScalarFieldEnum>
  }

  /**
   * instructor: findFirst
   */
  export interface instructorFindFirstArgs extends instructorFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * instructor findMany
   */
  export type instructorFindManyArgs = {
    /**
     * Select specific fields to fetch from the instructor
     * 
    **/
    select?: instructorSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: instructorInclude | null
    /**
     * Filter, which instructors to fetch.
     * 
    **/
    where?: instructorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of instructors to fetch.
     * 
    **/
    orderBy?: Enumerable<instructorOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing instructors.
     * 
    **/
    cursor?: instructorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` instructors from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` instructors.
     * 
    **/
    skip?: number
    distinct?: Enumerable<InstructorScalarFieldEnum>
  }


  /**
   * instructor create
   */
  export type instructorCreateArgs = {
    /**
     * Select specific fields to fetch from the instructor
     * 
    **/
    select?: instructorSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: instructorInclude | null
    /**
     * The data needed to create a instructor.
     * 
    **/
    data: XOR<instructorCreateInput, instructorUncheckedCreateInput>
  }


  /**
   * instructor createMany
   */
  export type instructorCreateManyArgs = {
    /**
     * The data used to create many instructors.
     * 
    **/
    data: Enumerable<instructorCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * instructor update
   */
  export type instructorUpdateArgs = {
    /**
     * Select specific fields to fetch from the instructor
     * 
    **/
    select?: instructorSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: instructorInclude | null
    /**
     * The data needed to update a instructor.
     * 
    **/
    data: XOR<instructorUpdateInput, instructorUncheckedUpdateInput>
    /**
     * Choose, which instructor to update.
     * 
    **/
    where: instructorWhereUniqueInput
  }


  /**
   * instructor updateMany
   */
  export type instructorUpdateManyArgs = {
    /**
     * The data used to update instructors.
     * 
    **/
    data: XOR<instructorUpdateManyMutationInput, instructorUncheckedUpdateManyInput>
    /**
     * Filter which instructors to update
     * 
    **/
    where?: instructorWhereInput
  }


  /**
   * instructor upsert
   */
  export type instructorUpsertArgs = {
    /**
     * Select specific fields to fetch from the instructor
     * 
    **/
    select?: instructorSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: instructorInclude | null
    /**
     * The filter to search for the instructor to update in case it exists.
     * 
    **/
    where: instructorWhereUniqueInput
    /**
     * In case the instructor found by the `where` argument doesn't exist, create a new instructor with this data.
     * 
    **/
    create: XOR<instructorCreateInput, instructorUncheckedCreateInput>
    /**
     * In case the instructor was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<instructorUpdateInput, instructorUncheckedUpdateInput>
  }


  /**
   * instructor delete
   */
  export type instructorDeleteArgs = {
    /**
     * Select specific fields to fetch from the instructor
     * 
    **/
    select?: instructorSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: instructorInclude | null
    /**
     * Filter which instructor to delete.
     * 
    **/
    where: instructorWhereUniqueInput
  }


  /**
   * instructor deleteMany
   */
  export type instructorDeleteManyArgs = {
    /**
     * Filter which instructors to delete
     * 
    **/
    where?: instructorWhereInput
  }


  /**
   * instructor: findUniqueOrThrow
   */
  export type instructorFindUniqueOrThrowArgs = instructorFindUniqueArgsBase
      

  /**
   * instructor: findFirstOrThrow
   */
  export type instructorFindFirstOrThrowArgs = instructorFindFirstArgsBase
      

  /**
   * instructor without action
   */
  export type instructorArgs = {
    /**
     * Select specific fields to fetch from the instructor
     * 
    **/
    select?: instructorSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: instructorInclude | null
  }



  /**
   * Model level
   */


  export type AggregateLevel = {
    _count: LevelCountAggregateOutputType | null
    _avg: LevelAvgAggregateOutputType | null
    _sum: LevelSumAggregateOutputType | null
    _min: LevelMinAggregateOutputType | null
    _max: LevelMaxAggregateOutputType | null
  }

  export type LevelAvgAggregateOutputType = {
    id: number | null
  }

  export type LevelSumAggregateOutputType = {
    id: number | null
  }

  export type LevelMinAggregateOutputType = {
    id: number | null
    level: string | null
  }

  export type LevelMaxAggregateOutputType = {
    id: number | null
    level: string | null
  }

  export type LevelCountAggregateOutputType = {
    id: number
    level: number
    _all: number
  }


  export type LevelAvgAggregateInputType = {
    id?: true
  }

  export type LevelSumAggregateInputType = {
    id?: true
  }

  export type LevelMinAggregateInputType = {
    id?: true
    level?: true
  }

  export type LevelMaxAggregateInputType = {
    id?: true
    level?: true
  }

  export type LevelCountAggregateInputType = {
    id?: true
    level?: true
    _all?: true
  }

  export type LevelAggregateArgs = {
    /**
     * Filter which level to aggregate.
     * 
    **/
    where?: levelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of levels to fetch.
     * 
    **/
    orderBy?: Enumerable<levelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: levelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` levels from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` levels.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned levels
    **/
    _count?: true | LevelCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LevelAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LevelSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LevelMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LevelMaxAggregateInputType
  }

  export type GetLevelAggregateType<T extends LevelAggregateArgs> = {
        [P in keyof T & keyof AggregateLevel]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLevel[P]>
      : GetScalarType<T[P], AggregateLevel[P]>
  }




  export type LevelGroupByArgs = {
    where?: levelWhereInput
    orderBy?: Enumerable<levelOrderByWithAggregationInput>
    by: Array<LevelScalarFieldEnum>
    having?: levelScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LevelCountAggregateInputType | true
    _avg?: LevelAvgAggregateInputType
    _sum?: LevelSumAggregateInputType
    _min?: LevelMinAggregateInputType
    _max?: LevelMaxAggregateInputType
  }


  export type LevelGroupByOutputType = {
    id: number
    level: string
    _count: LevelCountAggregateOutputType | null
    _avg: LevelAvgAggregateOutputType | null
    _sum: LevelSumAggregateOutputType | null
    _min: LevelMinAggregateOutputType | null
    _max: LevelMaxAggregateOutputType | null
  }

  type GetLevelGroupByPayload<T extends LevelGroupByArgs> = PrismaPromise<
    Array<
      PickArray<LevelGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LevelGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LevelGroupByOutputType[P]>
            : GetScalarType<T[P], LevelGroupByOutputType[P]>
        }
      >
    >


  export type levelSelect = {
    id?: boolean
    level?: boolean
    classes?: boolean | classesFindManyArgs
    _count?: boolean | LevelCountOutputTypeArgs
  }

  export type levelInclude = {
    classes?: boolean | classesFindManyArgs
    _count?: boolean | LevelCountOutputTypeArgs
  }

  export type levelGetPayload<
    S extends boolean | null | undefined | levelArgs,
    U = keyof S
      > = S extends true
        ? level
    : S extends undefined
    ? never
    : S extends levelArgs | levelFindManyArgs
    ?'include' extends U
    ? level  & {
    [P in TrueKeys<S['include']>]:
        P extends 'classes' ? Array < classesGetPayload<S['include'][P]>>  :
        P extends '_count' ? LevelCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'classes' ? Array < classesGetPayload<S['select'][P]>>  :
        P extends '_count' ? LevelCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof level ? level[P] : never
  } 
    : level
  : level


  type levelCountArgs = Merge<
    Omit<levelFindManyArgs, 'select' | 'include'> & {
      select?: LevelCountAggregateInputType | true
    }
  >

  export interface levelDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Level that matches the filter.
     * @param {levelFindUniqueArgs} args - Arguments to find a Level
     * @example
     * // Get one Level
     * const level = await prisma.level.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends levelFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, levelFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'level'> extends True ? CheckSelect<T, Prisma__levelClient<level>, Prisma__levelClient<levelGetPayload<T>>> : CheckSelect<T, Prisma__levelClient<level | null >, Prisma__levelClient<levelGetPayload<T> | null >>

    /**
     * Find the first Level that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {levelFindFirstArgs} args - Arguments to find a Level
     * @example
     * // Get one Level
     * const level = await prisma.level.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends levelFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, levelFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'level'> extends True ? CheckSelect<T, Prisma__levelClient<level>, Prisma__levelClient<levelGetPayload<T>>> : CheckSelect<T, Prisma__levelClient<level | null >, Prisma__levelClient<levelGetPayload<T> | null >>

    /**
     * Find zero or more Levels that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {levelFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Levels
     * const levels = await prisma.level.findMany()
     * 
     * // Get first 10 Levels
     * const levels = await prisma.level.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const levelWithIdOnly = await prisma.level.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends levelFindManyArgs>(
      args?: SelectSubset<T, levelFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<level>>, PrismaPromise<Array<levelGetPayload<T>>>>

    /**
     * Create a Level.
     * @param {levelCreateArgs} args - Arguments to create a Level.
     * @example
     * // Create one Level
     * const Level = await prisma.level.create({
     *   data: {
     *     // ... data to create a Level
     *   }
     * })
     * 
    **/
    create<T extends levelCreateArgs>(
      args: SelectSubset<T, levelCreateArgs>
    ): CheckSelect<T, Prisma__levelClient<level>, Prisma__levelClient<levelGetPayload<T>>>

    /**
     * Create many Levels.
     *     @param {levelCreateManyArgs} args - Arguments to create many Levels.
     *     @example
     *     // Create many Levels
     *     const level = await prisma.level.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends levelCreateManyArgs>(
      args?: SelectSubset<T, levelCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Level.
     * @param {levelDeleteArgs} args - Arguments to delete one Level.
     * @example
     * // Delete one Level
     * const Level = await prisma.level.delete({
     *   where: {
     *     // ... filter to delete one Level
     *   }
     * })
     * 
    **/
    delete<T extends levelDeleteArgs>(
      args: SelectSubset<T, levelDeleteArgs>
    ): CheckSelect<T, Prisma__levelClient<level>, Prisma__levelClient<levelGetPayload<T>>>

    /**
     * Update one Level.
     * @param {levelUpdateArgs} args - Arguments to update one Level.
     * @example
     * // Update one Level
     * const level = await prisma.level.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends levelUpdateArgs>(
      args: SelectSubset<T, levelUpdateArgs>
    ): CheckSelect<T, Prisma__levelClient<level>, Prisma__levelClient<levelGetPayload<T>>>

    /**
     * Delete zero or more Levels.
     * @param {levelDeleteManyArgs} args - Arguments to filter Levels to delete.
     * @example
     * // Delete a few Levels
     * const { count } = await prisma.level.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends levelDeleteManyArgs>(
      args?: SelectSubset<T, levelDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Levels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {levelUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Levels
     * const level = await prisma.level.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends levelUpdateManyArgs>(
      args: SelectSubset<T, levelUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Level.
     * @param {levelUpsertArgs} args - Arguments to update or create a Level.
     * @example
     * // Update or create a Level
     * const level = await prisma.level.upsert({
     *   create: {
     *     // ... data to create a Level
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Level we want to update
     *   }
     * })
    **/
    upsert<T extends levelUpsertArgs>(
      args: SelectSubset<T, levelUpsertArgs>
    ): CheckSelect<T, Prisma__levelClient<level>, Prisma__levelClient<levelGetPayload<T>>>

    /**
     * Find one Level that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {levelFindUniqueOrThrowArgs} args - Arguments to find a Level
     * @example
     * // Get one Level
     * const level = await prisma.level.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends levelFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, levelFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__levelClient<level>, Prisma__levelClient<levelGetPayload<T>>>

    /**
     * Find the first Level that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {levelFindFirstOrThrowArgs} args - Arguments to find a Level
     * @example
     * // Get one Level
     * const level = await prisma.level.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends levelFindFirstOrThrowArgs>(
      args?: SelectSubset<T, levelFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__levelClient<level>, Prisma__levelClient<levelGetPayload<T>>>

    /**
     * Count the number of Levels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {levelCountArgs} args - Arguments to filter Levels to count.
     * @example
     * // Count the number of Levels
     * const count = await prisma.level.count({
     *   where: {
     *     // ... the filter for the Levels we want to count
     *   }
     * })
    **/
    count<T extends levelCountArgs>(
      args?: Subset<T, levelCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LevelCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Level.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LevelAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LevelAggregateArgs>(args: Subset<T, LevelAggregateArgs>): PrismaPromise<GetLevelAggregateType<T>>

    /**
     * Group by Level.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LevelGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LevelGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LevelGroupByArgs['orderBy'] }
        : { orderBy?: LevelGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LevelGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLevelGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for level.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__levelClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    classes<T extends classesFindManyArgs = {}>(args?: Subset<T, classesFindManyArgs>): CheckSelect<T, PrismaPromise<Array<classes>>, PrismaPromise<Array<classesGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * level base type for findUnique actions
   */
  export type levelFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the level
     * 
    **/
    select?: levelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: levelInclude | null
    /**
     * Filter, which level to fetch.
     * 
    **/
    where: levelWhereUniqueInput
  }

  /**
   * level: findUnique
   */
  export interface levelFindUniqueArgs extends levelFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * level base type for findFirst actions
   */
  export type levelFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the level
     * 
    **/
    select?: levelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: levelInclude | null
    /**
     * Filter, which level to fetch.
     * 
    **/
    where?: levelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of levels to fetch.
     * 
    **/
    orderBy?: Enumerable<levelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for levels.
     * 
    **/
    cursor?: levelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` levels from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` levels.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of levels.
     * 
    **/
    distinct?: Enumerable<LevelScalarFieldEnum>
  }

  /**
   * level: findFirst
   */
  export interface levelFindFirstArgs extends levelFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * level findMany
   */
  export type levelFindManyArgs = {
    /**
     * Select specific fields to fetch from the level
     * 
    **/
    select?: levelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: levelInclude | null
    /**
     * Filter, which levels to fetch.
     * 
    **/
    where?: levelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of levels to fetch.
     * 
    **/
    orderBy?: Enumerable<levelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing levels.
     * 
    **/
    cursor?: levelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` levels from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` levels.
     * 
    **/
    skip?: number
    distinct?: Enumerable<LevelScalarFieldEnum>
  }


  /**
   * level create
   */
  export type levelCreateArgs = {
    /**
     * Select specific fields to fetch from the level
     * 
    **/
    select?: levelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: levelInclude | null
    /**
     * The data needed to create a level.
     * 
    **/
    data: XOR<levelCreateInput, levelUncheckedCreateInput>
  }


  /**
   * level createMany
   */
  export type levelCreateManyArgs = {
    /**
     * The data used to create many levels.
     * 
    **/
    data: Enumerable<levelCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * level update
   */
  export type levelUpdateArgs = {
    /**
     * Select specific fields to fetch from the level
     * 
    **/
    select?: levelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: levelInclude | null
    /**
     * The data needed to update a level.
     * 
    **/
    data: XOR<levelUpdateInput, levelUncheckedUpdateInput>
    /**
     * Choose, which level to update.
     * 
    **/
    where: levelWhereUniqueInput
  }


  /**
   * level updateMany
   */
  export type levelUpdateManyArgs = {
    /**
     * The data used to update levels.
     * 
    **/
    data: XOR<levelUpdateManyMutationInput, levelUncheckedUpdateManyInput>
    /**
     * Filter which levels to update
     * 
    **/
    where?: levelWhereInput
  }


  /**
   * level upsert
   */
  export type levelUpsertArgs = {
    /**
     * Select specific fields to fetch from the level
     * 
    **/
    select?: levelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: levelInclude | null
    /**
     * The filter to search for the level to update in case it exists.
     * 
    **/
    where: levelWhereUniqueInput
    /**
     * In case the level found by the `where` argument doesn't exist, create a new level with this data.
     * 
    **/
    create: XOR<levelCreateInput, levelUncheckedCreateInput>
    /**
     * In case the level was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<levelUpdateInput, levelUncheckedUpdateInput>
  }


  /**
   * level delete
   */
  export type levelDeleteArgs = {
    /**
     * Select specific fields to fetch from the level
     * 
    **/
    select?: levelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: levelInclude | null
    /**
     * Filter which level to delete.
     * 
    **/
    where: levelWhereUniqueInput
  }


  /**
   * level deleteMany
   */
  export type levelDeleteManyArgs = {
    /**
     * Filter which levels to delete
     * 
    **/
    where?: levelWhereInput
  }


  /**
   * level: findUniqueOrThrow
   */
  export type levelFindUniqueOrThrowArgs = levelFindUniqueArgsBase
      

  /**
   * level: findFirstOrThrow
   */
  export type levelFindFirstOrThrowArgs = levelFindFirstArgsBase
      

  /**
   * level without action
   */
  export type levelArgs = {
    /**
     * Select specific fields to fetch from the level
     * 
    **/
    select?: levelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: levelInclude | null
  }



  /**
   * Model my_classes
   */


  export type AggregateMy_classes = {
    _count: My_classesCountAggregateOutputType | null
    _avg: My_classesAvgAggregateOutputType | null
    _sum: My_classesSumAggregateOutputType | null
    _min: My_classesMinAggregateOutputType | null
    _max: My_classesMaxAggregateOutputType | null
  }

  export type My_classesAvgAggregateOutputType = {
    id: number | null
    user_id: number | null
    class_id: number | null
    progress: number | null
  }

  export type My_classesSumAggregateOutputType = {
    id: number | null
    user_id: number | null
    class_id: number | null
    progress: number | null
  }

  export type My_classesMinAggregateOutputType = {
    id: number | null
    user_id: number | null
    class_id: number | null
    progress: number | null
  }

  export type My_classesMaxAggregateOutputType = {
    id: number | null
    user_id: number | null
    class_id: number | null
    progress: number | null
  }

  export type My_classesCountAggregateOutputType = {
    id: number
    user_id: number
    class_id: number
    progress: number
    _all: number
  }


  export type My_classesAvgAggregateInputType = {
    id?: true
    user_id?: true
    class_id?: true
    progress?: true
  }

  export type My_classesSumAggregateInputType = {
    id?: true
    user_id?: true
    class_id?: true
    progress?: true
  }

  export type My_classesMinAggregateInputType = {
    id?: true
    user_id?: true
    class_id?: true
    progress?: true
  }

  export type My_classesMaxAggregateInputType = {
    id?: true
    user_id?: true
    class_id?: true
    progress?: true
  }

  export type My_classesCountAggregateInputType = {
    id?: true
    user_id?: true
    class_id?: true
    progress?: true
    _all?: true
  }

  export type My_classesAggregateArgs = {
    /**
     * Filter which my_classes to aggregate.
     * 
    **/
    where?: my_classesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of my_classes to fetch.
     * 
    **/
    orderBy?: Enumerable<my_classesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: my_classesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` my_classes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` my_classes.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned my_classes
    **/
    _count?: true | My_classesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: My_classesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: My_classesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: My_classesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: My_classesMaxAggregateInputType
  }

  export type GetMy_classesAggregateType<T extends My_classesAggregateArgs> = {
        [P in keyof T & keyof AggregateMy_classes]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMy_classes[P]>
      : GetScalarType<T[P], AggregateMy_classes[P]>
  }




  export type My_classesGroupByArgs = {
    where?: my_classesWhereInput
    orderBy?: Enumerable<my_classesOrderByWithAggregationInput>
    by: Array<My_classesScalarFieldEnum>
    having?: my_classesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: My_classesCountAggregateInputType | true
    _avg?: My_classesAvgAggregateInputType
    _sum?: My_classesSumAggregateInputType
    _min?: My_classesMinAggregateInputType
    _max?: My_classesMaxAggregateInputType
  }


  export type My_classesGroupByOutputType = {
    id: number
    user_id: number
    class_id: number
    progress: number
    _count: My_classesCountAggregateOutputType | null
    _avg: My_classesAvgAggregateOutputType | null
    _sum: My_classesSumAggregateOutputType | null
    _min: My_classesMinAggregateOutputType | null
    _max: My_classesMaxAggregateOutputType | null
  }

  type GetMy_classesGroupByPayload<T extends My_classesGroupByArgs> = PrismaPromise<
    Array<
      PickArray<My_classesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof My_classesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], My_classesGroupByOutputType[P]>
            : GetScalarType<T[P], My_classesGroupByOutputType[P]>
        }
      >
    >


  export type my_classesSelect = {
    id?: boolean
    user_id?: boolean
    class_id?: boolean
    progress?: boolean
    classes?: boolean | classesArgs
    users?: boolean | usersArgs
  }

  export type my_classesInclude = {
    classes?: boolean | classesArgs
    users?: boolean | usersArgs
  }

  export type my_classesGetPayload<
    S extends boolean | null | undefined | my_classesArgs,
    U = keyof S
      > = S extends true
        ? my_classes
    : S extends undefined
    ? never
    : S extends my_classesArgs | my_classesFindManyArgs
    ?'include' extends U
    ? my_classes  & {
    [P in TrueKeys<S['include']>]:
        P extends 'classes' ? classesGetPayload<S['include'][P]> :
        P extends 'users' ? usersGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'classes' ? classesGetPayload<S['select'][P]> :
        P extends 'users' ? usersGetPayload<S['select'][P]> :  P extends keyof my_classes ? my_classes[P] : never
  } 
    : my_classes
  : my_classes


  type my_classesCountArgs = Merge<
    Omit<my_classesFindManyArgs, 'select' | 'include'> & {
      select?: My_classesCountAggregateInputType | true
    }
  >

  export interface my_classesDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one My_classes that matches the filter.
     * @param {my_classesFindUniqueArgs} args - Arguments to find a My_classes
     * @example
     * // Get one My_classes
     * const my_classes = await prisma.my_classes.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends my_classesFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, my_classesFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'my_classes'> extends True ? CheckSelect<T, Prisma__my_classesClient<my_classes>, Prisma__my_classesClient<my_classesGetPayload<T>>> : CheckSelect<T, Prisma__my_classesClient<my_classes | null >, Prisma__my_classesClient<my_classesGetPayload<T> | null >>

    /**
     * Find the first My_classes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {my_classesFindFirstArgs} args - Arguments to find a My_classes
     * @example
     * // Get one My_classes
     * const my_classes = await prisma.my_classes.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends my_classesFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, my_classesFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'my_classes'> extends True ? CheckSelect<T, Prisma__my_classesClient<my_classes>, Prisma__my_classesClient<my_classesGetPayload<T>>> : CheckSelect<T, Prisma__my_classesClient<my_classes | null >, Prisma__my_classesClient<my_classesGetPayload<T> | null >>

    /**
     * Find zero or more My_classes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {my_classesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all My_classes
     * const my_classes = await prisma.my_classes.findMany()
     * 
     * // Get first 10 My_classes
     * const my_classes = await prisma.my_classes.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const my_classesWithIdOnly = await prisma.my_classes.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends my_classesFindManyArgs>(
      args?: SelectSubset<T, my_classesFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<my_classes>>, PrismaPromise<Array<my_classesGetPayload<T>>>>

    /**
     * Create a My_classes.
     * @param {my_classesCreateArgs} args - Arguments to create a My_classes.
     * @example
     * // Create one My_classes
     * const My_classes = await prisma.my_classes.create({
     *   data: {
     *     // ... data to create a My_classes
     *   }
     * })
     * 
    **/
    create<T extends my_classesCreateArgs>(
      args: SelectSubset<T, my_classesCreateArgs>
    ): CheckSelect<T, Prisma__my_classesClient<my_classes>, Prisma__my_classesClient<my_classesGetPayload<T>>>

    /**
     * Create many My_classes.
     *     @param {my_classesCreateManyArgs} args - Arguments to create many My_classes.
     *     @example
     *     // Create many My_classes
     *     const my_classes = await prisma.my_classes.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends my_classesCreateManyArgs>(
      args?: SelectSubset<T, my_classesCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a My_classes.
     * @param {my_classesDeleteArgs} args - Arguments to delete one My_classes.
     * @example
     * // Delete one My_classes
     * const My_classes = await prisma.my_classes.delete({
     *   where: {
     *     // ... filter to delete one My_classes
     *   }
     * })
     * 
    **/
    delete<T extends my_classesDeleteArgs>(
      args: SelectSubset<T, my_classesDeleteArgs>
    ): CheckSelect<T, Prisma__my_classesClient<my_classes>, Prisma__my_classesClient<my_classesGetPayload<T>>>

    /**
     * Update one My_classes.
     * @param {my_classesUpdateArgs} args - Arguments to update one My_classes.
     * @example
     * // Update one My_classes
     * const my_classes = await prisma.my_classes.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends my_classesUpdateArgs>(
      args: SelectSubset<T, my_classesUpdateArgs>
    ): CheckSelect<T, Prisma__my_classesClient<my_classes>, Prisma__my_classesClient<my_classesGetPayload<T>>>

    /**
     * Delete zero or more My_classes.
     * @param {my_classesDeleteManyArgs} args - Arguments to filter My_classes to delete.
     * @example
     * // Delete a few My_classes
     * const { count } = await prisma.my_classes.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends my_classesDeleteManyArgs>(
      args?: SelectSubset<T, my_classesDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more My_classes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {my_classesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many My_classes
     * const my_classes = await prisma.my_classes.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends my_classesUpdateManyArgs>(
      args: SelectSubset<T, my_classesUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one My_classes.
     * @param {my_classesUpsertArgs} args - Arguments to update or create a My_classes.
     * @example
     * // Update or create a My_classes
     * const my_classes = await prisma.my_classes.upsert({
     *   create: {
     *     // ... data to create a My_classes
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the My_classes we want to update
     *   }
     * })
    **/
    upsert<T extends my_classesUpsertArgs>(
      args: SelectSubset<T, my_classesUpsertArgs>
    ): CheckSelect<T, Prisma__my_classesClient<my_classes>, Prisma__my_classesClient<my_classesGetPayload<T>>>

    /**
     * Find one My_classes that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {my_classesFindUniqueOrThrowArgs} args - Arguments to find a My_classes
     * @example
     * // Get one My_classes
     * const my_classes = await prisma.my_classes.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends my_classesFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, my_classesFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__my_classesClient<my_classes>, Prisma__my_classesClient<my_classesGetPayload<T>>>

    /**
     * Find the first My_classes that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {my_classesFindFirstOrThrowArgs} args - Arguments to find a My_classes
     * @example
     * // Get one My_classes
     * const my_classes = await prisma.my_classes.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends my_classesFindFirstOrThrowArgs>(
      args?: SelectSubset<T, my_classesFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__my_classesClient<my_classes>, Prisma__my_classesClient<my_classesGetPayload<T>>>

    /**
     * Count the number of My_classes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {my_classesCountArgs} args - Arguments to filter My_classes to count.
     * @example
     * // Count the number of My_classes
     * const count = await prisma.my_classes.count({
     *   where: {
     *     // ... the filter for the My_classes we want to count
     *   }
     * })
    **/
    count<T extends my_classesCountArgs>(
      args?: Subset<T, my_classesCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], My_classesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a My_classes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {My_classesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends My_classesAggregateArgs>(args: Subset<T, My_classesAggregateArgs>): PrismaPromise<GetMy_classesAggregateType<T>>

    /**
     * Group by My_classes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {My_classesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends My_classesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: My_classesGroupByArgs['orderBy'] }
        : { orderBy?: My_classesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, My_classesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMy_classesGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for my_classes.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__my_classesClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    classes<T extends classesArgs = {}>(args?: Subset<T, classesArgs>): CheckSelect<T, Prisma__classesClient<classes | null >, Prisma__classesClient<classesGetPayload<T> | null >>;

    users<T extends usersArgs = {}>(args?: Subset<T, usersArgs>): CheckSelect<T, Prisma__usersClient<users | null >, Prisma__usersClient<usersGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * my_classes base type for findUnique actions
   */
  export type my_classesFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the my_classes
     * 
    **/
    select?: my_classesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: my_classesInclude | null
    /**
     * Filter, which my_classes to fetch.
     * 
    **/
    where: my_classesWhereUniqueInput
  }

  /**
   * my_classes: findUnique
   */
  export interface my_classesFindUniqueArgs extends my_classesFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * my_classes base type for findFirst actions
   */
  export type my_classesFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the my_classes
     * 
    **/
    select?: my_classesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: my_classesInclude | null
    /**
     * Filter, which my_classes to fetch.
     * 
    **/
    where?: my_classesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of my_classes to fetch.
     * 
    **/
    orderBy?: Enumerable<my_classesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for my_classes.
     * 
    **/
    cursor?: my_classesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` my_classes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` my_classes.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of my_classes.
     * 
    **/
    distinct?: Enumerable<My_classesScalarFieldEnum>
  }

  /**
   * my_classes: findFirst
   */
  export interface my_classesFindFirstArgs extends my_classesFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * my_classes findMany
   */
  export type my_classesFindManyArgs = {
    /**
     * Select specific fields to fetch from the my_classes
     * 
    **/
    select?: my_classesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: my_classesInclude | null
    /**
     * Filter, which my_classes to fetch.
     * 
    **/
    where?: my_classesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of my_classes to fetch.
     * 
    **/
    orderBy?: Enumerable<my_classesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing my_classes.
     * 
    **/
    cursor?: my_classesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` my_classes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` my_classes.
     * 
    **/
    skip?: number
    distinct?: Enumerable<My_classesScalarFieldEnum>
  }


  /**
   * my_classes create
   */
  export type my_classesCreateArgs = {
    /**
     * Select specific fields to fetch from the my_classes
     * 
    **/
    select?: my_classesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: my_classesInclude | null
    /**
     * The data needed to create a my_classes.
     * 
    **/
    data: XOR<my_classesCreateInput, my_classesUncheckedCreateInput>
  }


  /**
   * my_classes createMany
   */
  export type my_classesCreateManyArgs = {
    /**
     * The data used to create many my_classes.
     * 
    **/
    data: Enumerable<my_classesCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * my_classes update
   */
  export type my_classesUpdateArgs = {
    /**
     * Select specific fields to fetch from the my_classes
     * 
    **/
    select?: my_classesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: my_classesInclude | null
    /**
     * The data needed to update a my_classes.
     * 
    **/
    data: XOR<my_classesUpdateInput, my_classesUncheckedUpdateInput>
    /**
     * Choose, which my_classes to update.
     * 
    **/
    where: my_classesWhereUniqueInput
  }


  /**
   * my_classes updateMany
   */
  export type my_classesUpdateManyArgs = {
    /**
     * The data used to update my_classes.
     * 
    **/
    data: XOR<my_classesUpdateManyMutationInput, my_classesUncheckedUpdateManyInput>
    /**
     * Filter which my_classes to update
     * 
    **/
    where?: my_classesWhereInput
  }


  /**
   * my_classes upsert
   */
  export type my_classesUpsertArgs = {
    /**
     * Select specific fields to fetch from the my_classes
     * 
    **/
    select?: my_classesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: my_classesInclude | null
    /**
     * The filter to search for the my_classes to update in case it exists.
     * 
    **/
    where: my_classesWhereUniqueInput
    /**
     * In case the my_classes found by the `where` argument doesn't exist, create a new my_classes with this data.
     * 
    **/
    create: XOR<my_classesCreateInput, my_classesUncheckedCreateInput>
    /**
     * In case the my_classes was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<my_classesUpdateInput, my_classesUncheckedUpdateInput>
  }


  /**
   * my_classes delete
   */
  export type my_classesDeleteArgs = {
    /**
     * Select specific fields to fetch from the my_classes
     * 
    **/
    select?: my_classesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: my_classesInclude | null
    /**
     * Filter which my_classes to delete.
     * 
    **/
    where: my_classesWhereUniqueInput
  }


  /**
   * my_classes deleteMany
   */
  export type my_classesDeleteManyArgs = {
    /**
     * Filter which my_classes to delete
     * 
    **/
    where?: my_classesWhereInput
  }


  /**
   * my_classes: findUniqueOrThrow
   */
  export type my_classesFindUniqueOrThrowArgs = my_classesFindUniqueArgsBase
      

  /**
   * my_classes: findFirstOrThrow
   */
  export type my_classesFindFirstOrThrowArgs = my_classesFindFirstArgsBase
      

  /**
   * my_classes without action
   */
  export type my_classesArgs = {
    /**
     * Select specific fields to fetch from the my_classes
     * 
    **/
    select?: my_classesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: my_classesInclude | null
  }



  /**
   * Model price_scope
   */


  export type AggregatePrice_scope = {
    _count: Price_scopeCountAggregateOutputType | null
    _avg: Price_scopeAvgAggregateOutputType | null
    _sum: Price_scopeSumAggregateOutputType | null
    _min: Price_scopeMinAggregateOutputType | null
    _max: Price_scopeMaxAggregateOutputType | null
  }

  export type Price_scopeAvgAggregateOutputType = {
    id: number | null
  }

  export type Price_scopeSumAggregateOutputType = {
    id: number | null
  }

  export type Price_scopeMinAggregateOutputType = {
    id: number | null
    scope: string | null
  }

  export type Price_scopeMaxAggregateOutputType = {
    id: number | null
    scope: string | null
  }

  export type Price_scopeCountAggregateOutputType = {
    id: number
    scope: number
    _all: number
  }


  export type Price_scopeAvgAggregateInputType = {
    id?: true
  }

  export type Price_scopeSumAggregateInputType = {
    id?: true
  }

  export type Price_scopeMinAggregateInputType = {
    id?: true
    scope?: true
  }

  export type Price_scopeMaxAggregateInputType = {
    id?: true
    scope?: true
  }

  export type Price_scopeCountAggregateInputType = {
    id?: true
    scope?: true
    _all?: true
  }

  export type Price_scopeAggregateArgs = {
    /**
     * Filter which price_scope to aggregate.
     * 
    **/
    where?: price_scopeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of price_scopes to fetch.
     * 
    **/
    orderBy?: Enumerable<price_scopeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: price_scopeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` price_scopes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` price_scopes.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned price_scopes
    **/
    _count?: true | Price_scopeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Price_scopeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Price_scopeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Price_scopeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Price_scopeMaxAggregateInputType
  }

  export type GetPrice_scopeAggregateType<T extends Price_scopeAggregateArgs> = {
        [P in keyof T & keyof AggregatePrice_scope]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePrice_scope[P]>
      : GetScalarType<T[P], AggregatePrice_scope[P]>
  }




  export type Price_scopeGroupByArgs = {
    where?: price_scopeWhereInput
    orderBy?: Enumerable<price_scopeOrderByWithAggregationInput>
    by: Array<Price_scopeScalarFieldEnum>
    having?: price_scopeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Price_scopeCountAggregateInputType | true
    _avg?: Price_scopeAvgAggregateInputType
    _sum?: Price_scopeSumAggregateInputType
    _min?: Price_scopeMinAggregateInputType
    _max?: Price_scopeMaxAggregateInputType
  }


  export type Price_scopeGroupByOutputType = {
    id: number
    scope: string | null
    _count: Price_scopeCountAggregateOutputType | null
    _avg: Price_scopeAvgAggregateOutputType | null
    _sum: Price_scopeSumAggregateOutputType | null
    _min: Price_scopeMinAggregateOutputType | null
    _max: Price_scopeMaxAggregateOutputType | null
  }

  type GetPrice_scopeGroupByPayload<T extends Price_scopeGroupByArgs> = PrismaPromise<
    Array<
      PickArray<Price_scopeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Price_scopeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Price_scopeGroupByOutputType[P]>
            : GetScalarType<T[P], Price_scopeGroupByOutputType[P]>
        }
      >
    >


  export type price_scopeSelect = {
    id?: boolean
    scope?: boolean
    classes?: boolean | classesFindManyArgs
    _count?: boolean | Price_scopeCountOutputTypeArgs
  }

  export type price_scopeInclude = {
    classes?: boolean | classesFindManyArgs
    _count?: boolean | Price_scopeCountOutputTypeArgs
  }

  export type price_scopeGetPayload<
    S extends boolean | null | undefined | price_scopeArgs,
    U = keyof S
      > = S extends true
        ? price_scope
    : S extends undefined
    ? never
    : S extends price_scopeArgs | price_scopeFindManyArgs
    ?'include' extends U
    ? price_scope  & {
    [P in TrueKeys<S['include']>]:
        P extends 'classes' ? Array < classesGetPayload<S['include'][P]>>  :
        P extends '_count' ? Price_scopeCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'classes' ? Array < classesGetPayload<S['select'][P]>>  :
        P extends '_count' ? Price_scopeCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof price_scope ? price_scope[P] : never
  } 
    : price_scope
  : price_scope


  type price_scopeCountArgs = Merge<
    Omit<price_scopeFindManyArgs, 'select' | 'include'> & {
      select?: Price_scopeCountAggregateInputType | true
    }
  >

  export interface price_scopeDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Price_scope that matches the filter.
     * @param {price_scopeFindUniqueArgs} args - Arguments to find a Price_scope
     * @example
     * // Get one Price_scope
     * const price_scope = await prisma.price_scope.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends price_scopeFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, price_scopeFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'price_scope'> extends True ? CheckSelect<T, Prisma__price_scopeClient<price_scope>, Prisma__price_scopeClient<price_scopeGetPayload<T>>> : CheckSelect<T, Prisma__price_scopeClient<price_scope | null >, Prisma__price_scopeClient<price_scopeGetPayload<T> | null >>

    /**
     * Find the first Price_scope that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {price_scopeFindFirstArgs} args - Arguments to find a Price_scope
     * @example
     * // Get one Price_scope
     * const price_scope = await prisma.price_scope.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends price_scopeFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, price_scopeFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'price_scope'> extends True ? CheckSelect<T, Prisma__price_scopeClient<price_scope>, Prisma__price_scopeClient<price_scopeGetPayload<T>>> : CheckSelect<T, Prisma__price_scopeClient<price_scope | null >, Prisma__price_scopeClient<price_scopeGetPayload<T> | null >>

    /**
     * Find zero or more Price_scopes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {price_scopeFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Price_scopes
     * const price_scopes = await prisma.price_scope.findMany()
     * 
     * // Get first 10 Price_scopes
     * const price_scopes = await prisma.price_scope.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const price_scopeWithIdOnly = await prisma.price_scope.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends price_scopeFindManyArgs>(
      args?: SelectSubset<T, price_scopeFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<price_scope>>, PrismaPromise<Array<price_scopeGetPayload<T>>>>

    /**
     * Create a Price_scope.
     * @param {price_scopeCreateArgs} args - Arguments to create a Price_scope.
     * @example
     * // Create one Price_scope
     * const Price_scope = await prisma.price_scope.create({
     *   data: {
     *     // ... data to create a Price_scope
     *   }
     * })
     * 
    **/
    create<T extends price_scopeCreateArgs>(
      args: SelectSubset<T, price_scopeCreateArgs>
    ): CheckSelect<T, Prisma__price_scopeClient<price_scope>, Prisma__price_scopeClient<price_scopeGetPayload<T>>>

    /**
     * Create many Price_scopes.
     *     @param {price_scopeCreateManyArgs} args - Arguments to create many Price_scopes.
     *     @example
     *     // Create many Price_scopes
     *     const price_scope = await prisma.price_scope.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends price_scopeCreateManyArgs>(
      args?: SelectSubset<T, price_scopeCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Price_scope.
     * @param {price_scopeDeleteArgs} args - Arguments to delete one Price_scope.
     * @example
     * // Delete one Price_scope
     * const Price_scope = await prisma.price_scope.delete({
     *   where: {
     *     // ... filter to delete one Price_scope
     *   }
     * })
     * 
    **/
    delete<T extends price_scopeDeleteArgs>(
      args: SelectSubset<T, price_scopeDeleteArgs>
    ): CheckSelect<T, Prisma__price_scopeClient<price_scope>, Prisma__price_scopeClient<price_scopeGetPayload<T>>>

    /**
     * Update one Price_scope.
     * @param {price_scopeUpdateArgs} args - Arguments to update one Price_scope.
     * @example
     * // Update one Price_scope
     * const price_scope = await prisma.price_scope.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends price_scopeUpdateArgs>(
      args: SelectSubset<T, price_scopeUpdateArgs>
    ): CheckSelect<T, Prisma__price_scopeClient<price_scope>, Prisma__price_scopeClient<price_scopeGetPayload<T>>>

    /**
     * Delete zero or more Price_scopes.
     * @param {price_scopeDeleteManyArgs} args - Arguments to filter Price_scopes to delete.
     * @example
     * // Delete a few Price_scopes
     * const { count } = await prisma.price_scope.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends price_scopeDeleteManyArgs>(
      args?: SelectSubset<T, price_scopeDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Price_scopes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {price_scopeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Price_scopes
     * const price_scope = await prisma.price_scope.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends price_scopeUpdateManyArgs>(
      args: SelectSubset<T, price_scopeUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Price_scope.
     * @param {price_scopeUpsertArgs} args - Arguments to update or create a Price_scope.
     * @example
     * // Update or create a Price_scope
     * const price_scope = await prisma.price_scope.upsert({
     *   create: {
     *     // ... data to create a Price_scope
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Price_scope we want to update
     *   }
     * })
    **/
    upsert<T extends price_scopeUpsertArgs>(
      args: SelectSubset<T, price_scopeUpsertArgs>
    ): CheckSelect<T, Prisma__price_scopeClient<price_scope>, Prisma__price_scopeClient<price_scopeGetPayload<T>>>

    /**
     * Find one Price_scope that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {price_scopeFindUniqueOrThrowArgs} args - Arguments to find a Price_scope
     * @example
     * // Get one Price_scope
     * const price_scope = await prisma.price_scope.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends price_scopeFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, price_scopeFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__price_scopeClient<price_scope>, Prisma__price_scopeClient<price_scopeGetPayload<T>>>

    /**
     * Find the first Price_scope that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {price_scopeFindFirstOrThrowArgs} args - Arguments to find a Price_scope
     * @example
     * // Get one Price_scope
     * const price_scope = await prisma.price_scope.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends price_scopeFindFirstOrThrowArgs>(
      args?: SelectSubset<T, price_scopeFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__price_scopeClient<price_scope>, Prisma__price_scopeClient<price_scopeGetPayload<T>>>

    /**
     * Count the number of Price_scopes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {price_scopeCountArgs} args - Arguments to filter Price_scopes to count.
     * @example
     * // Count the number of Price_scopes
     * const count = await prisma.price_scope.count({
     *   where: {
     *     // ... the filter for the Price_scopes we want to count
     *   }
     * })
    **/
    count<T extends price_scopeCountArgs>(
      args?: Subset<T, price_scopeCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Price_scopeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Price_scope.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Price_scopeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Price_scopeAggregateArgs>(args: Subset<T, Price_scopeAggregateArgs>): PrismaPromise<GetPrice_scopeAggregateType<T>>

    /**
     * Group by Price_scope.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Price_scopeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Price_scopeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Price_scopeGroupByArgs['orderBy'] }
        : { orderBy?: Price_scopeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Price_scopeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPrice_scopeGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for price_scope.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__price_scopeClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    classes<T extends classesFindManyArgs = {}>(args?: Subset<T, classesFindManyArgs>): CheckSelect<T, PrismaPromise<Array<classes>>, PrismaPromise<Array<classesGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * price_scope base type for findUnique actions
   */
  export type price_scopeFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the price_scope
     * 
    **/
    select?: price_scopeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: price_scopeInclude | null
    /**
     * Filter, which price_scope to fetch.
     * 
    **/
    where: price_scopeWhereUniqueInput
  }

  /**
   * price_scope: findUnique
   */
  export interface price_scopeFindUniqueArgs extends price_scopeFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * price_scope base type for findFirst actions
   */
  export type price_scopeFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the price_scope
     * 
    **/
    select?: price_scopeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: price_scopeInclude | null
    /**
     * Filter, which price_scope to fetch.
     * 
    **/
    where?: price_scopeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of price_scopes to fetch.
     * 
    **/
    orderBy?: Enumerable<price_scopeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for price_scopes.
     * 
    **/
    cursor?: price_scopeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` price_scopes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` price_scopes.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of price_scopes.
     * 
    **/
    distinct?: Enumerable<Price_scopeScalarFieldEnum>
  }

  /**
   * price_scope: findFirst
   */
  export interface price_scopeFindFirstArgs extends price_scopeFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * price_scope findMany
   */
  export type price_scopeFindManyArgs = {
    /**
     * Select specific fields to fetch from the price_scope
     * 
    **/
    select?: price_scopeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: price_scopeInclude | null
    /**
     * Filter, which price_scopes to fetch.
     * 
    **/
    where?: price_scopeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of price_scopes to fetch.
     * 
    **/
    orderBy?: Enumerable<price_scopeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing price_scopes.
     * 
    **/
    cursor?: price_scopeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` price_scopes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` price_scopes.
     * 
    **/
    skip?: number
    distinct?: Enumerable<Price_scopeScalarFieldEnum>
  }


  /**
   * price_scope create
   */
  export type price_scopeCreateArgs = {
    /**
     * Select specific fields to fetch from the price_scope
     * 
    **/
    select?: price_scopeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: price_scopeInclude | null
    /**
     * The data needed to create a price_scope.
     * 
    **/
    data: XOR<price_scopeCreateInput, price_scopeUncheckedCreateInput>
  }


  /**
   * price_scope createMany
   */
  export type price_scopeCreateManyArgs = {
    /**
     * The data used to create many price_scopes.
     * 
    **/
    data: Enumerable<price_scopeCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * price_scope update
   */
  export type price_scopeUpdateArgs = {
    /**
     * Select specific fields to fetch from the price_scope
     * 
    **/
    select?: price_scopeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: price_scopeInclude | null
    /**
     * The data needed to update a price_scope.
     * 
    **/
    data: XOR<price_scopeUpdateInput, price_scopeUncheckedUpdateInput>
    /**
     * Choose, which price_scope to update.
     * 
    **/
    where: price_scopeWhereUniqueInput
  }


  /**
   * price_scope updateMany
   */
  export type price_scopeUpdateManyArgs = {
    /**
     * The data used to update price_scopes.
     * 
    **/
    data: XOR<price_scopeUpdateManyMutationInput, price_scopeUncheckedUpdateManyInput>
    /**
     * Filter which price_scopes to update
     * 
    **/
    where?: price_scopeWhereInput
  }


  /**
   * price_scope upsert
   */
  export type price_scopeUpsertArgs = {
    /**
     * Select specific fields to fetch from the price_scope
     * 
    **/
    select?: price_scopeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: price_scopeInclude | null
    /**
     * The filter to search for the price_scope to update in case it exists.
     * 
    **/
    where: price_scopeWhereUniqueInput
    /**
     * In case the price_scope found by the `where` argument doesn't exist, create a new price_scope with this data.
     * 
    **/
    create: XOR<price_scopeCreateInput, price_scopeUncheckedCreateInput>
    /**
     * In case the price_scope was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<price_scopeUpdateInput, price_scopeUncheckedUpdateInput>
  }


  /**
   * price_scope delete
   */
  export type price_scopeDeleteArgs = {
    /**
     * Select specific fields to fetch from the price_scope
     * 
    **/
    select?: price_scopeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: price_scopeInclude | null
    /**
     * Filter which price_scope to delete.
     * 
    **/
    where: price_scopeWhereUniqueInput
  }


  /**
   * price_scope deleteMany
   */
  export type price_scopeDeleteManyArgs = {
    /**
     * Filter which price_scopes to delete
     * 
    **/
    where?: price_scopeWhereInput
  }


  /**
   * price_scope: findUniqueOrThrow
   */
  export type price_scopeFindUniqueOrThrowArgs = price_scopeFindUniqueArgsBase
      

  /**
   * price_scope: findFirstOrThrow
   */
  export type price_scopeFindFirstOrThrowArgs = price_scopeFindFirstArgsBase
      

  /**
   * price_scope without action
   */
  export type price_scopeArgs = {
    /**
     * Select specific fields to fetch from the price_scope
     * 
    **/
    select?: price_scopeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: price_scopeInclude | null
  }



  /**
   * Model review
   */


  export type AggregateReview = {
    _count: ReviewCountAggregateOutputType | null
    _avg: ReviewAvgAggregateOutputType | null
    _sum: ReviewSumAggregateOutputType | null
    _min: ReviewMinAggregateOutputType | null
    _max: ReviewMaxAggregateOutputType | null
  }

  export type ReviewAvgAggregateOutputType = {
    id: number | null
    user_id: number | null
    rate: number | null
    class_id: number | null
  }

  export type ReviewSumAggregateOutputType = {
    id: number | null
    user_id: number | null
    rate: number | null
    class_id: number | null
  }

  export type ReviewMinAggregateOutputType = {
    id: number | null
    user_id: number | null
    rate: number | null
    class_id: number | null
  }

  export type ReviewMaxAggregateOutputType = {
    id: number | null
    user_id: number | null
    rate: number | null
    class_id: number | null
  }

  export type ReviewCountAggregateOutputType = {
    id: number
    user_id: number
    rate: number
    class_id: number
    _all: number
  }


  export type ReviewAvgAggregateInputType = {
    id?: true
    user_id?: true
    rate?: true
    class_id?: true
  }

  export type ReviewSumAggregateInputType = {
    id?: true
    user_id?: true
    rate?: true
    class_id?: true
  }

  export type ReviewMinAggregateInputType = {
    id?: true
    user_id?: true
    rate?: true
    class_id?: true
  }

  export type ReviewMaxAggregateInputType = {
    id?: true
    user_id?: true
    rate?: true
    class_id?: true
  }

  export type ReviewCountAggregateInputType = {
    id?: true
    user_id?: true
    rate?: true
    class_id?: true
    _all?: true
  }

  export type ReviewAggregateArgs = {
    /**
     * Filter which review to aggregate.
     * 
    **/
    where?: reviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of reviews to fetch.
     * 
    **/
    orderBy?: Enumerable<reviewOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: reviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` reviews from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` reviews.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned reviews
    **/
    _count?: true | ReviewCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ReviewAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ReviewSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReviewMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReviewMaxAggregateInputType
  }

  export type GetReviewAggregateType<T extends ReviewAggregateArgs> = {
        [P in keyof T & keyof AggregateReview]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReview[P]>
      : GetScalarType<T[P], AggregateReview[P]>
  }




  export type ReviewGroupByArgs = {
    where?: reviewWhereInput
    orderBy?: Enumerable<reviewOrderByWithAggregationInput>
    by: Array<ReviewScalarFieldEnum>
    having?: reviewScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReviewCountAggregateInputType | true
    _avg?: ReviewAvgAggregateInputType
    _sum?: ReviewSumAggregateInputType
    _min?: ReviewMinAggregateInputType
    _max?: ReviewMaxAggregateInputType
  }


  export type ReviewGroupByOutputType = {
    id: number
    user_id: number
    rate: number
    class_id: number
    _count: ReviewCountAggregateOutputType | null
    _avg: ReviewAvgAggregateOutputType | null
    _sum: ReviewSumAggregateOutputType | null
    _min: ReviewMinAggregateOutputType | null
    _max: ReviewMaxAggregateOutputType | null
  }

  type GetReviewGroupByPayload<T extends ReviewGroupByArgs> = PrismaPromise<
    Array<
      PickArray<ReviewGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReviewGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReviewGroupByOutputType[P]>
            : GetScalarType<T[P], ReviewGroupByOutputType[P]>
        }
      >
    >


  export type reviewSelect = {
    id?: boolean
    user_id?: boolean
    rate?: boolean
    class_id?: boolean
    classes?: boolean | classesArgs
    users?: boolean | usersArgs
  }

  export type reviewInclude = {
    classes?: boolean | classesArgs
    users?: boolean | usersArgs
  }

  export type reviewGetPayload<
    S extends boolean | null | undefined | reviewArgs,
    U = keyof S
      > = S extends true
        ? review
    : S extends undefined
    ? never
    : S extends reviewArgs | reviewFindManyArgs
    ?'include' extends U
    ? review  & {
    [P in TrueKeys<S['include']>]:
        P extends 'classes' ? classesGetPayload<S['include'][P]> :
        P extends 'users' ? usersGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'classes' ? classesGetPayload<S['select'][P]> :
        P extends 'users' ? usersGetPayload<S['select'][P]> :  P extends keyof review ? review[P] : never
  } 
    : review
  : review


  type reviewCountArgs = Merge<
    Omit<reviewFindManyArgs, 'select' | 'include'> & {
      select?: ReviewCountAggregateInputType | true
    }
  >

  export interface reviewDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Review that matches the filter.
     * @param {reviewFindUniqueArgs} args - Arguments to find a Review
     * @example
     * // Get one Review
     * const review = await prisma.review.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends reviewFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, reviewFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'review'> extends True ? CheckSelect<T, Prisma__reviewClient<review>, Prisma__reviewClient<reviewGetPayload<T>>> : CheckSelect<T, Prisma__reviewClient<review | null >, Prisma__reviewClient<reviewGetPayload<T> | null >>

    /**
     * Find the first Review that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reviewFindFirstArgs} args - Arguments to find a Review
     * @example
     * // Get one Review
     * const review = await prisma.review.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends reviewFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, reviewFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'review'> extends True ? CheckSelect<T, Prisma__reviewClient<review>, Prisma__reviewClient<reviewGetPayload<T>>> : CheckSelect<T, Prisma__reviewClient<review | null >, Prisma__reviewClient<reviewGetPayload<T> | null >>

    /**
     * Find zero or more Reviews that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reviewFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Reviews
     * const reviews = await prisma.review.findMany()
     * 
     * // Get first 10 Reviews
     * const reviews = await prisma.review.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const reviewWithIdOnly = await prisma.review.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends reviewFindManyArgs>(
      args?: SelectSubset<T, reviewFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<review>>, PrismaPromise<Array<reviewGetPayload<T>>>>

    /**
     * Create a Review.
     * @param {reviewCreateArgs} args - Arguments to create a Review.
     * @example
     * // Create one Review
     * const Review = await prisma.review.create({
     *   data: {
     *     // ... data to create a Review
     *   }
     * })
     * 
    **/
    create<T extends reviewCreateArgs>(
      args: SelectSubset<T, reviewCreateArgs>
    ): CheckSelect<T, Prisma__reviewClient<review>, Prisma__reviewClient<reviewGetPayload<T>>>

    /**
     * Create many Reviews.
     *     @param {reviewCreateManyArgs} args - Arguments to create many Reviews.
     *     @example
     *     // Create many Reviews
     *     const review = await prisma.review.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends reviewCreateManyArgs>(
      args?: SelectSubset<T, reviewCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Review.
     * @param {reviewDeleteArgs} args - Arguments to delete one Review.
     * @example
     * // Delete one Review
     * const Review = await prisma.review.delete({
     *   where: {
     *     // ... filter to delete one Review
     *   }
     * })
     * 
    **/
    delete<T extends reviewDeleteArgs>(
      args: SelectSubset<T, reviewDeleteArgs>
    ): CheckSelect<T, Prisma__reviewClient<review>, Prisma__reviewClient<reviewGetPayload<T>>>

    /**
     * Update one Review.
     * @param {reviewUpdateArgs} args - Arguments to update one Review.
     * @example
     * // Update one Review
     * const review = await prisma.review.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends reviewUpdateArgs>(
      args: SelectSubset<T, reviewUpdateArgs>
    ): CheckSelect<T, Prisma__reviewClient<review>, Prisma__reviewClient<reviewGetPayload<T>>>

    /**
     * Delete zero or more Reviews.
     * @param {reviewDeleteManyArgs} args - Arguments to filter Reviews to delete.
     * @example
     * // Delete a few Reviews
     * const { count } = await prisma.review.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends reviewDeleteManyArgs>(
      args?: SelectSubset<T, reviewDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reviewUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Reviews
     * const review = await prisma.review.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends reviewUpdateManyArgs>(
      args: SelectSubset<T, reviewUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Review.
     * @param {reviewUpsertArgs} args - Arguments to update or create a Review.
     * @example
     * // Update or create a Review
     * const review = await prisma.review.upsert({
     *   create: {
     *     // ... data to create a Review
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Review we want to update
     *   }
     * })
    **/
    upsert<T extends reviewUpsertArgs>(
      args: SelectSubset<T, reviewUpsertArgs>
    ): CheckSelect<T, Prisma__reviewClient<review>, Prisma__reviewClient<reviewGetPayload<T>>>

    /**
     * Find one Review that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {reviewFindUniqueOrThrowArgs} args - Arguments to find a Review
     * @example
     * // Get one Review
     * const review = await prisma.review.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends reviewFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, reviewFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__reviewClient<review>, Prisma__reviewClient<reviewGetPayload<T>>>

    /**
     * Find the first Review that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reviewFindFirstOrThrowArgs} args - Arguments to find a Review
     * @example
     * // Get one Review
     * const review = await prisma.review.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends reviewFindFirstOrThrowArgs>(
      args?: SelectSubset<T, reviewFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__reviewClient<review>, Prisma__reviewClient<reviewGetPayload<T>>>

    /**
     * Count the number of Reviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reviewCountArgs} args - Arguments to filter Reviews to count.
     * @example
     * // Count the number of Reviews
     * const count = await prisma.review.count({
     *   where: {
     *     // ... the filter for the Reviews we want to count
     *   }
     * })
    **/
    count<T extends reviewCountArgs>(
      args?: Subset<T, reviewCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReviewCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Review.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReviewAggregateArgs>(args: Subset<T, ReviewAggregateArgs>): PrismaPromise<GetReviewAggregateType<T>>

    /**
     * Group by Review.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReviewGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReviewGroupByArgs['orderBy'] }
        : { orderBy?: ReviewGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReviewGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReviewGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for review.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__reviewClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    classes<T extends classesArgs = {}>(args?: Subset<T, classesArgs>): CheckSelect<T, Prisma__classesClient<classes | null >, Prisma__classesClient<classesGetPayload<T> | null >>;

    users<T extends usersArgs = {}>(args?: Subset<T, usersArgs>): CheckSelect<T, Prisma__usersClient<users | null >, Prisma__usersClient<usersGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * review base type for findUnique actions
   */
  export type reviewFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the review
     * 
    **/
    select?: reviewSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: reviewInclude | null
    /**
     * Filter, which review to fetch.
     * 
    **/
    where: reviewWhereUniqueInput
  }

  /**
   * review: findUnique
   */
  export interface reviewFindUniqueArgs extends reviewFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * review base type for findFirst actions
   */
  export type reviewFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the review
     * 
    **/
    select?: reviewSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: reviewInclude | null
    /**
     * Filter, which review to fetch.
     * 
    **/
    where?: reviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of reviews to fetch.
     * 
    **/
    orderBy?: Enumerable<reviewOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for reviews.
     * 
    **/
    cursor?: reviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` reviews from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` reviews.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of reviews.
     * 
    **/
    distinct?: Enumerable<ReviewScalarFieldEnum>
  }

  /**
   * review: findFirst
   */
  export interface reviewFindFirstArgs extends reviewFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * review findMany
   */
  export type reviewFindManyArgs = {
    /**
     * Select specific fields to fetch from the review
     * 
    **/
    select?: reviewSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: reviewInclude | null
    /**
     * Filter, which reviews to fetch.
     * 
    **/
    where?: reviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of reviews to fetch.
     * 
    **/
    orderBy?: Enumerable<reviewOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing reviews.
     * 
    **/
    cursor?: reviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` reviews from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` reviews.
     * 
    **/
    skip?: number
    distinct?: Enumerable<ReviewScalarFieldEnum>
  }


  /**
   * review create
   */
  export type reviewCreateArgs = {
    /**
     * Select specific fields to fetch from the review
     * 
    **/
    select?: reviewSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: reviewInclude | null
    /**
     * The data needed to create a review.
     * 
    **/
    data: XOR<reviewCreateInput, reviewUncheckedCreateInput>
  }


  /**
   * review createMany
   */
  export type reviewCreateManyArgs = {
    /**
     * The data used to create many reviews.
     * 
    **/
    data: Enumerable<reviewCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * review update
   */
  export type reviewUpdateArgs = {
    /**
     * Select specific fields to fetch from the review
     * 
    **/
    select?: reviewSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: reviewInclude | null
    /**
     * The data needed to update a review.
     * 
    **/
    data: XOR<reviewUpdateInput, reviewUncheckedUpdateInput>
    /**
     * Choose, which review to update.
     * 
    **/
    where: reviewWhereUniqueInput
  }


  /**
   * review updateMany
   */
  export type reviewUpdateManyArgs = {
    /**
     * The data used to update reviews.
     * 
    **/
    data: XOR<reviewUpdateManyMutationInput, reviewUncheckedUpdateManyInput>
    /**
     * Filter which reviews to update
     * 
    **/
    where?: reviewWhereInput
  }


  /**
   * review upsert
   */
  export type reviewUpsertArgs = {
    /**
     * Select specific fields to fetch from the review
     * 
    **/
    select?: reviewSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: reviewInclude | null
    /**
     * The filter to search for the review to update in case it exists.
     * 
    **/
    where: reviewWhereUniqueInput
    /**
     * In case the review found by the `where` argument doesn't exist, create a new review with this data.
     * 
    **/
    create: XOR<reviewCreateInput, reviewUncheckedCreateInput>
    /**
     * In case the review was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<reviewUpdateInput, reviewUncheckedUpdateInput>
  }


  /**
   * review delete
   */
  export type reviewDeleteArgs = {
    /**
     * Select specific fields to fetch from the review
     * 
    **/
    select?: reviewSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: reviewInclude | null
    /**
     * Filter which review to delete.
     * 
    **/
    where: reviewWhereUniqueInput
  }


  /**
   * review deleteMany
   */
  export type reviewDeleteManyArgs = {
    /**
     * Filter which reviews to delete
     * 
    **/
    where?: reviewWhereInput
  }


  /**
   * review: findUniqueOrThrow
   */
  export type reviewFindUniqueOrThrowArgs = reviewFindUniqueArgsBase
      

  /**
   * review: findFirstOrThrow
   */
  export type reviewFindFirstOrThrowArgs = reviewFindFirstArgsBase
      

  /**
   * review without action
   */
  export type reviewArgs = {
    /**
     * Select specific fields to fetch from the review
     * 
    **/
    select?: reviewSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: reviewInclude | null
  }



  /**
   * Model wishlist
   */


  export type AggregateWishlist = {
    _count: WishlistCountAggregateOutputType | null
    _avg: WishlistAvgAggregateOutputType | null
    _sum: WishlistSumAggregateOutputType | null
    _min: WishlistMinAggregateOutputType | null
    _max: WishlistMaxAggregateOutputType | null
  }

  export type WishlistAvgAggregateOutputType = {
    id: number | null
    user_id: number | null
    class_id: number | null
  }

  export type WishlistSumAggregateOutputType = {
    id: number | null
    user_id: number | null
    class_id: number | null
  }

  export type WishlistMinAggregateOutputType = {
    id: number | null
    user_id: number | null
    class_id: number | null
  }

  export type WishlistMaxAggregateOutputType = {
    id: number | null
    user_id: number | null
    class_id: number | null
  }

  export type WishlistCountAggregateOutputType = {
    id: number
    user_id: number
    class_id: number
    _all: number
  }


  export type WishlistAvgAggregateInputType = {
    id?: true
    user_id?: true
    class_id?: true
  }

  export type WishlistSumAggregateInputType = {
    id?: true
    user_id?: true
    class_id?: true
  }

  export type WishlistMinAggregateInputType = {
    id?: true
    user_id?: true
    class_id?: true
  }

  export type WishlistMaxAggregateInputType = {
    id?: true
    user_id?: true
    class_id?: true
  }

  export type WishlistCountAggregateInputType = {
    id?: true
    user_id?: true
    class_id?: true
    _all?: true
  }

  export type WishlistAggregateArgs = {
    /**
     * Filter which wishlist to aggregate.
     * 
    **/
    where?: wishlistWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of wishlists to fetch.
     * 
    **/
    orderBy?: Enumerable<wishlistOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: wishlistWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` wishlists from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` wishlists.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned wishlists
    **/
    _count?: true | WishlistCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WishlistAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WishlistSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WishlistMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WishlistMaxAggregateInputType
  }

  export type GetWishlistAggregateType<T extends WishlistAggregateArgs> = {
        [P in keyof T & keyof AggregateWishlist]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWishlist[P]>
      : GetScalarType<T[P], AggregateWishlist[P]>
  }




  export type WishlistGroupByArgs = {
    where?: wishlistWhereInput
    orderBy?: Enumerable<wishlistOrderByWithAggregationInput>
    by: Array<WishlistScalarFieldEnum>
    having?: wishlistScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WishlistCountAggregateInputType | true
    _avg?: WishlistAvgAggregateInputType
    _sum?: WishlistSumAggregateInputType
    _min?: WishlistMinAggregateInputType
    _max?: WishlistMaxAggregateInputType
  }


  export type WishlistGroupByOutputType = {
    id: number
    user_id: number
    class_id: number
    _count: WishlistCountAggregateOutputType | null
    _avg: WishlistAvgAggregateOutputType | null
    _sum: WishlistSumAggregateOutputType | null
    _min: WishlistMinAggregateOutputType | null
    _max: WishlistMaxAggregateOutputType | null
  }

  type GetWishlistGroupByPayload<T extends WishlistGroupByArgs> = PrismaPromise<
    Array<
      PickArray<WishlistGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WishlistGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WishlistGroupByOutputType[P]>
            : GetScalarType<T[P], WishlistGroupByOutputType[P]>
        }
      >
    >


  export type wishlistSelect = {
    id?: boolean
    user_id?: boolean
    class_id?: boolean
    classes?: boolean | classesArgs
    users?: boolean | usersArgs
  }

  export type wishlistInclude = {
    classes?: boolean | classesArgs
    users?: boolean | usersArgs
  }

  export type wishlistGetPayload<
    S extends boolean | null | undefined | wishlistArgs,
    U = keyof S
      > = S extends true
        ? wishlist
    : S extends undefined
    ? never
    : S extends wishlistArgs | wishlistFindManyArgs
    ?'include' extends U
    ? wishlist  & {
    [P in TrueKeys<S['include']>]:
        P extends 'classes' ? classesGetPayload<S['include'][P]> :
        P extends 'users' ? usersGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'classes' ? classesGetPayload<S['select'][P]> :
        P extends 'users' ? usersGetPayload<S['select'][P]> :  P extends keyof wishlist ? wishlist[P] : never
  } 
    : wishlist
  : wishlist


  type wishlistCountArgs = Merge<
    Omit<wishlistFindManyArgs, 'select' | 'include'> & {
      select?: WishlistCountAggregateInputType | true
    }
  >

  export interface wishlistDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Wishlist that matches the filter.
     * @param {wishlistFindUniqueArgs} args - Arguments to find a Wishlist
     * @example
     * // Get one Wishlist
     * const wishlist = await prisma.wishlist.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends wishlistFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, wishlistFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'wishlist'> extends True ? CheckSelect<T, Prisma__wishlistClient<wishlist>, Prisma__wishlistClient<wishlistGetPayload<T>>> : CheckSelect<T, Prisma__wishlistClient<wishlist | null >, Prisma__wishlistClient<wishlistGetPayload<T> | null >>

    /**
     * Find the first Wishlist that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {wishlistFindFirstArgs} args - Arguments to find a Wishlist
     * @example
     * // Get one Wishlist
     * const wishlist = await prisma.wishlist.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends wishlistFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, wishlistFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'wishlist'> extends True ? CheckSelect<T, Prisma__wishlistClient<wishlist>, Prisma__wishlistClient<wishlistGetPayload<T>>> : CheckSelect<T, Prisma__wishlistClient<wishlist | null >, Prisma__wishlistClient<wishlistGetPayload<T> | null >>

    /**
     * Find zero or more Wishlists that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {wishlistFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Wishlists
     * const wishlists = await prisma.wishlist.findMany()
     * 
     * // Get first 10 Wishlists
     * const wishlists = await prisma.wishlist.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const wishlistWithIdOnly = await prisma.wishlist.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends wishlistFindManyArgs>(
      args?: SelectSubset<T, wishlistFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<wishlist>>, PrismaPromise<Array<wishlistGetPayload<T>>>>

    /**
     * Create a Wishlist.
     * @param {wishlistCreateArgs} args - Arguments to create a Wishlist.
     * @example
     * // Create one Wishlist
     * const Wishlist = await prisma.wishlist.create({
     *   data: {
     *     // ... data to create a Wishlist
     *   }
     * })
     * 
    **/
    create<T extends wishlistCreateArgs>(
      args: SelectSubset<T, wishlistCreateArgs>
    ): CheckSelect<T, Prisma__wishlistClient<wishlist>, Prisma__wishlistClient<wishlistGetPayload<T>>>

    /**
     * Create many Wishlists.
     *     @param {wishlistCreateManyArgs} args - Arguments to create many Wishlists.
     *     @example
     *     // Create many Wishlists
     *     const wishlist = await prisma.wishlist.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends wishlistCreateManyArgs>(
      args?: SelectSubset<T, wishlistCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Wishlist.
     * @param {wishlistDeleteArgs} args - Arguments to delete one Wishlist.
     * @example
     * // Delete one Wishlist
     * const Wishlist = await prisma.wishlist.delete({
     *   where: {
     *     // ... filter to delete one Wishlist
     *   }
     * })
     * 
    **/
    delete<T extends wishlistDeleteArgs>(
      args: SelectSubset<T, wishlistDeleteArgs>
    ): CheckSelect<T, Prisma__wishlistClient<wishlist>, Prisma__wishlistClient<wishlistGetPayload<T>>>

    /**
     * Update one Wishlist.
     * @param {wishlistUpdateArgs} args - Arguments to update one Wishlist.
     * @example
     * // Update one Wishlist
     * const wishlist = await prisma.wishlist.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends wishlistUpdateArgs>(
      args: SelectSubset<T, wishlistUpdateArgs>
    ): CheckSelect<T, Prisma__wishlistClient<wishlist>, Prisma__wishlistClient<wishlistGetPayload<T>>>

    /**
     * Delete zero or more Wishlists.
     * @param {wishlistDeleteManyArgs} args - Arguments to filter Wishlists to delete.
     * @example
     * // Delete a few Wishlists
     * const { count } = await prisma.wishlist.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends wishlistDeleteManyArgs>(
      args?: SelectSubset<T, wishlistDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Wishlists.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {wishlistUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Wishlists
     * const wishlist = await prisma.wishlist.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends wishlistUpdateManyArgs>(
      args: SelectSubset<T, wishlistUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Wishlist.
     * @param {wishlistUpsertArgs} args - Arguments to update or create a Wishlist.
     * @example
     * // Update or create a Wishlist
     * const wishlist = await prisma.wishlist.upsert({
     *   create: {
     *     // ... data to create a Wishlist
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Wishlist we want to update
     *   }
     * })
    **/
    upsert<T extends wishlistUpsertArgs>(
      args: SelectSubset<T, wishlistUpsertArgs>
    ): CheckSelect<T, Prisma__wishlistClient<wishlist>, Prisma__wishlistClient<wishlistGetPayload<T>>>

    /**
     * Find one Wishlist that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {wishlistFindUniqueOrThrowArgs} args - Arguments to find a Wishlist
     * @example
     * // Get one Wishlist
     * const wishlist = await prisma.wishlist.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends wishlistFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, wishlistFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__wishlistClient<wishlist>, Prisma__wishlistClient<wishlistGetPayload<T>>>

    /**
     * Find the first Wishlist that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {wishlistFindFirstOrThrowArgs} args - Arguments to find a Wishlist
     * @example
     * // Get one Wishlist
     * const wishlist = await prisma.wishlist.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends wishlistFindFirstOrThrowArgs>(
      args?: SelectSubset<T, wishlistFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__wishlistClient<wishlist>, Prisma__wishlistClient<wishlistGetPayload<T>>>

    /**
     * Count the number of Wishlists.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {wishlistCountArgs} args - Arguments to filter Wishlists to count.
     * @example
     * // Count the number of Wishlists
     * const count = await prisma.wishlist.count({
     *   where: {
     *     // ... the filter for the Wishlists we want to count
     *   }
     * })
    **/
    count<T extends wishlistCountArgs>(
      args?: Subset<T, wishlistCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WishlistCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Wishlist.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WishlistAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WishlistAggregateArgs>(args: Subset<T, WishlistAggregateArgs>): PrismaPromise<GetWishlistAggregateType<T>>

    /**
     * Group by Wishlist.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WishlistGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WishlistGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WishlistGroupByArgs['orderBy'] }
        : { orderBy?: WishlistGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WishlistGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWishlistGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for wishlist.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__wishlistClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    classes<T extends classesArgs = {}>(args?: Subset<T, classesArgs>): CheckSelect<T, Prisma__classesClient<classes | null >, Prisma__classesClient<classesGetPayload<T> | null >>;

    users<T extends usersArgs = {}>(args?: Subset<T, usersArgs>): CheckSelect<T, Prisma__usersClient<users | null >, Prisma__usersClient<usersGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * wishlist base type for findUnique actions
   */
  export type wishlistFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the wishlist
     * 
    **/
    select?: wishlistSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: wishlistInclude | null
    /**
     * Filter, which wishlist to fetch.
     * 
    **/
    where: wishlistWhereUniqueInput
  }

  /**
   * wishlist: findUnique
   */
  export interface wishlistFindUniqueArgs extends wishlistFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * wishlist base type for findFirst actions
   */
  export type wishlistFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the wishlist
     * 
    **/
    select?: wishlistSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: wishlistInclude | null
    /**
     * Filter, which wishlist to fetch.
     * 
    **/
    where?: wishlistWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of wishlists to fetch.
     * 
    **/
    orderBy?: Enumerable<wishlistOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for wishlists.
     * 
    **/
    cursor?: wishlistWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` wishlists from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` wishlists.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of wishlists.
     * 
    **/
    distinct?: Enumerable<WishlistScalarFieldEnum>
  }

  /**
   * wishlist: findFirst
   */
  export interface wishlistFindFirstArgs extends wishlistFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * wishlist findMany
   */
  export type wishlistFindManyArgs = {
    /**
     * Select specific fields to fetch from the wishlist
     * 
    **/
    select?: wishlistSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: wishlistInclude | null
    /**
     * Filter, which wishlists to fetch.
     * 
    **/
    where?: wishlistWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of wishlists to fetch.
     * 
    **/
    orderBy?: Enumerable<wishlistOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing wishlists.
     * 
    **/
    cursor?: wishlistWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` wishlists from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` wishlists.
     * 
    **/
    skip?: number
    distinct?: Enumerable<WishlistScalarFieldEnum>
  }


  /**
   * wishlist create
   */
  export type wishlistCreateArgs = {
    /**
     * Select specific fields to fetch from the wishlist
     * 
    **/
    select?: wishlistSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: wishlistInclude | null
    /**
     * The data needed to create a wishlist.
     * 
    **/
    data: XOR<wishlistCreateInput, wishlistUncheckedCreateInput>
  }


  /**
   * wishlist createMany
   */
  export type wishlistCreateManyArgs = {
    /**
     * The data used to create many wishlists.
     * 
    **/
    data: Enumerable<wishlistCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * wishlist update
   */
  export type wishlistUpdateArgs = {
    /**
     * Select specific fields to fetch from the wishlist
     * 
    **/
    select?: wishlistSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: wishlistInclude | null
    /**
     * The data needed to update a wishlist.
     * 
    **/
    data: XOR<wishlistUpdateInput, wishlistUncheckedUpdateInput>
    /**
     * Choose, which wishlist to update.
     * 
    **/
    where: wishlistWhereUniqueInput
  }


  /**
   * wishlist updateMany
   */
  export type wishlistUpdateManyArgs = {
    /**
     * The data used to update wishlists.
     * 
    **/
    data: XOR<wishlistUpdateManyMutationInput, wishlistUncheckedUpdateManyInput>
    /**
     * Filter which wishlists to update
     * 
    **/
    where?: wishlistWhereInput
  }


  /**
   * wishlist upsert
   */
  export type wishlistUpsertArgs = {
    /**
     * Select specific fields to fetch from the wishlist
     * 
    **/
    select?: wishlistSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: wishlistInclude | null
    /**
     * The filter to search for the wishlist to update in case it exists.
     * 
    **/
    where: wishlistWhereUniqueInput
    /**
     * In case the wishlist found by the `where` argument doesn't exist, create a new wishlist with this data.
     * 
    **/
    create: XOR<wishlistCreateInput, wishlistUncheckedCreateInput>
    /**
     * In case the wishlist was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<wishlistUpdateInput, wishlistUncheckedUpdateInput>
  }


  /**
   * wishlist delete
   */
  export type wishlistDeleteArgs = {
    /**
     * Select specific fields to fetch from the wishlist
     * 
    **/
    select?: wishlistSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: wishlistInclude | null
    /**
     * Filter which wishlist to delete.
     * 
    **/
    where: wishlistWhereUniqueInput
  }


  /**
   * wishlist deleteMany
   */
  export type wishlistDeleteManyArgs = {
    /**
     * Filter which wishlists to delete
     * 
    **/
    where?: wishlistWhereInput
  }


  /**
   * wishlist: findUniqueOrThrow
   */
  export type wishlistFindUniqueOrThrowArgs = wishlistFindUniqueArgsBase
      

  /**
   * wishlist: findFirstOrThrow
   */
  export type wishlistFindFirstOrThrowArgs = wishlistFindFirstArgsBase
      

  /**
   * wishlist without action
   */
  export type wishlistArgs = {
    /**
     * Select specific fields to fetch from the wishlist
     * 
    **/
    select?: wishlistSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: wishlistInclude | null
  }



  /**
   * Enums
   */

  // Based on
  // https://github.com/microsoft/TypeScript/issues/3192#issuecomment-261720275

  export const UsersScalarFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    password: 'password',
    img: 'img',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type UsersScalarFieldEnum = (typeof UsersScalarFieldEnum)[keyof typeof UsersScalarFieldEnum]


  export const CategoryScalarFieldEnum: {
    id: 'id',
    name: 'name',
    depth: 'depth',
    parent_id: 'parent_id'
  };

  export type CategoryScalarFieldEnum = (typeof CategoryScalarFieldEnum)[keyof typeof CategoryScalarFieldEnum]


  export const Class_imgScalarFieldEnum: {
    id: 'id',
    url: 'url',
    class_id: 'class_id'
  };

  export type Class_imgScalarFieldEnum = (typeof Class_imgScalarFieldEnum)[keyof typeof Class_imgScalarFieldEnum]


  export const ClassesScalarFieldEnum: {
    id: 'id',
    name: 'name',
    instructor_id: 'instructor_id',
    price: 'price',
    img: 'img',
    rate: 'rate',
    description: 'description',
    students: 'students',
    sessions: 'sessions',
    price_scope: 'price_scope',
    category1_id: 'category1_id',
    category2_id: 'category2_id',
    category3_id: 'category3_id',
    level_id: 'level_id',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type ClassesScalarFieldEnum = (typeof ClassesScalarFieldEnum)[keyof typeof ClassesScalarFieldEnum]


  export const ContentsScalarFieldEnum: {
    id: 'id',
    class_id: 'class_id',
    content: 'content'
  };

  export type ContentsScalarFieldEnum = (typeof ContentsScalarFieldEnum)[keyof typeof ContentsScalarFieldEnum]


  export const InstructorScalarFieldEnum: {
    id: 'id',
    name: 'name'
  };

  export type InstructorScalarFieldEnum = (typeof InstructorScalarFieldEnum)[keyof typeof InstructorScalarFieldEnum]


  export const LevelScalarFieldEnum: {
    id: 'id',
    level: 'level'
  };

  export type LevelScalarFieldEnum = (typeof LevelScalarFieldEnum)[keyof typeof LevelScalarFieldEnum]


  export const My_classesScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    class_id: 'class_id',
    progress: 'progress'
  };

  export type My_classesScalarFieldEnum = (typeof My_classesScalarFieldEnum)[keyof typeof My_classesScalarFieldEnum]


  export const Price_scopeScalarFieldEnum: {
    id: 'id',
    scope: 'scope'
  };

  export type Price_scopeScalarFieldEnum = (typeof Price_scopeScalarFieldEnum)[keyof typeof Price_scopeScalarFieldEnum]


  export const ReviewScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    rate: 'rate',
    class_id: 'class_id'
  };

  export type ReviewScalarFieldEnum = (typeof ReviewScalarFieldEnum)[keyof typeof ReviewScalarFieldEnum]


  export const WishlistScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    class_id: 'class_id'
  };

  export type WishlistScalarFieldEnum = (typeof WishlistScalarFieldEnum)[keyof typeof WishlistScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  /**
   * Deep Input Types
   */


  export type usersWhereInput = {
    AND?: Enumerable<usersWhereInput>
    OR?: Enumerable<usersWhereInput>
    NOT?: Enumerable<usersWhereInput>
    id?: IntFilter | number
    name?: StringNullableFilter | string | null
    email?: StringFilter | string
    password?: StringFilter | string
    img?: StringNullableFilter | string | null
    created_at?: DateTimeNullableFilter | Date | string | null
    updated_at?: DateTimeNullableFilter | Date | string | null
    my_classes?: My_classesListRelationFilter
    review?: ReviewListRelationFilter
    wishlist?: WishlistListRelationFilter
  }

  export type usersOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    img?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    my_classes?: my_classesOrderByRelationAggregateInput
    review?: reviewOrderByRelationAggregateInput
    wishlist?: wishlistOrderByRelationAggregateInput
  }

  export type usersWhereUniqueInput = {
    id?: number
    email?: string
  }

  export type usersOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    img?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: usersCountOrderByAggregateInput
    _avg?: usersAvgOrderByAggregateInput
    _max?: usersMaxOrderByAggregateInput
    _min?: usersMinOrderByAggregateInput
    _sum?: usersSumOrderByAggregateInput
  }

  export type usersScalarWhereWithAggregatesInput = {
    AND?: Enumerable<usersScalarWhereWithAggregatesInput>
    OR?: Enumerable<usersScalarWhereWithAggregatesInput>
    NOT?: Enumerable<usersScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringNullableWithAggregatesFilter | string | null
    email?: StringWithAggregatesFilter | string
    password?: StringWithAggregatesFilter | string
    img?: StringNullableWithAggregatesFilter | string | null
    created_at?: DateTimeNullableWithAggregatesFilter | Date | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type categoryWhereInput = {
    AND?: Enumerable<categoryWhereInput>
    OR?: Enumerable<categoryWhereInput>
    NOT?: Enumerable<categoryWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    depth?: IntNullableFilter | number | null
    parent_id?: IntNullableFilter | number | null
    classes_categoryToclasses_category1_id?: ClassesListRelationFilter
    classes_categoryToclasses_category2_id?: ClassesListRelationFilter
    classes_categoryToclasses_category3_id?: ClassesListRelationFilter
  }

  export type categoryOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    depth?: SortOrder
    parent_id?: SortOrder
    classes_categoryToclasses_category1_id?: classesOrderByRelationAggregateInput
    classes_categoryToclasses_category2_id?: classesOrderByRelationAggregateInput
    classes_categoryToclasses_category3_id?: classesOrderByRelationAggregateInput
  }

  export type categoryWhereUniqueInput = {
    id?: number
  }

  export type categoryOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    depth?: SortOrder
    parent_id?: SortOrder
    _count?: categoryCountOrderByAggregateInput
    _avg?: categoryAvgOrderByAggregateInput
    _max?: categoryMaxOrderByAggregateInput
    _min?: categoryMinOrderByAggregateInput
    _sum?: categorySumOrderByAggregateInput
  }

  export type categoryScalarWhereWithAggregatesInput = {
    AND?: Enumerable<categoryScalarWhereWithAggregatesInput>
    OR?: Enumerable<categoryScalarWhereWithAggregatesInput>
    NOT?: Enumerable<categoryScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
    depth?: IntNullableWithAggregatesFilter | number | null
    parent_id?: IntNullableWithAggregatesFilter | number | null
  }

  export type class_imgWhereInput = {
    AND?: Enumerable<class_imgWhereInput>
    OR?: Enumerable<class_imgWhereInput>
    NOT?: Enumerable<class_imgWhereInput>
    id?: IntFilter | number
    url?: StringFilter | string
    class_id?: IntFilter | number
    classes?: XOR<ClassesRelationFilter, classesWhereInput>
  }

  export type class_imgOrderByWithRelationInput = {
    id?: SortOrder
    url?: SortOrder
    class_id?: SortOrder
    classes?: classesOrderByWithRelationInput
  }

  export type class_imgWhereUniqueInput = {
    id?: number
  }

  export type class_imgOrderByWithAggregationInput = {
    id?: SortOrder
    url?: SortOrder
    class_id?: SortOrder
    _count?: class_imgCountOrderByAggregateInput
    _avg?: class_imgAvgOrderByAggregateInput
    _max?: class_imgMaxOrderByAggregateInput
    _min?: class_imgMinOrderByAggregateInput
    _sum?: class_imgSumOrderByAggregateInput
  }

  export type class_imgScalarWhereWithAggregatesInput = {
    AND?: Enumerable<class_imgScalarWhereWithAggregatesInput>
    OR?: Enumerable<class_imgScalarWhereWithAggregatesInput>
    NOT?: Enumerable<class_imgScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    url?: StringWithAggregatesFilter | string
    class_id?: IntWithAggregatesFilter | number
  }

  export type classesWhereInput = {
    AND?: Enumerable<classesWhereInput>
    OR?: Enumerable<classesWhereInput>
    NOT?: Enumerable<classesWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    instructor_id?: IntFilter | number
    price?: FloatNullableFilter | number | null
    img?: StringNullableFilter | string | null
    rate?: FloatNullableFilter | number | null
    description?: StringNullableFilter | string | null
    students?: IntNullableFilter | number | null
    sessions?: IntNullableFilter | number | null
    price_scope?: IntNullableFilter | number | null
    category1_id?: IntNullableFilter | number | null
    category2_id?: IntNullableFilter | number | null
    category3_id?: IntNullableFilter | number | null
    level_id?: IntNullableFilter | number | null
    created_at?: DateTimeNullableFilter | Date | string | null
    updated_at?: DateTimeNullableFilter | Date | string | null
    category_categoryToclasses_category1_id?: XOR<CategoryRelationFilter, categoryWhereInput> | null
    category_categoryToclasses_category2_id?: XOR<CategoryRelationFilter, categoryWhereInput> | null
    category_categoryToclasses_category3_id?: XOR<CategoryRelationFilter, categoryWhereInput> | null
    instructor?: XOR<InstructorRelationFilter, instructorWhereInput>
    level?: XOR<LevelRelationFilter, levelWhereInput> | null
    price_scope_classesToprice_scope?: XOR<Price_scopeRelationFilter, price_scopeWhereInput> | null
    class_img?: Class_imgListRelationFilter
    contents?: ContentsListRelationFilter
    my_classes?: My_classesListRelationFilter
    review?: ReviewListRelationFilter
    wishlist?: WishlistListRelationFilter
  }

  export type classesOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    instructor_id?: SortOrder
    price?: SortOrder
    img?: SortOrder
    rate?: SortOrder
    description?: SortOrder
    students?: SortOrder
    sessions?: SortOrder
    price_scope?: SortOrder
    category1_id?: SortOrder
    category2_id?: SortOrder
    category3_id?: SortOrder
    level_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    category_categoryToclasses_category1_id?: categoryOrderByWithRelationInput
    category_categoryToclasses_category2_id?: categoryOrderByWithRelationInput
    category_categoryToclasses_category3_id?: categoryOrderByWithRelationInput
    instructor?: instructorOrderByWithRelationInput
    level?: levelOrderByWithRelationInput
    price_scope_classesToprice_scope?: price_scopeOrderByWithRelationInput
    class_img?: class_imgOrderByRelationAggregateInput
    contents?: contentsOrderByRelationAggregateInput
    my_classes?: my_classesOrderByRelationAggregateInput
    review?: reviewOrderByRelationAggregateInput
    wishlist?: wishlistOrderByRelationAggregateInput
  }

  export type classesWhereUniqueInput = {
    id?: number
  }

  export type classesOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    instructor_id?: SortOrder
    price?: SortOrder
    img?: SortOrder
    rate?: SortOrder
    description?: SortOrder
    students?: SortOrder
    sessions?: SortOrder
    price_scope?: SortOrder
    category1_id?: SortOrder
    category2_id?: SortOrder
    category3_id?: SortOrder
    level_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: classesCountOrderByAggregateInput
    _avg?: classesAvgOrderByAggregateInput
    _max?: classesMaxOrderByAggregateInput
    _min?: classesMinOrderByAggregateInput
    _sum?: classesSumOrderByAggregateInput
  }

  export type classesScalarWhereWithAggregatesInput = {
    AND?: Enumerable<classesScalarWhereWithAggregatesInput>
    OR?: Enumerable<classesScalarWhereWithAggregatesInput>
    NOT?: Enumerable<classesScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
    instructor_id?: IntWithAggregatesFilter | number
    price?: FloatNullableWithAggregatesFilter | number | null
    img?: StringNullableWithAggregatesFilter | string | null
    rate?: FloatNullableWithAggregatesFilter | number | null
    description?: StringNullableWithAggregatesFilter | string | null
    students?: IntNullableWithAggregatesFilter | number | null
    sessions?: IntNullableWithAggregatesFilter | number | null
    price_scope?: IntNullableWithAggregatesFilter | number | null
    category1_id?: IntNullableWithAggregatesFilter | number | null
    category2_id?: IntNullableWithAggregatesFilter | number | null
    category3_id?: IntNullableWithAggregatesFilter | number | null
    level_id?: IntNullableWithAggregatesFilter | number | null
    created_at?: DateTimeNullableWithAggregatesFilter | Date | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type contentsWhereInput = {
    AND?: Enumerable<contentsWhereInput>
    OR?: Enumerable<contentsWhereInput>
    NOT?: Enumerable<contentsWhereInput>
    id?: IntFilter | number
    class_id?: IntFilter | number
    content?: StringNullableFilter | string | null
    classes?: XOR<ClassesRelationFilter, classesWhereInput>
  }

  export type contentsOrderByWithRelationInput = {
    id?: SortOrder
    class_id?: SortOrder
    content?: SortOrder
    classes?: classesOrderByWithRelationInput
  }

  export type contentsWhereUniqueInput = {
    id?: number
  }

  export type contentsOrderByWithAggregationInput = {
    id?: SortOrder
    class_id?: SortOrder
    content?: SortOrder
    _count?: contentsCountOrderByAggregateInput
    _avg?: contentsAvgOrderByAggregateInput
    _max?: contentsMaxOrderByAggregateInput
    _min?: contentsMinOrderByAggregateInput
    _sum?: contentsSumOrderByAggregateInput
  }

  export type contentsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<contentsScalarWhereWithAggregatesInput>
    OR?: Enumerable<contentsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<contentsScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    class_id?: IntWithAggregatesFilter | number
    content?: StringNullableWithAggregatesFilter | string | null
  }

  export type instructorWhereInput = {
    AND?: Enumerable<instructorWhereInput>
    OR?: Enumerable<instructorWhereInput>
    NOT?: Enumerable<instructorWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    classes?: ClassesListRelationFilter
  }

  export type instructorOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    classes?: classesOrderByRelationAggregateInput
  }

  export type instructorWhereUniqueInput = {
    id?: number
  }

  export type instructorOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    _count?: instructorCountOrderByAggregateInput
    _avg?: instructorAvgOrderByAggregateInput
    _max?: instructorMaxOrderByAggregateInput
    _min?: instructorMinOrderByAggregateInput
    _sum?: instructorSumOrderByAggregateInput
  }

  export type instructorScalarWhereWithAggregatesInput = {
    AND?: Enumerable<instructorScalarWhereWithAggregatesInput>
    OR?: Enumerable<instructorScalarWhereWithAggregatesInput>
    NOT?: Enumerable<instructorScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
  }

  export type levelWhereInput = {
    AND?: Enumerable<levelWhereInput>
    OR?: Enumerable<levelWhereInput>
    NOT?: Enumerable<levelWhereInput>
    id?: IntFilter | number
    level?: StringFilter | string
    classes?: ClassesListRelationFilter
  }

  export type levelOrderByWithRelationInput = {
    id?: SortOrder
    level?: SortOrder
    classes?: classesOrderByRelationAggregateInput
  }

  export type levelWhereUniqueInput = {
    id?: number
  }

  export type levelOrderByWithAggregationInput = {
    id?: SortOrder
    level?: SortOrder
    _count?: levelCountOrderByAggregateInput
    _avg?: levelAvgOrderByAggregateInput
    _max?: levelMaxOrderByAggregateInput
    _min?: levelMinOrderByAggregateInput
    _sum?: levelSumOrderByAggregateInput
  }

  export type levelScalarWhereWithAggregatesInput = {
    AND?: Enumerable<levelScalarWhereWithAggregatesInput>
    OR?: Enumerable<levelScalarWhereWithAggregatesInput>
    NOT?: Enumerable<levelScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    level?: StringWithAggregatesFilter | string
  }

  export type my_classesWhereInput = {
    AND?: Enumerable<my_classesWhereInput>
    OR?: Enumerable<my_classesWhereInput>
    NOT?: Enumerable<my_classesWhereInput>
    id?: IntFilter | number
    user_id?: IntFilter | number
    class_id?: IntFilter | number
    progress?: IntFilter | number
    classes?: XOR<ClassesRelationFilter, classesWhereInput>
    users?: XOR<UsersRelationFilter, usersWhereInput>
  }

  export type my_classesOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrder
    class_id?: SortOrder
    progress?: SortOrder
    classes?: classesOrderByWithRelationInput
    users?: usersOrderByWithRelationInput
  }

  export type my_classesWhereUniqueInput = {
    id?: number
  }

  export type my_classesOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    class_id?: SortOrder
    progress?: SortOrder
    _count?: my_classesCountOrderByAggregateInput
    _avg?: my_classesAvgOrderByAggregateInput
    _max?: my_classesMaxOrderByAggregateInput
    _min?: my_classesMinOrderByAggregateInput
    _sum?: my_classesSumOrderByAggregateInput
  }

  export type my_classesScalarWhereWithAggregatesInput = {
    AND?: Enumerable<my_classesScalarWhereWithAggregatesInput>
    OR?: Enumerable<my_classesScalarWhereWithAggregatesInput>
    NOT?: Enumerable<my_classesScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    user_id?: IntWithAggregatesFilter | number
    class_id?: IntWithAggregatesFilter | number
    progress?: IntWithAggregatesFilter | number
  }

  export type price_scopeWhereInput = {
    AND?: Enumerable<price_scopeWhereInput>
    OR?: Enumerable<price_scopeWhereInput>
    NOT?: Enumerable<price_scopeWhereInput>
    id?: IntFilter | number
    scope?: StringNullableFilter | string | null
    classes?: ClassesListRelationFilter
  }

  export type price_scopeOrderByWithRelationInput = {
    id?: SortOrder
    scope?: SortOrder
    classes?: classesOrderByRelationAggregateInput
  }

  export type price_scopeWhereUniqueInput = {
    id?: number
  }

  export type price_scopeOrderByWithAggregationInput = {
    id?: SortOrder
    scope?: SortOrder
    _count?: price_scopeCountOrderByAggregateInput
    _avg?: price_scopeAvgOrderByAggregateInput
    _max?: price_scopeMaxOrderByAggregateInput
    _min?: price_scopeMinOrderByAggregateInput
    _sum?: price_scopeSumOrderByAggregateInput
  }

  export type price_scopeScalarWhereWithAggregatesInput = {
    AND?: Enumerable<price_scopeScalarWhereWithAggregatesInput>
    OR?: Enumerable<price_scopeScalarWhereWithAggregatesInput>
    NOT?: Enumerable<price_scopeScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    scope?: StringNullableWithAggregatesFilter | string | null
  }

  export type reviewWhereInput = {
    AND?: Enumerable<reviewWhereInput>
    OR?: Enumerable<reviewWhereInput>
    NOT?: Enumerable<reviewWhereInput>
    id?: IntFilter | number
    user_id?: IntFilter | number
    rate?: FloatFilter | number
    class_id?: IntFilter | number
    classes?: XOR<ClassesRelationFilter, classesWhereInput>
    users?: XOR<UsersRelationFilter, usersWhereInput>
  }

  export type reviewOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrder
    rate?: SortOrder
    class_id?: SortOrder
    classes?: classesOrderByWithRelationInput
    users?: usersOrderByWithRelationInput
  }

  export type reviewWhereUniqueInput = {
    id?: number
  }

  export type reviewOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    rate?: SortOrder
    class_id?: SortOrder
    _count?: reviewCountOrderByAggregateInput
    _avg?: reviewAvgOrderByAggregateInput
    _max?: reviewMaxOrderByAggregateInput
    _min?: reviewMinOrderByAggregateInput
    _sum?: reviewSumOrderByAggregateInput
  }

  export type reviewScalarWhereWithAggregatesInput = {
    AND?: Enumerable<reviewScalarWhereWithAggregatesInput>
    OR?: Enumerable<reviewScalarWhereWithAggregatesInput>
    NOT?: Enumerable<reviewScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    user_id?: IntWithAggregatesFilter | number
    rate?: FloatWithAggregatesFilter | number
    class_id?: IntWithAggregatesFilter | number
  }

  export type wishlistWhereInput = {
    AND?: Enumerable<wishlistWhereInput>
    OR?: Enumerable<wishlistWhereInput>
    NOT?: Enumerable<wishlistWhereInput>
    id?: IntFilter | number
    user_id?: IntFilter | number
    class_id?: IntFilter | number
    classes?: XOR<ClassesRelationFilter, classesWhereInput>
    users?: XOR<UsersRelationFilter, usersWhereInput>
  }

  export type wishlistOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrder
    class_id?: SortOrder
    classes?: classesOrderByWithRelationInput
    users?: usersOrderByWithRelationInput
  }

  export type wishlistWhereUniqueInput = {
    id?: number
  }

  export type wishlistOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    class_id?: SortOrder
    _count?: wishlistCountOrderByAggregateInput
    _avg?: wishlistAvgOrderByAggregateInput
    _max?: wishlistMaxOrderByAggregateInput
    _min?: wishlistMinOrderByAggregateInput
    _sum?: wishlistSumOrderByAggregateInput
  }

  export type wishlistScalarWhereWithAggregatesInput = {
    AND?: Enumerable<wishlistScalarWhereWithAggregatesInput>
    OR?: Enumerable<wishlistScalarWhereWithAggregatesInput>
    NOT?: Enumerable<wishlistScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    user_id?: IntWithAggregatesFilter | number
    class_id?: IntWithAggregatesFilter | number
  }

  export type usersCreateInput = {
    name?: string | null
    email: string
    password: string
    img?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    my_classes?: my_classesCreateNestedManyWithoutUsersInput
    review?: reviewCreateNestedManyWithoutUsersInput
    wishlist?: wishlistCreateNestedManyWithoutUsersInput
  }

  export type usersUncheckedCreateInput = {
    id?: number
    name?: string | null
    email: string
    password: string
    img?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    my_classes?: my_classesUncheckedCreateNestedManyWithoutUsersInput
    review?: reviewUncheckedCreateNestedManyWithoutUsersInput
    wishlist?: wishlistUncheckedCreateNestedManyWithoutUsersInput
  }

  export type usersUpdateInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    img?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    my_classes?: my_classesUpdateManyWithoutUsersNestedInput
    review?: reviewUpdateManyWithoutUsersNestedInput
    wishlist?: wishlistUpdateManyWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    img?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    my_classes?: my_classesUncheckedUpdateManyWithoutUsersNestedInput
    review?: reviewUncheckedUpdateManyWithoutUsersNestedInput
    wishlist?: wishlistUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type usersCreateManyInput = {
    id?: number
    name?: string | null
    email: string
    password: string
    img?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type usersUpdateManyMutationInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    img?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type usersUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    img?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type categoryCreateInput = {
    name: string
    depth?: number | null
    parent_id?: number | null
    classes_categoryToclasses_category1_id?: classesCreateNestedManyWithoutCategory_categoryToclasses_category1_idInput
    classes_categoryToclasses_category2_id?: classesCreateNestedManyWithoutCategory_categoryToclasses_category2_idInput
    classes_categoryToclasses_category3_id?: classesCreateNestedManyWithoutCategory_categoryToclasses_category3_idInput
  }

  export type categoryUncheckedCreateInput = {
    id?: number
    name: string
    depth?: number | null
    parent_id?: number | null
    classes_categoryToclasses_category1_id?: classesUncheckedCreateNestedManyWithoutCategory_categoryToclasses_category1_idInput
    classes_categoryToclasses_category2_id?: classesUncheckedCreateNestedManyWithoutCategory_categoryToclasses_category2_idInput
    classes_categoryToclasses_category3_id?: classesUncheckedCreateNestedManyWithoutCategory_categoryToclasses_category3_idInput
  }

  export type categoryUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    depth?: NullableIntFieldUpdateOperationsInput | number | null
    parent_id?: NullableIntFieldUpdateOperationsInput | number | null
    classes_categoryToclasses_category1_id?: classesUpdateManyWithoutCategory_categoryToclasses_category1_idNestedInput
    classes_categoryToclasses_category2_id?: classesUpdateManyWithoutCategory_categoryToclasses_category2_idNestedInput
    classes_categoryToclasses_category3_id?: classesUpdateManyWithoutCategory_categoryToclasses_category3_idNestedInput
  }

  export type categoryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    depth?: NullableIntFieldUpdateOperationsInput | number | null
    parent_id?: NullableIntFieldUpdateOperationsInput | number | null
    classes_categoryToclasses_category1_id?: classesUncheckedUpdateManyWithoutCategory_categoryToclasses_category1_idNestedInput
    classes_categoryToclasses_category2_id?: classesUncheckedUpdateManyWithoutCategory_categoryToclasses_category2_idNestedInput
    classes_categoryToclasses_category3_id?: classesUncheckedUpdateManyWithoutCategory_categoryToclasses_category3_idNestedInput
  }

  export type categoryCreateManyInput = {
    id?: number
    name: string
    depth?: number | null
    parent_id?: number | null
  }

  export type categoryUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    depth?: NullableIntFieldUpdateOperationsInput | number | null
    parent_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type categoryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    depth?: NullableIntFieldUpdateOperationsInput | number | null
    parent_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type class_imgCreateInput = {
    url: string
    classes: classesCreateNestedOneWithoutClass_imgInput
  }

  export type class_imgUncheckedCreateInput = {
    id?: number
    url: string
    class_id: number
  }

  export type class_imgUpdateInput = {
    url?: StringFieldUpdateOperationsInput | string
    classes?: classesUpdateOneRequiredWithoutClass_imgNestedInput
  }

  export type class_imgUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    class_id?: IntFieldUpdateOperationsInput | number
  }

  export type class_imgCreateManyInput = {
    id?: number
    url: string
    class_id: number
  }

  export type class_imgUpdateManyMutationInput = {
    url?: StringFieldUpdateOperationsInput | string
  }

  export type class_imgUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    class_id?: IntFieldUpdateOperationsInput | number
  }

  export type classesCreateInput = {
    name: string
    price?: number | null
    img?: string | null
    rate?: number | null
    description?: string | null
    students?: number | null
    sessions?: number | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    category_categoryToclasses_category1_id?: categoryCreateNestedOneWithoutClasses_categoryToclasses_category1_idInput
    category_categoryToclasses_category2_id?: categoryCreateNestedOneWithoutClasses_categoryToclasses_category2_idInput
    category_categoryToclasses_category3_id?: categoryCreateNestedOneWithoutClasses_categoryToclasses_category3_idInput
    instructor: instructorCreateNestedOneWithoutClassesInput
    level?: levelCreateNestedOneWithoutClassesInput
    price_scope_classesToprice_scope?: price_scopeCreateNestedOneWithoutClassesInput
    class_img?: class_imgCreateNestedManyWithoutClassesInput
    contents?: contentsCreateNestedManyWithoutClassesInput
    my_classes?: my_classesCreateNestedManyWithoutClassesInput
    review?: reviewCreateNestedManyWithoutClassesInput
    wishlist?: wishlistCreateNestedManyWithoutClassesInput
  }

  export type classesUncheckedCreateInput = {
    id?: number
    name: string
    instructor_id: number
    price?: number | null
    img?: string | null
    rate?: number | null
    description?: string | null
    students?: number | null
    sessions?: number | null
    price_scope?: number | null
    category1_id?: number | null
    category2_id?: number | null
    category3_id?: number | null
    level_id?: number | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    class_img?: class_imgUncheckedCreateNestedManyWithoutClassesInput
    contents?: contentsUncheckedCreateNestedManyWithoutClassesInput
    my_classes?: my_classesUncheckedCreateNestedManyWithoutClassesInput
    review?: reviewUncheckedCreateNestedManyWithoutClassesInput
    wishlist?: wishlistUncheckedCreateNestedManyWithoutClassesInput
  }

  export type classesUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    img?: NullableStringFieldUpdateOperationsInput | string | null
    rate?: NullableFloatFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    students?: NullableIntFieldUpdateOperationsInput | number | null
    sessions?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    category_categoryToclasses_category1_id?: categoryUpdateOneWithoutClasses_categoryToclasses_category1_idNestedInput
    category_categoryToclasses_category2_id?: categoryUpdateOneWithoutClasses_categoryToclasses_category2_idNestedInput
    category_categoryToclasses_category3_id?: categoryUpdateOneWithoutClasses_categoryToclasses_category3_idNestedInput
    instructor?: instructorUpdateOneRequiredWithoutClassesNestedInput
    level?: levelUpdateOneWithoutClassesNestedInput
    price_scope_classesToprice_scope?: price_scopeUpdateOneWithoutClassesNestedInput
    class_img?: class_imgUpdateManyWithoutClassesNestedInput
    contents?: contentsUpdateManyWithoutClassesNestedInput
    my_classes?: my_classesUpdateManyWithoutClassesNestedInput
    review?: reviewUpdateManyWithoutClassesNestedInput
    wishlist?: wishlistUpdateManyWithoutClassesNestedInput
  }

  export type classesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    instructor_id?: IntFieldUpdateOperationsInput | number
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    img?: NullableStringFieldUpdateOperationsInput | string | null
    rate?: NullableFloatFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    students?: NullableIntFieldUpdateOperationsInput | number | null
    sessions?: NullableIntFieldUpdateOperationsInput | number | null
    price_scope?: NullableIntFieldUpdateOperationsInput | number | null
    category1_id?: NullableIntFieldUpdateOperationsInput | number | null
    category2_id?: NullableIntFieldUpdateOperationsInput | number | null
    category3_id?: NullableIntFieldUpdateOperationsInput | number | null
    level_id?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    class_img?: class_imgUncheckedUpdateManyWithoutClassesNestedInput
    contents?: contentsUncheckedUpdateManyWithoutClassesNestedInput
    my_classes?: my_classesUncheckedUpdateManyWithoutClassesNestedInput
    review?: reviewUncheckedUpdateManyWithoutClassesNestedInput
    wishlist?: wishlistUncheckedUpdateManyWithoutClassesNestedInput
  }

  export type classesCreateManyInput = {
    id?: number
    name: string
    instructor_id: number
    price?: number | null
    img?: string | null
    rate?: number | null
    description?: string | null
    students?: number | null
    sessions?: number | null
    price_scope?: number | null
    category1_id?: number | null
    category2_id?: number | null
    category3_id?: number | null
    level_id?: number | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type classesUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    img?: NullableStringFieldUpdateOperationsInput | string | null
    rate?: NullableFloatFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    students?: NullableIntFieldUpdateOperationsInput | number | null
    sessions?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type classesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    instructor_id?: IntFieldUpdateOperationsInput | number
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    img?: NullableStringFieldUpdateOperationsInput | string | null
    rate?: NullableFloatFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    students?: NullableIntFieldUpdateOperationsInput | number | null
    sessions?: NullableIntFieldUpdateOperationsInput | number | null
    price_scope?: NullableIntFieldUpdateOperationsInput | number | null
    category1_id?: NullableIntFieldUpdateOperationsInput | number | null
    category2_id?: NullableIntFieldUpdateOperationsInput | number | null
    category3_id?: NullableIntFieldUpdateOperationsInput | number | null
    level_id?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type contentsCreateInput = {
    content?: string | null
    classes: classesCreateNestedOneWithoutContentsInput
  }

  export type contentsUncheckedCreateInput = {
    id?: number
    class_id: number
    content?: string | null
  }

  export type contentsUpdateInput = {
    content?: NullableStringFieldUpdateOperationsInput | string | null
    classes?: classesUpdateOneRequiredWithoutContentsNestedInput
  }

  export type contentsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    class_id?: IntFieldUpdateOperationsInput | number
    content?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type contentsCreateManyInput = {
    id?: number
    class_id: number
    content?: string | null
  }

  export type contentsUpdateManyMutationInput = {
    content?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type contentsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    class_id?: IntFieldUpdateOperationsInput | number
    content?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type instructorCreateInput = {
    name: string
    classes?: classesCreateNestedManyWithoutInstructorInput
  }

  export type instructorUncheckedCreateInput = {
    id?: number
    name: string
    classes?: classesUncheckedCreateNestedManyWithoutInstructorInput
  }

  export type instructorUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    classes?: classesUpdateManyWithoutInstructorNestedInput
  }

  export type instructorUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    classes?: classesUncheckedUpdateManyWithoutInstructorNestedInput
  }

  export type instructorCreateManyInput = {
    id?: number
    name: string
  }

  export type instructorUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type instructorUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type levelCreateInput = {
    level: string
    classes?: classesCreateNestedManyWithoutLevelInput
  }

  export type levelUncheckedCreateInput = {
    id?: number
    level: string
    classes?: classesUncheckedCreateNestedManyWithoutLevelInput
  }

  export type levelUpdateInput = {
    level?: StringFieldUpdateOperationsInput | string
    classes?: classesUpdateManyWithoutLevelNestedInput
  }

  export type levelUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    level?: StringFieldUpdateOperationsInput | string
    classes?: classesUncheckedUpdateManyWithoutLevelNestedInput
  }

  export type levelCreateManyInput = {
    id?: number
    level: string
  }

  export type levelUpdateManyMutationInput = {
    level?: StringFieldUpdateOperationsInput | string
  }

  export type levelUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    level?: StringFieldUpdateOperationsInput | string
  }

  export type my_classesCreateInput = {
    progress?: number
    classes: classesCreateNestedOneWithoutMy_classesInput
    users: usersCreateNestedOneWithoutMy_classesInput
  }

  export type my_classesUncheckedCreateInput = {
    id?: number
    user_id: number
    class_id: number
    progress?: number
  }

  export type my_classesUpdateInput = {
    progress?: IntFieldUpdateOperationsInput | number
    classes?: classesUpdateOneRequiredWithoutMy_classesNestedInput
    users?: usersUpdateOneRequiredWithoutMy_classesNestedInput
  }

  export type my_classesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    class_id?: IntFieldUpdateOperationsInput | number
    progress?: IntFieldUpdateOperationsInput | number
  }

  export type my_classesCreateManyInput = {
    id?: number
    user_id: number
    class_id: number
    progress?: number
  }

  export type my_classesUpdateManyMutationInput = {
    progress?: IntFieldUpdateOperationsInput | number
  }

  export type my_classesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    class_id?: IntFieldUpdateOperationsInput | number
    progress?: IntFieldUpdateOperationsInput | number
  }

  export type price_scopeCreateInput = {
    scope?: string | null
    classes?: classesCreateNestedManyWithoutPrice_scope_classesToprice_scopeInput
  }

  export type price_scopeUncheckedCreateInput = {
    id?: number
    scope?: string | null
    classes?: classesUncheckedCreateNestedManyWithoutPrice_scope_classesToprice_scopeInput
  }

  export type price_scopeUpdateInput = {
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    classes?: classesUpdateManyWithoutPrice_scope_classesToprice_scopeNestedInput
  }

  export type price_scopeUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    classes?: classesUncheckedUpdateManyWithoutPrice_scope_classesToprice_scopeNestedInput
  }

  export type price_scopeCreateManyInput = {
    id?: number
    scope?: string | null
  }

  export type price_scopeUpdateManyMutationInput = {
    scope?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type price_scopeUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    scope?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type reviewCreateInput = {
    rate: number
    classes: classesCreateNestedOneWithoutReviewInput
    users: usersCreateNestedOneWithoutReviewInput
  }

  export type reviewUncheckedCreateInput = {
    id?: number
    user_id: number
    rate: number
    class_id: number
  }

  export type reviewUpdateInput = {
    rate?: FloatFieldUpdateOperationsInput | number
    classes?: classesUpdateOneRequiredWithoutReviewNestedInput
    users?: usersUpdateOneRequiredWithoutReviewNestedInput
  }

  export type reviewUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    rate?: FloatFieldUpdateOperationsInput | number
    class_id?: IntFieldUpdateOperationsInput | number
  }

  export type reviewCreateManyInput = {
    id?: number
    user_id: number
    rate: number
    class_id: number
  }

  export type reviewUpdateManyMutationInput = {
    rate?: FloatFieldUpdateOperationsInput | number
  }

  export type reviewUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    rate?: FloatFieldUpdateOperationsInput | number
    class_id?: IntFieldUpdateOperationsInput | number
  }

  export type wishlistCreateInput = {
    classes: classesCreateNestedOneWithoutWishlistInput
    users: usersCreateNestedOneWithoutWishlistInput
  }

  export type wishlistUncheckedCreateInput = {
    id?: number
    user_id: number
    class_id: number
  }

  export type wishlistUpdateInput = {
    classes?: classesUpdateOneRequiredWithoutWishlistNestedInput
    users?: usersUpdateOneRequiredWithoutWishlistNestedInput
  }

  export type wishlistUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    class_id?: IntFieldUpdateOperationsInput | number
  }

  export type wishlistCreateManyInput = {
    id?: number
    user_id: number
    class_id: number
  }

  export type wishlistUpdateManyMutationInput = {

  }

  export type wishlistUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    class_id?: IntFieldUpdateOperationsInput | number
  }

  export type IntFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type StringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableFilter | string | null
  }

  export type StringFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringFilter | string
  }

  export type DateTimeNullableFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableFilter | Date | string | null
  }

  export type My_classesListRelationFilter = {
    every?: my_classesWhereInput
    some?: my_classesWhereInput
    none?: my_classesWhereInput
  }

  export type ReviewListRelationFilter = {
    every?: reviewWhereInput
    some?: reviewWhereInput
    none?: reviewWhereInput
  }

  export type WishlistListRelationFilter = {
    every?: wishlistWhereInput
    some?: wishlistWhereInput
    none?: wishlistWhereInput
  }

  export type my_classesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type reviewOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type wishlistOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type usersCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    img?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type usersAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type usersMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    img?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type usersMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    img?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type usersSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    _min?: NestedIntFilter
    _max?: NestedIntFilter
  }

  export type StringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
  }

  export type StringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type DateTimeNullableWithAggregatesFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableWithAggregatesFilter | Date | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedDateTimeNullableFilter
    _max?: NestedDateTimeNullableFilter
  }

  export type IntNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
  }

  export type ClassesListRelationFilter = {
    every?: classesWhereInput
    some?: classesWhereInput
    none?: classesWhereInput
  }

  export type classesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type categoryCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    depth?: SortOrder
    parent_id?: SortOrder
  }

  export type categoryAvgOrderByAggregateInput = {
    id?: SortOrder
    depth?: SortOrder
    parent_id?: SortOrder
  }

  export type categoryMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    depth?: SortOrder
    parent_id?: SortOrder
  }

  export type categoryMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    depth?: SortOrder
    parent_id?: SortOrder
  }

  export type categorySumOrderByAggregateInput = {
    id?: SortOrder
    depth?: SortOrder
    parent_id?: SortOrder
  }

  export type IntNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedIntNullableFilter
    _min?: NestedIntNullableFilter
    _max?: NestedIntNullableFilter
  }

  export type ClassesRelationFilter = {
    is?: classesWhereInput
    isNot?: classesWhereInput
  }

  export type class_imgCountOrderByAggregateInput = {
    id?: SortOrder
    url?: SortOrder
    class_id?: SortOrder
  }

  export type class_imgAvgOrderByAggregateInput = {
    id?: SortOrder
    class_id?: SortOrder
  }

  export type class_imgMaxOrderByAggregateInput = {
    id?: SortOrder
    url?: SortOrder
    class_id?: SortOrder
  }

  export type class_imgMinOrderByAggregateInput = {
    id?: SortOrder
    url?: SortOrder
    class_id?: SortOrder
  }

  export type class_imgSumOrderByAggregateInput = {
    id?: SortOrder
    class_id?: SortOrder
  }

  export type FloatNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatNullableFilter | number | null
  }

  export type CategoryRelationFilter = {
    is?: categoryWhereInput | null
    isNot?: categoryWhereInput | null
  }

  export type InstructorRelationFilter = {
    is?: instructorWhereInput
    isNot?: instructorWhereInput
  }

  export type LevelRelationFilter = {
    is?: levelWhereInput | null
    isNot?: levelWhereInput | null
  }

  export type Price_scopeRelationFilter = {
    is?: price_scopeWhereInput | null
    isNot?: price_scopeWhereInput | null
  }

  export type Class_imgListRelationFilter = {
    every?: class_imgWhereInput
    some?: class_imgWhereInput
    none?: class_imgWhereInput
  }

  export type ContentsListRelationFilter = {
    every?: contentsWhereInput
    some?: contentsWhereInput
    none?: contentsWhereInput
  }

  export type class_imgOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type contentsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type classesCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    instructor_id?: SortOrder
    price?: SortOrder
    img?: SortOrder
    rate?: SortOrder
    description?: SortOrder
    students?: SortOrder
    sessions?: SortOrder
    price_scope?: SortOrder
    category1_id?: SortOrder
    category2_id?: SortOrder
    category3_id?: SortOrder
    level_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type classesAvgOrderByAggregateInput = {
    id?: SortOrder
    instructor_id?: SortOrder
    price?: SortOrder
    rate?: SortOrder
    students?: SortOrder
    sessions?: SortOrder
    price_scope?: SortOrder
    category1_id?: SortOrder
    category2_id?: SortOrder
    category3_id?: SortOrder
    level_id?: SortOrder
  }

  export type classesMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    instructor_id?: SortOrder
    price?: SortOrder
    img?: SortOrder
    rate?: SortOrder
    description?: SortOrder
    students?: SortOrder
    sessions?: SortOrder
    price_scope?: SortOrder
    category1_id?: SortOrder
    category2_id?: SortOrder
    category3_id?: SortOrder
    level_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type classesMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    instructor_id?: SortOrder
    price?: SortOrder
    img?: SortOrder
    rate?: SortOrder
    description?: SortOrder
    students?: SortOrder
    sessions?: SortOrder
    price_scope?: SortOrder
    category1_id?: SortOrder
    category2_id?: SortOrder
    category3_id?: SortOrder
    level_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type classesSumOrderByAggregateInput = {
    id?: SortOrder
    instructor_id?: SortOrder
    price?: SortOrder
    rate?: SortOrder
    students?: SortOrder
    sessions?: SortOrder
    price_scope?: SortOrder
    category1_id?: SortOrder
    category2_id?: SortOrder
    category3_id?: SortOrder
    level_id?: SortOrder
  }

  export type FloatNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedFloatNullableFilter
    _min?: NestedFloatNullableFilter
    _max?: NestedFloatNullableFilter
  }

  export type contentsCountOrderByAggregateInput = {
    id?: SortOrder
    class_id?: SortOrder
    content?: SortOrder
  }

  export type contentsAvgOrderByAggregateInput = {
    id?: SortOrder
    class_id?: SortOrder
  }

  export type contentsMaxOrderByAggregateInput = {
    id?: SortOrder
    class_id?: SortOrder
    content?: SortOrder
  }

  export type contentsMinOrderByAggregateInput = {
    id?: SortOrder
    class_id?: SortOrder
    content?: SortOrder
  }

  export type contentsSumOrderByAggregateInput = {
    id?: SortOrder
    class_id?: SortOrder
  }

  export type instructorCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type instructorAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type instructorMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type instructorMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type instructorSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type levelCountOrderByAggregateInput = {
    id?: SortOrder
    level?: SortOrder
  }

  export type levelAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type levelMaxOrderByAggregateInput = {
    id?: SortOrder
    level?: SortOrder
  }

  export type levelMinOrderByAggregateInput = {
    id?: SortOrder
    level?: SortOrder
  }

  export type levelSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type UsersRelationFilter = {
    is?: usersWhereInput
    isNot?: usersWhereInput
  }

  export type my_classesCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    class_id?: SortOrder
    progress?: SortOrder
  }

  export type my_classesAvgOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    class_id?: SortOrder
    progress?: SortOrder
  }

  export type my_classesMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    class_id?: SortOrder
    progress?: SortOrder
  }

  export type my_classesMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    class_id?: SortOrder
    progress?: SortOrder
  }

  export type my_classesSumOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    class_id?: SortOrder
    progress?: SortOrder
  }

  export type price_scopeCountOrderByAggregateInput = {
    id?: SortOrder
    scope?: SortOrder
  }

  export type price_scopeAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type price_scopeMaxOrderByAggregateInput = {
    id?: SortOrder
    scope?: SortOrder
  }

  export type price_scopeMinOrderByAggregateInput = {
    id?: SortOrder
    scope?: SortOrder
  }

  export type price_scopeSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type FloatFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatFilter | number
  }

  export type reviewCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    rate?: SortOrder
    class_id?: SortOrder
  }

  export type reviewAvgOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    rate?: SortOrder
    class_id?: SortOrder
  }

  export type reviewMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    rate?: SortOrder
    class_id?: SortOrder
  }

  export type reviewMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    rate?: SortOrder
    class_id?: SortOrder
  }

  export type reviewSumOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    rate?: SortOrder
    class_id?: SortOrder
  }

  export type FloatWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedFloatFilter
    _min?: NestedFloatFilter
    _max?: NestedFloatFilter
  }

  export type wishlistCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    class_id?: SortOrder
  }

  export type wishlistAvgOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    class_id?: SortOrder
  }

  export type wishlistMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    class_id?: SortOrder
  }

  export type wishlistMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    class_id?: SortOrder
  }

  export type wishlistSumOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    class_id?: SortOrder
  }

  export type my_classesCreateNestedManyWithoutUsersInput = {
    create?: XOR<Enumerable<my_classesCreateWithoutUsersInput>, Enumerable<my_classesUncheckedCreateWithoutUsersInput>>
    connectOrCreate?: Enumerable<my_classesCreateOrConnectWithoutUsersInput>
    createMany?: my_classesCreateManyUsersInputEnvelope
    connect?: Enumerable<my_classesWhereUniqueInput>
  }

  export type reviewCreateNestedManyWithoutUsersInput = {
    create?: XOR<Enumerable<reviewCreateWithoutUsersInput>, Enumerable<reviewUncheckedCreateWithoutUsersInput>>
    connectOrCreate?: Enumerable<reviewCreateOrConnectWithoutUsersInput>
    createMany?: reviewCreateManyUsersInputEnvelope
    connect?: Enumerable<reviewWhereUniqueInput>
  }

  export type wishlistCreateNestedManyWithoutUsersInput = {
    create?: XOR<Enumerable<wishlistCreateWithoutUsersInput>, Enumerable<wishlistUncheckedCreateWithoutUsersInput>>
    connectOrCreate?: Enumerable<wishlistCreateOrConnectWithoutUsersInput>
    createMany?: wishlistCreateManyUsersInputEnvelope
    connect?: Enumerable<wishlistWhereUniqueInput>
  }

  export type my_classesUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<Enumerable<my_classesCreateWithoutUsersInput>, Enumerable<my_classesUncheckedCreateWithoutUsersInput>>
    connectOrCreate?: Enumerable<my_classesCreateOrConnectWithoutUsersInput>
    createMany?: my_classesCreateManyUsersInputEnvelope
    connect?: Enumerable<my_classesWhereUniqueInput>
  }

  export type reviewUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<Enumerable<reviewCreateWithoutUsersInput>, Enumerable<reviewUncheckedCreateWithoutUsersInput>>
    connectOrCreate?: Enumerable<reviewCreateOrConnectWithoutUsersInput>
    createMany?: reviewCreateManyUsersInputEnvelope
    connect?: Enumerable<reviewWhereUniqueInput>
  }

  export type wishlistUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<Enumerable<wishlistCreateWithoutUsersInput>, Enumerable<wishlistUncheckedCreateWithoutUsersInput>>
    connectOrCreate?: Enumerable<wishlistCreateOrConnectWithoutUsersInput>
    createMany?: wishlistCreateManyUsersInputEnvelope
    connect?: Enumerable<wishlistWhereUniqueInput>
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type my_classesUpdateManyWithoutUsersNestedInput = {
    create?: XOR<Enumerable<my_classesCreateWithoutUsersInput>, Enumerable<my_classesUncheckedCreateWithoutUsersInput>>
    connectOrCreate?: Enumerable<my_classesCreateOrConnectWithoutUsersInput>
    upsert?: Enumerable<my_classesUpsertWithWhereUniqueWithoutUsersInput>
    createMany?: my_classesCreateManyUsersInputEnvelope
    set?: Enumerable<my_classesWhereUniqueInput>
    disconnect?: Enumerable<my_classesWhereUniqueInput>
    delete?: Enumerable<my_classesWhereUniqueInput>
    connect?: Enumerable<my_classesWhereUniqueInput>
    update?: Enumerable<my_classesUpdateWithWhereUniqueWithoutUsersInput>
    updateMany?: Enumerable<my_classesUpdateManyWithWhereWithoutUsersInput>
    deleteMany?: Enumerable<my_classesScalarWhereInput>
  }

  export type reviewUpdateManyWithoutUsersNestedInput = {
    create?: XOR<Enumerable<reviewCreateWithoutUsersInput>, Enumerable<reviewUncheckedCreateWithoutUsersInput>>
    connectOrCreate?: Enumerable<reviewCreateOrConnectWithoutUsersInput>
    upsert?: Enumerable<reviewUpsertWithWhereUniqueWithoutUsersInput>
    createMany?: reviewCreateManyUsersInputEnvelope
    set?: Enumerable<reviewWhereUniqueInput>
    disconnect?: Enumerable<reviewWhereUniqueInput>
    delete?: Enumerable<reviewWhereUniqueInput>
    connect?: Enumerable<reviewWhereUniqueInput>
    update?: Enumerable<reviewUpdateWithWhereUniqueWithoutUsersInput>
    updateMany?: Enumerable<reviewUpdateManyWithWhereWithoutUsersInput>
    deleteMany?: Enumerable<reviewScalarWhereInput>
  }

  export type wishlistUpdateManyWithoutUsersNestedInput = {
    create?: XOR<Enumerable<wishlistCreateWithoutUsersInput>, Enumerable<wishlistUncheckedCreateWithoutUsersInput>>
    connectOrCreate?: Enumerable<wishlistCreateOrConnectWithoutUsersInput>
    upsert?: Enumerable<wishlistUpsertWithWhereUniqueWithoutUsersInput>
    createMany?: wishlistCreateManyUsersInputEnvelope
    set?: Enumerable<wishlistWhereUniqueInput>
    disconnect?: Enumerable<wishlistWhereUniqueInput>
    delete?: Enumerable<wishlistWhereUniqueInput>
    connect?: Enumerable<wishlistWhereUniqueInput>
    update?: Enumerable<wishlistUpdateWithWhereUniqueWithoutUsersInput>
    updateMany?: Enumerable<wishlistUpdateManyWithWhereWithoutUsersInput>
    deleteMany?: Enumerable<wishlistScalarWhereInput>
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type my_classesUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<Enumerable<my_classesCreateWithoutUsersInput>, Enumerable<my_classesUncheckedCreateWithoutUsersInput>>
    connectOrCreate?: Enumerable<my_classesCreateOrConnectWithoutUsersInput>
    upsert?: Enumerable<my_classesUpsertWithWhereUniqueWithoutUsersInput>
    createMany?: my_classesCreateManyUsersInputEnvelope
    set?: Enumerable<my_classesWhereUniqueInput>
    disconnect?: Enumerable<my_classesWhereUniqueInput>
    delete?: Enumerable<my_classesWhereUniqueInput>
    connect?: Enumerable<my_classesWhereUniqueInput>
    update?: Enumerable<my_classesUpdateWithWhereUniqueWithoutUsersInput>
    updateMany?: Enumerable<my_classesUpdateManyWithWhereWithoutUsersInput>
    deleteMany?: Enumerable<my_classesScalarWhereInput>
  }

  export type reviewUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<Enumerable<reviewCreateWithoutUsersInput>, Enumerable<reviewUncheckedCreateWithoutUsersInput>>
    connectOrCreate?: Enumerable<reviewCreateOrConnectWithoutUsersInput>
    upsert?: Enumerable<reviewUpsertWithWhereUniqueWithoutUsersInput>
    createMany?: reviewCreateManyUsersInputEnvelope
    set?: Enumerable<reviewWhereUniqueInput>
    disconnect?: Enumerable<reviewWhereUniqueInput>
    delete?: Enumerable<reviewWhereUniqueInput>
    connect?: Enumerable<reviewWhereUniqueInput>
    update?: Enumerable<reviewUpdateWithWhereUniqueWithoutUsersInput>
    updateMany?: Enumerable<reviewUpdateManyWithWhereWithoutUsersInput>
    deleteMany?: Enumerable<reviewScalarWhereInput>
  }

  export type wishlistUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<Enumerable<wishlistCreateWithoutUsersInput>, Enumerable<wishlistUncheckedCreateWithoutUsersInput>>
    connectOrCreate?: Enumerable<wishlistCreateOrConnectWithoutUsersInput>
    upsert?: Enumerable<wishlistUpsertWithWhereUniqueWithoutUsersInput>
    createMany?: wishlistCreateManyUsersInputEnvelope
    set?: Enumerable<wishlistWhereUniqueInput>
    disconnect?: Enumerable<wishlistWhereUniqueInput>
    delete?: Enumerable<wishlistWhereUniqueInput>
    connect?: Enumerable<wishlistWhereUniqueInput>
    update?: Enumerable<wishlistUpdateWithWhereUniqueWithoutUsersInput>
    updateMany?: Enumerable<wishlistUpdateManyWithWhereWithoutUsersInput>
    deleteMany?: Enumerable<wishlistScalarWhereInput>
  }

  export type classesCreateNestedManyWithoutCategory_categoryToclasses_category1_idInput = {
    create?: XOR<Enumerable<classesCreateWithoutCategory_categoryToclasses_category1_idInput>, Enumerable<classesUncheckedCreateWithoutCategory_categoryToclasses_category1_idInput>>
    connectOrCreate?: Enumerable<classesCreateOrConnectWithoutCategory_categoryToclasses_category1_idInput>
    createMany?: classesCreateManyCategory_categoryToclasses_category1_idInputEnvelope
    connect?: Enumerable<classesWhereUniqueInput>
  }

  export type classesCreateNestedManyWithoutCategory_categoryToclasses_category2_idInput = {
    create?: XOR<Enumerable<classesCreateWithoutCategory_categoryToclasses_category2_idInput>, Enumerable<classesUncheckedCreateWithoutCategory_categoryToclasses_category2_idInput>>
    connectOrCreate?: Enumerable<classesCreateOrConnectWithoutCategory_categoryToclasses_category2_idInput>
    createMany?: classesCreateManyCategory_categoryToclasses_category2_idInputEnvelope
    connect?: Enumerable<classesWhereUniqueInput>
  }

  export type classesCreateNestedManyWithoutCategory_categoryToclasses_category3_idInput = {
    create?: XOR<Enumerable<classesCreateWithoutCategory_categoryToclasses_category3_idInput>, Enumerable<classesUncheckedCreateWithoutCategory_categoryToclasses_category3_idInput>>
    connectOrCreate?: Enumerable<classesCreateOrConnectWithoutCategory_categoryToclasses_category3_idInput>
    createMany?: classesCreateManyCategory_categoryToclasses_category3_idInputEnvelope
    connect?: Enumerable<classesWhereUniqueInput>
  }

  export type classesUncheckedCreateNestedManyWithoutCategory_categoryToclasses_category1_idInput = {
    create?: XOR<Enumerable<classesCreateWithoutCategory_categoryToclasses_category1_idInput>, Enumerable<classesUncheckedCreateWithoutCategory_categoryToclasses_category1_idInput>>
    connectOrCreate?: Enumerable<classesCreateOrConnectWithoutCategory_categoryToclasses_category1_idInput>
    createMany?: classesCreateManyCategory_categoryToclasses_category1_idInputEnvelope
    connect?: Enumerable<classesWhereUniqueInput>
  }

  export type classesUncheckedCreateNestedManyWithoutCategory_categoryToclasses_category2_idInput = {
    create?: XOR<Enumerable<classesCreateWithoutCategory_categoryToclasses_category2_idInput>, Enumerable<classesUncheckedCreateWithoutCategory_categoryToclasses_category2_idInput>>
    connectOrCreate?: Enumerable<classesCreateOrConnectWithoutCategory_categoryToclasses_category2_idInput>
    createMany?: classesCreateManyCategory_categoryToclasses_category2_idInputEnvelope
    connect?: Enumerable<classesWhereUniqueInput>
  }

  export type classesUncheckedCreateNestedManyWithoutCategory_categoryToclasses_category3_idInput = {
    create?: XOR<Enumerable<classesCreateWithoutCategory_categoryToclasses_category3_idInput>, Enumerable<classesUncheckedCreateWithoutCategory_categoryToclasses_category3_idInput>>
    connectOrCreate?: Enumerable<classesCreateOrConnectWithoutCategory_categoryToclasses_category3_idInput>
    createMany?: classesCreateManyCategory_categoryToclasses_category3_idInputEnvelope
    connect?: Enumerable<classesWhereUniqueInput>
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type classesUpdateManyWithoutCategory_categoryToclasses_category1_idNestedInput = {
    create?: XOR<Enumerable<classesCreateWithoutCategory_categoryToclasses_category1_idInput>, Enumerable<classesUncheckedCreateWithoutCategory_categoryToclasses_category1_idInput>>
    connectOrCreate?: Enumerable<classesCreateOrConnectWithoutCategory_categoryToclasses_category1_idInput>
    upsert?: Enumerable<classesUpsertWithWhereUniqueWithoutCategory_categoryToclasses_category1_idInput>
    createMany?: classesCreateManyCategory_categoryToclasses_category1_idInputEnvelope
    set?: Enumerable<classesWhereUniqueInput>
    disconnect?: Enumerable<classesWhereUniqueInput>
    delete?: Enumerable<classesWhereUniqueInput>
    connect?: Enumerable<classesWhereUniqueInput>
    update?: Enumerable<classesUpdateWithWhereUniqueWithoutCategory_categoryToclasses_category1_idInput>
    updateMany?: Enumerable<classesUpdateManyWithWhereWithoutCategory_categoryToclasses_category1_idInput>
    deleteMany?: Enumerable<classesScalarWhereInput>
  }

  export type classesUpdateManyWithoutCategory_categoryToclasses_category2_idNestedInput = {
    create?: XOR<Enumerable<classesCreateWithoutCategory_categoryToclasses_category2_idInput>, Enumerable<classesUncheckedCreateWithoutCategory_categoryToclasses_category2_idInput>>
    connectOrCreate?: Enumerable<classesCreateOrConnectWithoutCategory_categoryToclasses_category2_idInput>
    upsert?: Enumerable<classesUpsertWithWhereUniqueWithoutCategory_categoryToclasses_category2_idInput>
    createMany?: classesCreateManyCategory_categoryToclasses_category2_idInputEnvelope
    set?: Enumerable<classesWhereUniqueInput>
    disconnect?: Enumerable<classesWhereUniqueInput>
    delete?: Enumerable<classesWhereUniqueInput>
    connect?: Enumerable<classesWhereUniqueInput>
    update?: Enumerable<classesUpdateWithWhereUniqueWithoutCategory_categoryToclasses_category2_idInput>
    updateMany?: Enumerable<classesUpdateManyWithWhereWithoutCategory_categoryToclasses_category2_idInput>
    deleteMany?: Enumerable<classesScalarWhereInput>
  }

  export type classesUpdateManyWithoutCategory_categoryToclasses_category3_idNestedInput = {
    create?: XOR<Enumerable<classesCreateWithoutCategory_categoryToclasses_category3_idInput>, Enumerable<classesUncheckedCreateWithoutCategory_categoryToclasses_category3_idInput>>
    connectOrCreate?: Enumerable<classesCreateOrConnectWithoutCategory_categoryToclasses_category3_idInput>
    upsert?: Enumerable<classesUpsertWithWhereUniqueWithoutCategory_categoryToclasses_category3_idInput>
    createMany?: classesCreateManyCategory_categoryToclasses_category3_idInputEnvelope
    set?: Enumerable<classesWhereUniqueInput>
    disconnect?: Enumerable<classesWhereUniqueInput>
    delete?: Enumerable<classesWhereUniqueInput>
    connect?: Enumerable<classesWhereUniqueInput>
    update?: Enumerable<classesUpdateWithWhereUniqueWithoutCategory_categoryToclasses_category3_idInput>
    updateMany?: Enumerable<classesUpdateManyWithWhereWithoutCategory_categoryToclasses_category3_idInput>
    deleteMany?: Enumerable<classesScalarWhereInput>
  }

  export type classesUncheckedUpdateManyWithoutCategory_categoryToclasses_category1_idNestedInput = {
    create?: XOR<Enumerable<classesCreateWithoutCategory_categoryToclasses_category1_idInput>, Enumerable<classesUncheckedCreateWithoutCategory_categoryToclasses_category1_idInput>>
    connectOrCreate?: Enumerable<classesCreateOrConnectWithoutCategory_categoryToclasses_category1_idInput>
    upsert?: Enumerable<classesUpsertWithWhereUniqueWithoutCategory_categoryToclasses_category1_idInput>
    createMany?: classesCreateManyCategory_categoryToclasses_category1_idInputEnvelope
    set?: Enumerable<classesWhereUniqueInput>
    disconnect?: Enumerable<classesWhereUniqueInput>
    delete?: Enumerable<classesWhereUniqueInput>
    connect?: Enumerable<classesWhereUniqueInput>
    update?: Enumerable<classesUpdateWithWhereUniqueWithoutCategory_categoryToclasses_category1_idInput>
    updateMany?: Enumerable<classesUpdateManyWithWhereWithoutCategory_categoryToclasses_category1_idInput>
    deleteMany?: Enumerable<classesScalarWhereInput>
  }

  export type classesUncheckedUpdateManyWithoutCategory_categoryToclasses_category2_idNestedInput = {
    create?: XOR<Enumerable<classesCreateWithoutCategory_categoryToclasses_category2_idInput>, Enumerable<classesUncheckedCreateWithoutCategory_categoryToclasses_category2_idInput>>
    connectOrCreate?: Enumerable<classesCreateOrConnectWithoutCategory_categoryToclasses_category2_idInput>
    upsert?: Enumerable<classesUpsertWithWhereUniqueWithoutCategory_categoryToclasses_category2_idInput>
    createMany?: classesCreateManyCategory_categoryToclasses_category2_idInputEnvelope
    set?: Enumerable<classesWhereUniqueInput>
    disconnect?: Enumerable<classesWhereUniqueInput>
    delete?: Enumerable<classesWhereUniqueInput>
    connect?: Enumerable<classesWhereUniqueInput>
    update?: Enumerable<classesUpdateWithWhereUniqueWithoutCategory_categoryToclasses_category2_idInput>
    updateMany?: Enumerable<classesUpdateManyWithWhereWithoutCategory_categoryToclasses_category2_idInput>
    deleteMany?: Enumerable<classesScalarWhereInput>
  }

  export type classesUncheckedUpdateManyWithoutCategory_categoryToclasses_category3_idNestedInput = {
    create?: XOR<Enumerable<classesCreateWithoutCategory_categoryToclasses_category3_idInput>, Enumerable<classesUncheckedCreateWithoutCategory_categoryToclasses_category3_idInput>>
    connectOrCreate?: Enumerable<classesCreateOrConnectWithoutCategory_categoryToclasses_category3_idInput>
    upsert?: Enumerable<classesUpsertWithWhereUniqueWithoutCategory_categoryToclasses_category3_idInput>
    createMany?: classesCreateManyCategory_categoryToclasses_category3_idInputEnvelope
    set?: Enumerable<classesWhereUniqueInput>
    disconnect?: Enumerable<classesWhereUniqueInput>
    delete?: Enumerable<classesWhereUniqueInput>
    connect?: Enumerable<classesWhereUniqueInput>
    update?: Enumerable<classesUpdateWithWhereUniqueWithoutCategory_categoryToclasses_category3_idInput>
    updateMany?: Enumerable<classesUpdateManyWithWhereWithoutCategory_categoryToclasses_category3_idInput>
    deleteMany?: Enumerable<classesScalarWhereInput>
  }

  export type classesCreateNestedOneWithoutClass_imgInput = {
    create?: XOR<classesCreateWithoutClass_imgInput, classesUncheckedCreateWithoutClass_imgInput>
    connectOrCreate?: classesCreateOrConnectWithoutClass_imgInput
    connect?: classesWhereUniqueInput
  }

  export type classesUpdateOneRequiredWithoutClass_imgNestedInput = {
    create?: XOR<classesCreateWithoutClass_imgInput, classesUncheckedCreateWithoutClass_imgInput>
    connectOrCreate?: classesCreateOrConnectWithoutClass_imgInput
    upsert?: classesUpsertWithoutClass_imgInput
    connect?: classesWhereUniqueInput
    update?: XOR<classesUpdateWithoutClass_imgInput, classesUncheckedUpdateWithoutClass_imgInput>
  }

  export type categoryCreateNestedOneWithoutClasses_categoryToclasses_category1_idInput = {
    create?: XOR<categoryCreateWithoutClasses_categoryToclasses_category1_idInput, categoryUncheckedCreateWithoutClasses_categoryToclasses_category1_idInput>
    connectOrCreate?: categoryCreateOrConnectWithoutClasses_categoryToclasses_category1_idInput
    connect?: categoryWhereUniqueInput
  }

  export type categoryCreateNestedOneWithoutClasses_categoryToclasses_category2_idInput = {
    create?: XOR<categoryCreateWithoutClasses_categoryToclasses_category2_idInput, categoryUncheckedCreateWithoutClasses_categoryToclasses_category2_idInput>
    connectOrCreate?: categoryCreateOrConnectWithoutClasses_categoryToclasses_category2_idInput
    connect?: categoryWhereUniqueInput
  }

  export type categoryCreateNestedOneWithoutClasses_categoryToclasses_category3_idInput = {
    create?: XOR<categoryCreateWithoutClasses_categoryToclasses_category3_idInput, categoryUncheckedCreateWithoutClasses_categoryToclasses_category3_idInput>
    connectOrCreate?: categoryCreateOrConnectWithoutClasses_categoryToclasses_category3_idInput
    connect?: categoryWhereUniqueInput
  }

  export type instructorCreateNestedOneWithoutClassesInput = {
    create?: XOR<instructorCreateWithoutClassesInput, instructorUncheckedCreateWithoutClassesInput>
    connectOrCreate?: instructorCreateOrConnectWithoutClassesInput
    connect?: instructorWhereUniqueInput
  }

  export type levelCreateNestedOneWithoutClassesInput = {
    create?: XOR<levelCreateWithoutClassesInput, levelUncheckedCreateWithoutClassesInput>
    connectOrCreate?: levelCreateOrConnectWithoutClassesInput
    connect?: levelWhereUniqueInput
  }

  export type price_scopeCreateNestedOneWithoutClassesInput = {
    create?: XOR<price_scopeCreateWithoutClassesInput, price_scopeUncheckedCreateWithoutClassesInput>
    connectOrCreate?: price_scopeCreateOrConnectWithoutClassesInput
    connect?: price_scopeWhereUniqueInput
  }

  export type class_imgCreateNestedManyWithoutClassesInput = {
    create?: XOR<Enumerable<class_imgCreateWithoutClassesInput>, Enumerable<class_imgUncheckedCreateWithoutClassesInput>>
    connectOrCreate?: Enumerable<class_imgCreateOrConnectWithoutClassesInput>
    createMany?: class_imgCreateManyClassesInputEnvelope
    connect?: Enumerable<class_imgWhereUniqueInput>
  }

  export type contentsCreateNestedManyWithoutClassesInput = {
    create?: XOR<Enumerable<contentsCreateWithoutClassesInput>, Enumerable<contentsUncheckedCreateWithoutClassesInput>>
    connectOrCreate?: Enumerable<contentsCreateOrConnectWithoutClassesInput>
    createMany?: contentsCreateManyClassesInputEnvelope
    connect?: Enumerable<contentsWhereUniqueInput>
  }

  export type my_classesCreateNestedManyWithoutClassesInput = {
    create?: XOR<Enumerable<my_classesCreateWithoutClassesInput>, Enumerable<my_classesUncheckedCreateWithoutClassesInput>>
    connectOrCreate?: Enumerable<my_classesCreateOrConnectWithoutClassesInput>
    createMany?: my_classesCreateManyClassesInputEnvelope
    connect?: Enumerable<my_classesWhereUniqueInput>
  }

  export type reviewCreateNestedManyWithoutClassesInput = {
    create?: XOR<Enumerable<reviewCreateWithoutClassesInput>, Enumerable<reviewUncheckedCreateWithoutClassesInput>>
    connectOrCreate?: Enumerable<reviewCreateOrConnectWithoutClassesInput>
    createMany?: reviewCreateManyClassesInputEnvelope
    connect?: Enumerable<reviewWhereUniqueInput>
  }

  export type wishlistCreateNestedManyWithoutClassesInput = {
    create?: XOR<Enumerable<wishlistCreateWithoutClassesInput>, Enumerable<wishlistUncheckedCreateWithoutClassesInput>>
    connectOrCreate?: Enumerable<wishlistCreateOrConnectWithoutClassesInput>
    createMany?: wishlistCreateManyClassesInputEnvelope
    connect?: Enumerable<wishlistWhereUniqueInput>
  }

  export type class_imgUncheckedCreateNestedManyWithoutClassesInput = {
    create?: XOR<Enumerable<class_imgCreateWithoutClassesInput>, Enumerable<class_imgUncheckedCreateWithoutClassesInput>>
    connectOrCreate?: Enumerable<class_imgCreateOrConnectWithoutClassesInput>
    createMany?: class_imgCreateManyClassesInputEnvelope
    connect?: Enumerable<class_imgWhereUniqueInput>
  }

  export type contentsUncheckedCreateNestedManyWithoutClassesInput = {
    create?: XOR<Enumerable<contentsCreateWithoutClassesInput>, Enumerable<contentsUncheckedCreateWithoutClassesInput>>
    connectOrCreate?: Enumerable<contentsCreateOrConnectWithoutClassesInput>
    createMany?: contentsCreateManyClassesInputEnvelope
    connect?: Enumerable<contentsWhereUniqueInput>
  }

  export type my_classesUncheckedCreateNestedManyWithoutClassesInput = {
    create?: XOR<Enumerable<my_classesCreateWithoutClassesInput>, Enumerable<my_classesUncheckedCreateWithoutClassesInput>>
    connectOrCreate?: Enumerable<my_classesCreateOrConnectWithoutClassesInput>
    createMany?: my_classesCreateManyClassesInputEnvelope
    connect?: Enumerable<my_classesWhereUniqueInput>
  }

  export type reviewUncheckedCreateNestedManyWithoutClassesInput = {
    create?: XOR<Enumerable<reviewCreateWithoutClassesInput>, Enumerable<reviewUncheckedCreateWithoutClassesInput>>
    connectOrCreate?: Enumerable<reviewCreateOrConnectWithoutClassesInput>
    createMany?: reviewCreateManyClassesInputEnvelope
    connect?: Enumerable<reviewWhereUniqueInput>
  }

  export type wishlistUncheckedCreateNestedManyWithoutClassesInput = {
    create?: XOR<Enumerable<wishlistCreateWithoutClassesInput>, Enumerable<wishlistUncheckedCreateWithoutClassesInput>>
    connectOrCreate?: Enumerable<wishlistCreateOrConnectWithoutClassesInput>
    createMany?: wishlistCreateManyClassesInputEnvelope
    connect?: Enumerable<wishlistWhereUniqueInput>
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type categoryUpdateOneWithoutClasses_categoryToclasses_category1_idNestedInput = {
    create?: XOR<categoryCreateWithoutClasses_categoryToclasses_category1_idInput, categoryUncheckedCreateWithoutClasses_categoryToclasses_category1_idInput>
    connectOrCreate?: categoryCreateOrConnectWithoutClasses_categoryToclasses_category1_idInput
    upsert?: categoryUpsertWithoutClasses_categoryToclasses_category1_idInput
    disconnect?: boolean
    delete?: boolean
    connect?: categoryWhereUniqueInput
    update?: XOR<categoryUpdateWithoutClasses_categoryToclasses_category1_idInput, categoryUncheckedUpdateWithoutClasses_categoryToclasses_category1_idInput>
  }

  export type categoryUpdateOneWithoutClasses_categoryToclasses_category2_idNestedInput = {
    create?: XOR<categoryCreateWithoutClasses_categoryToclasses_category2_idInput, categoryUncheckedCreateWithoutClasses_categoryToclasses_category2_idInput>
    connectOrCreate?: categoryCreateOrConnectWithoutClasses_categoryToclasses_category2_idInput
    upsert?: categoryUpsertWithoutClasses_categoryToclasses_category2_idInput
    disconnect?: boolean
    delete?: boolean
    connect?: categoryWhereUniqueInput
    update?: XOR<categoryUpdateWithoutClasses_categoryToclasses_category2_idInput, categoryUncheckedUpdateWithoutClasses_categoryToclasses_category2_idInput>
  }

  export type categoryUpdateOneWithoutClasses_categoryToclasses_category3_idNestedInput = {
    create?: XOR<categoryCreateWithoutClasses_categoryToclasses_category3_idInput, categoryUncheckedCreateWithoutClasses_categoryToclasses_category3_idInput>
    connectOrCreate?: categoryCreateOrConnectWithoutClasses_categoryToclasses_category3_idInput
    upsert?: categoryUpsertWithoutClasses_categoryToclasses_category3_idInput
    disconnect?: boolean
    delete?: boolean
    connect?: categoryWhereUniqueInput
    update?: XOR<categoryUpdateWithoutClasses_categoryToclasses_category3_idInput, categoryUncheckedUpdateWithoutClasses_categoryToclasses_category3_idInput>
  }

  export type instructorUpdateOneRequiredWithoutClassesNestedInput = {
    create?: XOR<instructorCreateWithoutClassesInput, instructorUncheckedCreateWithoutClassesInput>
    connectOrCreate?: instructorCreateOrConnectWithoutClassesInput
    upsert?: instructorUpsertWithoutClassesInput
    connect?: instructorWhereUniqueInput
    update?: XOR<instructorUpdateWithoutClassesInput, instructorUncheckedUpdateWithoutClassesInput>
  }

  export type levelUpdateOneWithoutClassesNestedInput = {
    create?: XOR<levelCreateWithoutClassesInput, levelUncheckedCreateWithoutClassesInput>
    connectOrCreate?: levelCreateOrConnectWithoutClassesInput
    upsert?: levelUpsertWithoutClassesInput
    disconnect?: boolean
    delete?: boolean
    connect?: levelWhereUniqueInput
    update?: XOR<levelUpdateWithoutClassesInput, levelUncheckedUpdateWithoutClassesInput>
  }

  export type price_scopeUpdateOneWithoutClassesNestedInput = {
    create?: XOR<price_scopeCreateWithoutClassesInput, price_scopeUncheckedCreateWithoutClassesInput>
    connectOrCreate?: price_scopeCreateOrConnectWithoutClassesInput
    upsert?: price_scopeUpsertWithoutClassesInput
    disconnect?: boolean
    delete?: boolean
    connect?: price_scopeWhereUniqueInput
    update?: XOR<price_scopeUpdateWithoutClassesInput, price_scopeUncheckedUpdateWithoutClassesInput>
  }

  export type class_imgUpdateManyWithoutClassesNestedInput = {
    create?: XOR<Enumerable<class_imgCreateWithoutClassesInput>, Enumerable<class_imgUncheckedCreateWithoutClassesInput>>
    connectOrCreate?: Enumerable<class_imgCreateOrConnectWithoutClassesInput>
    upsert?: Enumerable<class_imgUpsertWithWhereUniqueWithoutClassesInput>
    createMany?: class_imgCreateManyClassesInputEnvelope
    set?: Enumerable<class_imgWhereUniqueInput>
    disconnect?: Enumerable<class_imgWhereUniqueInput>
    delete?: Enumerable<class_imgWhereUniqueInput>
    connect?: Enumerable<class_imgWhereUniqueInput>
    update?: Enumerable<class_imgUpdateWithWhereUniqueWithoutClassesInput>
    updateMany?: Enumerable<class_imgUpdateManyWithWhereWithoutClassesInput>
    deleteMany?: Enumerable<class_imgScalarWhereInput>
  }

  export type contentsUpdateManyWithoutClassesNestedInput = {
    create?: XOR<Enumerable<contentsCreateWithoutClassesInput>, Enumerable<contentsUncheckedCreateWithoutClassesInput>>
    connectOrCreate?: Enumerable<contentsCreateOrConnectWithoutClassesInput>
    upsert?: Enumerable<contentsUpsertWithWhereUniqueWithoutClassesInput>
    createMany?: contentsCreateManyClassesInputEnvelope
    set?: Enumerable<contentsWhereUniqueInput>
    disconnect?: Enumerable<contentsWhereUniqueInput>
    delete?: Enumerable<contentsWhereUniqueInput>
    connect?: Enumerable<contentsWhereUniqueInput>
    update?: Enumerable<contentsUpdateWithWhereUniqueWithoutClassesInput>
    updateMany?: Enumerable<contentsUpdateManyWithWhereWithoutClassesInput>
    deleteMany?: Enumerable<contentsScalarWhereInput>
  }

  export type my_classesUpdateManyWithoutClassesNestedInput = {
    create?: XOR<Enumerable<my_classesCreateWithoutClassesInput>, Enumerable<my_classesUncheckedCreateWithoutClassesInput>>
    connectOrCreate?: Enumerable<my_classesCreateOrConnectWithoutClassesInput>
    upsert?: Enumerable<my_classesUpsertWithWhereUniqueWithoutClassesInput>
    createMany?: my_classesCreateManyClassesInputEnvelope
    set?: Enumerable<my_classesWhereUniqueInput>
    disconnect?: Enumerable<my_classesWhereUniqueInput>
    delete?: Enumerable<my_classesWhereUniqueInput>
    connect?: Enumerable<my_classesWhereUniqueInput>
    update?: Enumerable<my_classesUpdateWithWhereUniqueWithoutClassesInput>
    updateMany?: Enumerable<my_classesUpdateManyWithWhereWithoutClassesInput>
    deleteMany?: Enumerable<my_classesScalarWhereInput>
  }

  export type reviewUpdateManyWithoutClassesNestedInput = {
    create?: XOR<Enumerable<reviewCreateWithoutClassesInput>, Enumerable<reviewUncheckedCreateWithoutClassesInput>>
    connectOrCreate?: Enumerable<reviewCreateOrConnectWithoutClassesInput>
    upsert?: Enumerable<reviewUpsertWithWhereUniqueWithoutClassesInput>
    createMany?: reviewCreateManyClassesInputEnvelope
    set?: Enumerable<reviewWhereUniqueInput>
    disconnect?: Enumerable<reviewWhereUniqueInput>
    delete?: Enumerable<reviewWhereUniqueInput>
    connect?: Enumerable<reviewWhereUniqueInput>
    update?: Enumerable<reviewUpdateWithWhereUniqueWithoutClassesInput>
    updateMany?: Enumerable<reviewUpdateManyWithWhereWithoutClassesInput>
    deleteMany?: Enumerable<reviewScalarWhereInput>
  }

  export type wishlistUpdateManyWithoutClassesNestedInput = {
    create?: XOR<Enumerable<wishlistCreateWithoutClassesInput>, Enumerable<wishlistUncheckedCreateWithoutClassesInput>>
    connectOrCreate?: Enumerable<wishlistCreateOrConnectWithoutClassesInput>
    upsert?: Enumerable<wishlistUpsertWithWhereUniqueWithoutClassesInput>
    createMany?: wishlistCreateManyClassesInputEnvelope
    set?: Enumerable<wishlistWhereUniqueInput>
    disconnect?: Enumerable<wishlistWhereUniqueInput>
    delete?: Enumerable<wishlistWhereUniqueInput>
    connect?: Enumerable<wishlistWhereUniqueInput>
    update?: Enumerable<wishlistUpdateWithWhereUniqueWithoutClassesInput>
    updateMany?: Enumerable<wishlistUpdateManyWithWhereWithoutClassesInput>
    deleteMany?: Enumerable<wishlistScalarWhereInput>
  }

  export type class_imgUncheckedUpdateManyWithoutClassesNestedInput = {
    create?: XOR<Enumerable<class_imgCreateWithoutClassesInput>, Enumerable<class_imgUncheckedCreateWithoutClassesInput>>
    connectOrCreate?: Enumerable<class_imgCreateOrConnectWithoutClassesInput>
    upsert?: Enumerable<class_imgUpsertWithWhereUniqueWithoutClassesInput>
    createMany?: class_imgCreateManyClassesInputEnvelope
    set?: Enumerable<class_imgWhereUniqueInput>
    disconnect?: Enumerable<class_imgWhereUniqueInput>
    delete?: Enumerable<class_imgWhereUniqueInput>
    connect?: Enumerable<class_imgWhereUniqueInput>
    update?: Enumerable<class_imgUpdateWithWhereUniqueWithoutClassesInput>
    updateMany?: Enumerable<class_imgUpdateManyWithWhereWithoutClassesInput>
    deleteMany?: Enumerable<class_imgScalarWhereInput>
  }

  export type contentsUncheckedUpdateManyWithoutClassesNestedInput = {
    create?: XOR<Enumerable<contentsCreateWithoutClassesInput>, Enumerable<contentsUncheckedCreateWithoutClassesInput>>
    connectOrCreate?: Enumerable<contentsCreateOrConnectWithoutClassesInput>
    upsert?: Enumerable<contentsUpsertWithWhereUniqueWithoutClassesInput>
    createMany?: contentsCreateManyClassesInputEnvelope
    set?: Enumerable<contentsWhereUniqueInput>
    disconnect?: Enumerable<contentsWhereUniqueInput>
    delete?: Enumerable<contentsWhereUniqueInput>
    connect?: Enumerable<contentsWhereUniqueInput>
    update?: Enumerable<contentsUpdateWithWhereUniqueWithoutClassesInput>
    updateMany?: Enumerable<contentsUpdateManyWithWhereWithoutClassesInput>
    deleteMany?: Enumerable<contentsScalarWhereInput>
  }

  export type my_classesUncheckedUpdateManyWithoutClassesNestedInput = {
    create?: XOR<Enumerable<my_classesCreateWithoutClassesInput>, Enumerable<my_classesUncheckedCreateWithoutClassesInput>>
    connectOrCreate?: Enumerable<my_classesCreateOrConnectWithoutClassesInput>
    upsert?: Enumerable<my_classesUpsertWithWhereUniqueWithoutClassesInput>
    createMany?: my_classesCreateManyClassesInputEnvelope
    set?: Enumerable<my_classesWhereUniqueInput>
    disconnect?: Enumerable<my_classesWhereUniqueInput>
    delete?: Enumerable<my_classesWhereUniqueInput>
    connect?: Enumerable<my_classesWhereUniqueInput>
    update?: Enumerable<my_classesUpdateWithWhereUniqueWithoutClassesInput>
    updateMany?: Enumerable<my_classesUpdateManyWithWhereWithoutClassesInput>
    deleteMany?: Enumerable<my_classesScalarWhereInput>
  }

  export type reviewUncheckedUpdateManyWithoutClassesNestedInput = {
    create?: XOR<Enumerable<reviewCreateWithoutClassesInput>, Enumerable<reviewUncheckedCreateWithoutClassesInput>>
    connectOrCreate?: Enumerable<reviewCreateOrConnectWithoutClassesInput>
    upsert?: Enumerable<reviewUpsertWithWhereUniqueWithoutClassesInput>
    createMany?: reviewCreateManyClassesInputEnvelope
    set?: Enumerable<reviewWhereUniqueInput>
    disconnect?: Enumerable<reviewWhereUniqueInput>
    delete?: Enumerable<reviewWhereUniqueInput>
    connect?: Enumerable<reviewWhereUniqueInput>
    update?: Enumerable<reviewUpdateWithWhereUniqueWithoutClassesInput>
    updateMany?: Enumerable<reviewUpdateManyWithWhereWithoutClassesInput>
    deleteMany?: Enumerable<reviewScalarWhereInput>
  }

  export type wishlistUncheckedUpdateManyWithoutClassesNestedInput = {
    create?: XOR<Enumerable<wishlistCreateWithoutClassesInput>, Enumerable<wishlistUncheckedCreateWithoutClassesInput>>
    connectOrCreate?: Enumerable<wishlistCreateOrConnectWithoutClassesInput>
    upsert?: Enumerable<wishlistUpsertWithWhereUniqueWithoutClassesInput>
    createMany?: wishlistCreateManyClassesInputEnvelope
    set?: Enumerable<wishlistWhereUniqueInput>
    disconnect?: Enumerable<wishlistWhereUniqueInput>
    delete?: Enumerable<wishlistWhereUniqueInput>
    connect?: Enumerable<wishlistWhereUniqueInput>
    update?: Enumerable<wishlistUpdateWithWhereUniqueWithoutClassesInput>
    updateMany?: Enumerable<wishlistUpdateManyWithWhereWithoutClassesInput>
    deleteMany?: Enumerable<wishlistScalarWhereInput>
  }

  export type classesCreateNestedOneWithoutContentsInput = {
    create?: XOR<classesCreateWithoutContentsInput, classesUncheckedCreateWithoutContentsInput>
    connectOrCreate?: classesCreateOrConnectWithoutContentsInput
    connect?: classesWhereUniqueInput
  }

  export type classesUpdateOneRequiredWithoutContentsNestedInput = {
    create?: XOR<classesCreateWithoutContentsInput, classesUncheckedCreateWithoutContentsInput>
    connectOrCreate?: classesCreateOrConnectWithoutContentsInput
    upsert?: classesUpsertWithoutContentsInput
    connect?: classesWhereUniqueInput
    update?: XOR<classesUpdateWithoutContentsInput, classesUncheckedUpdateWithoutContentsInput>
  }

  export type classesCreateNestedManyWithoutInstructorInput = {
    create?: XOR<Enumerable<classesCreateWithoutInstructorInput>, Enumerable<classesUncheckedCreateWithoutInstructorInput>>
    connectOrCreate?: Enumerable<classesCreateOrConnectWithoutInstructorInput>
    createMany?: classesCreateManyInstructorInputEnvelope
    connect?: Enumerable<classesWhereUniqueInput>
  }

  export type classesUncheckedCreateNestedManyWithoutInstructorInput = {
    create?: XOR<Enumerable<classesCreateWithoutInstructorInput>, Enumerable<classesUncheckedCreateWithoutInstructorInput>>
    connectOrCreate?: Enumerable<classesCreateOrConnectWithoutInstructorInput>
    createMany?: classesCreateManyInstructorInputEnvelope
    connect?: Enumerable<classesWhereUniqueInput>
  }

  export type classesUpdateManyWithoutInstructorNestedInput = {
    create?: XOR<Enumerable<classesCreateWithoutInstructorInput>, Enumerable<classesUncheckedCreateWithoutInstructorInput>>
    connectOrCreate?: Enumerable<classesCreateOrConnectWithoutInstructorInput>
    upsert?: Enumerable<classesUpsertWithWhereUniqueWithoutInstructorInput>
    createMany?: classesCreateManyInstructorInputEnvelope
    set?: Enumerable<classesWhereUniqueInput>
    disconnect?: Enumerable<classesWhereUniqueInput>
    delete?: Enumerable<classesWhereUniqueInput>
    connect?: Enumerable<classesWhereUniqueInput>
    update?: Enumerable<classesUpdateWithWhereUniqueWithoutInstructorInput>
    updateMany?: Enumerable<classesUpdateManyWithWhereWithoutInstructorInput>
    deleteMany?: Enumerable<classesScalarWhereInput>
  }

  export type classesUncheckedUpdateManyWithoutInstructorNestedInput = {
    create?: XOR<Enumerable<classesCreateWithoutInstructorInput>, Enumerable<classesUncheckedCreateWithoutInstructorInput>>
    connectOrCreate?: Enumerable<classesCreateOrConnectWithoutInstructorInput>
    upsert?: Enumerable<classesUpsertWithWhereUniqueWithoutInstructorInput>
    createMany?: classesCreateManyInstructorInputEnvelope
    set?: Enumerable<classesWhereUniqueInput>
    disconnect?: Enumerable<classesWhereUniqueInput>
    delete?: Enumerable<classesWhereUniqueInput>
    connect?: Enumerable<classesWhereUniqueInput>
    update?: Enumerable<classesUpdateWithWhereUniqueWithoutInstructorInput>
    updateMany?: Enumerable<classesUpdateManyWithWhereWithoutInstructorInput>
    deleteMany?: Enumerable<classesScalarWhereInput>
  }

  export type classesCreateNestedManyWithoutLevelInput = {
    create?: XOR<Enumerable<classesCreateWithoutLevelInput>, Enumerable<classesUncheckedCreateWithoutLevelInput>>
    connectOrCreate?: Enumerable<classesCreateOrConnectWithoutLevelInput>
    createMany?: classesCreateManyLevelInputEnvelope
    connect?: Enumerable<classesWhereUniqueInput>
  }

  export type classesUncheckedCreateNestedManyWithoutLevelInput = {
    create?: XOR<Enumerable<classesCreateWithoutLevelInput>, Enumerable<classesUncheckedCreateWithoutLevelInput>>
    connectOrCreate?: Enumerable<classesCreateOrConnectWithoutLevelInput>
    createMany?: classesCreateManyLevelInputEnvelope
    connect?: Enumerable<classesWhereUniqueInput>
  }

  export type classesUpdateManyWithoutLevelNestedInput = {
    create?: XOR<Enumerable<classesCreateWithoutLevelInput>, Enumerable<classesUncheckedCreateWithoutLevelInput>>
    connectOrCreate?: Enumerable<classesCreateOrConnectWithoutLevelInput>
    upsert?: Enumerable<classesUpsertWithWhereUniqueWithoutLevelInput>
    createMany?: classesCreateManyLevelInputEnvelope
    set?: Enumerable<classesWhereUniqueInput>
    disconnect?: Enumerable<classesWhereUniqueInput>
    delete?: Enumerable<classesWhereUniqueInput>
    connect?: Enumerable<classesWhereUniqueInput>
    update?: Enumerable<classesUpdateWithWhereUniqueWithoutLevelInput>
    updateMany?: Enumerable<classesUpdateManyWithWhereWithoutLevelInput>
    deleteMany?: Enumerable<classesScalarWhereInput>
  }

  export type classesUncheckedUpdateManyWithoutLevelNestedInput = {
    create?: XOR<Enumerable<classesCreateWithoutLevelInput>, Enumerable<classesUncheckedCreateWithoutLevelInput>>
    connectOrCreate?: Enumerable<classesCreateOrConnectWithoutLevelInput>
    upsert?: Enumerable<classesUpsertWithWhereUniqueWithoutLevelInput>
    createMany?: classesCreateManyLevelInputEnvelope
    set?: Enumerable<classesWhereUniqueInput>
    disconnect?: Enumerable<classesWhereUniqueInput>
    delete?: Enumerable<classesWhereUniqueInput>
    connect?: Enumerable<classesWhereUniqueInput>
    update?: Enumerable<classesUpdateWithWhereUniqueWithoutLevelInput>
    updateMany?: Enumerable<classesUpdateManyWithWhereWithoutLevelInput>
    deleteMany?: Enumerable<classesScalarWhereInput>
  }

  export type classesCreateNestedOneWithoutMy_classesInput = {
    create?: XOR<classesCreateWithoutMy_classesInput, classesUncheckedCreateWithoutMy_classesInput>
    connectOrCreate?: classesCreateOrConnectWithoutMy_classesInput
    connect?: classesWhereUniqueInput
  }

  export type usersCreateNestedOneWithoutMy_classesInput = {
    create?: XOR<usersCreateWithoutMy_classesInput, usersUncheckedCreateWithoutMy_classesInput>
    connectOrCreate?: usersCreateOrConnectWithoutMy_classesInput
    connect?: usersWhereUniqueInput
  }

  export type classesUpdateOneRequiredWithoutMy_classesNestedInput = {
    create?: XOR<classesCreateWithoutMy_classesInput, classesUncheckedCreateWithoutMy_classesInput>
    connectOrCreate?: classesCreateOrConnectWithoutMy_classesInput
    upsert?: classesUpsertWithoutMy_classesInput
    connect?: classesWhereUniqueInput
    update?: XOR<classesUpdateWithoutMy_classesInput, classesUncheckedUpdateWithoutMy_classesInput>
  }

  export type usersUpdateOneRequiredWithoutMy_classesNestedInput = {
    create?: XOR<usersCreateWithoutMy_classesInput, usersUncheckedCreateWithoutMy_classesInput>
    connectOrCreate?: usersCreateOrConnectWithoutMy_classesInput
    upsert?: usersUpsertWithoutMy_classesInput
    connect?: usersWhereUniqueInput
    update?: XOR<usersUpdateWithoutMy_classesInput, usersUncheckedUpdateWithoutMy_classesInput>
  }

  export type classesCreateNestedManyWithoutPrice_scope_classesToprice_scopeInput = {
    create?: XOR<Enumerable<classesCreateWithoutPrice_scope_classesToprice_scopeInput>, Enumerable<classesUncheckedCreateWithoutPrice_scope_classesToprice_scopeInput>>
    connectOrCreate?: Enumerable<classesCreateOrConnectWithoutPrice_scope_classesToprice_scopeInput>
    createMany?: classesCreateManyPrice_scope_classesToprice_scopeInputEnvelope
    connect?: Enumerable<classesWhereUniqueInput>
  }

  export type classesUncheckedCreateNestedManyWithoutPrice_scope_classesToprice_scopeInput = {
    create?: XOR<Enumerable<classesCreateWithoutPrice_scope_classesToprice_scopeInput>, Enumerable<classesUncheckedCreateWithoutPrice_scope_classesToprice_scopeInput>>
    connectOrCreate?: Enumerable<classesCreateOrConnectWithoutPrice_scope_classesToprice_scopeInput>
    createMany?: classesCreateManyPrice_scope_classesToprice_scopeInputEnvelope
    connect?: Enumerable<classesWhereUniqueInput>
  }

  export type classesUpdateManyWithoutPrice_scope_classesToprice_scopeNestedInput = {
    create?: XOR<Enumerable<classesCreateWithoutPrice_scope_classesToprice_scopeInput>, Enumerable<classesUncheckedCreateWithoutPrice_scope_classesToprice_scopeInput>>
    connectOrCreate?: Enumerable<classesCreateOrConnectWithoutPrice_scope_classesToprice_scopeInput>
    upsert?: Enumerable<classesUpsertWithWhereUniqueWithoutPrice_scope_classesToprice_scopeInput>
    createMany?: classesCreateManyPrice_scope_classesToprice_scopeInputEnvelope
    set?: Enumerable<classesWhereUniqueInput>
    disconnect?: Enumerable<classesWhereUniqueInput>
    delete?: Enumerable<classesWhereUniqueInput>
    connect?: Enumerable<classesWhereUniqueInput>
    update?: Enumerable<classesUpdateWithWhereUniqueWithoutPrice_scope_classesToprice_scopeInput>
    updateMany?: Enumerable<classesUpdateManyWithWhereWithoutPrice_scope_classesToprice_scopeInput>
    deleteMany?: Enumerable<classesScalarWhereInput>
  }

  export type classesUncheckedUpdateManyWithoutPrice_scope_classesToprice_scopeNestedInput = {
    create?: XOR<Enumerable<classesCreateWithoutPrice_scope_classesToprice_scopeInput>, Enumerable<classesUncheckedCreateWithoutPrice_scope_classesToprice_scopeInput>>
    connectOrCreate?: Enumerable<classesCreateOrConnectWithoutPrice_scope_classesToprice_scopeInput>
    upsert?: Enumerable<classesUpsertWithWhereUniqueWithoutPrice_scope_classesToprice_scopeInput>
    createMany?: classesCreateManyPrice_scope_classesToprice_scopeInputEnvelope
    set?: Enumerable<classesWhereUniqueInput>
    disconnect?: Enumerable<classesWhereUniqueInput>
    delete?: Enumerable<classesWhereUniqueInput>
    connect?: Enumerable<classesWhereUniqueInput>
    update?: Enumerable<classesUpdateWithWhereUniqueWithoutPrice_scope_classesToprice_scopeInput>
    updateMany?: Enumerable<classesUpdateManyWithWhereWithoutPrice_scope_classesToprice_scopeInput>
    deleteMany?: Enumerable<classesScalarWhereInput>
  }

  export type classesCreateNestedOneWithoutReviewInput = {
    create?: XOR<classesCreateWithoutReviewInput, classesUncheckedCreateWithoutReviewInput>
    connectOrCreate?: classesCreateOrConnectWithoutReviewInput
    connect?: classesWhereUniqueInput
  }

  export type usersCreateNestedOneWithoutReviewInput = {
    create?: XOR<usersCreateWithoutReviewInput, usersUncheckedCreateWithoutReviewInput>
    connectOrCreate?: usersCreateOrConnectWithoutReviewInput
    connect?: usersWhereUniqueInput
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type classesUpdateOneRequiredWithoutReviewNestedInput = {
    create?: XOR<classesCreateWithoutReviewInput, classesUncheckedCreateWithoutReviewInput>
    connectOrCreate?: classesCreateOrConnectWithoutReviewInput
    upsert?: classesUpsertWithoutReviewInput
    connect?: classesWhereUniqueInput
    update?: XOR<classesUpdateWithoutReviewInput, classesUncheckedUpdateWithoutReviewInput>
  }

  export type usersUpdateOneRequiredWithoutReviewNestedInput = {
    create?: XOR<usersCreateWithoutReviewInput, usersUncheckedCreateWithoutReviewInput>
    connectOrCreate?: usersCreateOrConnectWithoutReviewInput
    upsert?: usersUpsertWithoutReviewInput
    connect?: usersWhereUniqueInput
    update?: XOR<usersUpdateWithoutReviewInput, usersUncheckedUpdateWithoutReviewInput>
  }

  export type classesCreateNestedOneWithoutWishlistInput = {
    create?: XOR<classesCreateWithoutWishlistInput, classesUncheckedCreateWithoutWishlistInput>
    connectOrCreate?: classesCreateOrConnectWithoutWishlistInput
    connect?: classesWhereUniqueInput
  }

  export type usersCreateNestedOneWithoutWishlistInput = {
    create?: XOR<usersCreateWithoutWishlistInput, usersUncheckedCreateWithoutWishlistInput>
    connectOrCreate?: usersCreateOrConnectWithoutWishlistInput
    connect?: usersWhereUniqueInput
  }

  export type classesUpdateOneRequiredWithoutWishlistNestedInput = {
    create?: XOR<classesCreateWithoutWishlistInput, classesUncheckedCreateWithoutWishlistInput>
    connectOrCreate?: classesCreateOrConnectWithoutWishlistInput
    upsert?: classesUpsertWithoutWishlistInput
    connect?: classesWhereUniqueInput
    update?: XOR<classesUpdateWithoutWishlistInput, classesUncheckedUpdateWithoutWishlistInput>
  }

  export type usersUpdateOneRequiredWithoutWishlistNestedInput = {
    create?: XOR<usersCreateWithoutWishlistInput, usersUncheckedCreateWithoutWishlistInput>
    connectOrCreate?: usersCreateOrConnectWithoutWishlistInput
    upsert?: usersUpsertWithoutWishlistInput
    connect?: usersWhereUniqueInput
    update?: XOR<usersUpdateWithoutWishlistInput, usersUncheckedUpdateWithoutWishlistInput>
  }

  export type NestedIntFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type NestedStringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableFilter | string | null
  }

  export type NestedStringFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringFilter | string
  }

  export type NestedDateTimeNullableFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableFilter | Date | string | null
  }

  export type NestedIntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    _min?: NestedIntFilter
    _max?: NestedIntFilter
  }

  export type NestedFloatFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatFilter | number
  }

  export type NestedStringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
  }

  export type NestedIntNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
  }

  export type NestedStringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type NestedDateTimeNullableWithAggregatesFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableWithAggregatesFilter | Date | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedDateTimeNullableFilter
    _max?: NestedDateTimeNullableFilter
  }

  export type NestedIntNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedIntNullableFilter
    _min?: NestedIntNullableFilter
    _max?: NestedIntNullableFilter
  }

  export type NestedFloatNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatNullableFilter | number | null
  }

  export type NestedFloatNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedFloatNullableFilter
    _min?: NestedFloatNullableFilter
    _max?: NestedFloatNullableFilter
  }

  export type NestedFloatWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedFloatFilter
    _min?: NestedFloatFilter
    _max?: NestedFloatFilter
  }

  export type my_classesCreateWithoutUsersInput = {
    progress?: number
    classes: classesCreateNestedOneWithoutMy_classesInput
  }

  export type my_classesUncheckedCreateWithoutUsersInput = {
    id?: number
    class_id: number
    progress?: number
  }

  export type my_classesCreateOrConnectWithoutUsersInput = {
    where: my_classesWhereUniqueInput
    create: XOR<my_classesCreateWithoutUsersInput, my_classesUncheckedCreateWithoutUsersInput>
  }

  export type my_classesCreateManyUsersInputEnvelope = {
    data: Enumerable<my_classesCreateManyUsersInput>
    skipDuplicates?: boolean
  }

  export type reviewCreateWithoutUsersInput = {
    rate: number
    classes: classesCreateNestedOneWithoutReviewInput
  }

  export type reviewUncheckedCreateWithoutUsersInput = {
    id?: number
    rate: number
    class_id: number
  }

  export type reviewCreateOrConnectWithoutUsersInput = {
    where: reviewWhereUniqueInput
    create: XOR<reviewCreateWithoutUsersInput, reviewUncheckedCreateWithoutUsersInput>
  }

  export type reviewCreateManyUsersInputEnvelope = {
    data: Enumerable<reviewCreateManyUsersInput>
    skipDuplicates?: boolean
  }

  export type wishlistCreateWithoutUsersInput = {
    classes: classesCreateNestedOneWithoutWishlistInput
  }

  export type wishlistUncheckedCreateWithoutUsersInput = {
    id?: number
    class_id: number
  }

  export type wishlistCreateOrConnectWithoutUsersInput = {
    where: wishlistWhereUniqueInput
    create: XOR<wishlistCreateWithoutUsersInput, wishlistUncheckedCreateWithoutUsersInput>
  }

  export type wishlistCreateManyUsersInputEnvelope = {
    data: Enumerable<wishlistCreateManyUsersInput>
    skipDuplicates?: boolean
  }

  export type my_classesUpsertWithWhereUniqueWithoutUsersInput = {
    where: my_classesWhereUniqueInput
    update: XOR<my_classesUpdateWithoutUsersInput, my_classesUncheckedUpdateWithoutUsersInput>
    create: XOR<my_classesCreateWithoutUsersInput, my_classesUncheckedCreateWithoutUsersInput>
  }

  export type my_classesUpdateWithWhereUniqueWithoutUsersInput = {
    where: my_classesWhereUniqueInput
    data: XOR<my_classesUpdateWithoutUsersInput, my_classesUncheckedUpdateWithoutUsersInput>
  }

  export type my_classesUpdateManyWithWhereWithoutUsersInput = {
    where: my_classesScalarWhereInput
    data: XOR<my_classesUpdateManyMutationInput, my_classesUncheckedUpdateManyWithoutMy_classesInput>
  }

  export type my_classesScalarWhereInput = {
    AND?: Enumerable<my_classesScalarWhereInput>
    OR?: Enumerable<my_classesScalarWhereInput>
    NOT?: Enumerable<my_classesScalarWhereInput>
    id?: IntFilter | number
    user_id?: IntFilter | number
    class_id?: IntFilter | number
    progress?: IntFilter | number
  }

  export type reviewUpsertWithWhereUniqueWithoutUsersInput = {
    where: reviewWhereUniqueInput
    update: XOR<reviewUpdateWithoutUsersInput, reviewUncheckedUpdateWithoutUsersInput>
    create: XOR<reviewCreateWithoutUsersInput, reviewUncheckedCreateWithoutUsersInput>
  }

  export type reviewUpdateWithWhereUniqueWithoutUsersInput = {
    where: reviewWhereUniqueInput
    data: XOR<reviewUpdateWithoutUsersInput, reviewUncheckedUpdateWithoutUsersInput>
  }

  export type reviewUpdateManyWithWhereWithoutUsersInput = {
    where: reviewScalarWhereInput
    data: XOR<reviewUpdateManyMutationInput, reviewUncheckedUpdateManyWithoutReviewInput>
  }

  export type reviewScalarWhereInput = {
    AND?: Enumerable<reviewScalarWhereInput>
    OR?: Enumerable<reviewScalarWhereInput>
    NOT?: Enumerable<reviewScalarWhereInput>
    id?: IntFilter | number
    user_id?: IntFilter | number
    rate?: FloatFilter | number
    class_id?: IntFilter | number
  }

  export type wishlistUpsertWithWhereUniqueWithoutUsersInput = {
    where: wishlistWhereUniqueInput
    update: XOR<wishlistUpdateWithoutUsersInput, wishlistUncheckedUpdateWithoutUsersInput>
    create: XOR<wishlistCreateWithoutUsersInput, wishlistUncheckedCreateWithoutUsersInput>
  }

  export type wishlistUpdateWithWhereUniqueWithoutUsersInput = {
    where: wishlistWhereUniqueInput
    data: XOR<wishlistUpdateWithoutUsersInput, wishlistUncheckedUpdateWithoutUsersInput>
  }

  export type wishlistUpdateManyWithWhereWithoutUsersInput = {
    where: wishlistScalarWhereInput
    data: XOR<wishlistUpdateManyMutationInput, wishlistUncheckedUpdateManyWithoutWishlistInput>
  }

  export type wishlistScalarWhereInput = {
    AND?: Enumerable<wishlistScalarWhereInput>
    OR?: Enumerable<wishlistScalarWhereInput>
    NOT?: Enumerable<wishlistScalarWhereInput>
    id?: IntFilter | number
    user_id?: IntFilter | number
    class_id?: IntFilter | number
  }

  export type classesCreateWithoutCategory_categoryToclasses_category1_idInput = {
    name: string
    price?: number | null
    img?: string | null
    rate?: number | null
    description?: string | null
    students?: number | null
    sessions?: number | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    category_categoryToclasses_category2_id?: categoryCreateNestedOneWithoutClasses_categoryToclasses_category2_idInput
    category_categoryToclasses_category3_id?: categoryCreateNestedOneWithoutClasses_categoryToclasses_category3_idInput
    instructor: instructorCreateNestedOneWithoutClassesInput
    level?: levelCreateNestedOneWithoutClassesInput
    price_scope_classesToprice_scope?: price_scopeCreateNestedOneWithoutClassesInput
    class_img?: class_imgCreateNestedManyWithoutClassesInput
    contents?: contentsCreateNestedManyWithoutClassesInput
    my_classes?: my_classesCreateNestedManyWithoutClassesInput
    review?: reviewCreateNestedManyWithoutClassesInput
    wishlist?: wishlistCreateNestedManyWithoutClassesInput
  }

  export type classesUncheckedCreateWithoutCategory_categoryToclasses_category1_idInput = {
    id?: number
    name: string
    instructor_id: number
    price?: number | null
    img?: string | null
    rate?: number | null
    description?: string | null
    students?: number | null
    sessions?: number | null
    price_scope?: number | null
    category2_id?: number | null
    category3_id?: number | null
    level_id?: number | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    class_img?: class_imgUncheckedCreateNestedManyWithoutClassesInput
    contents?: contentsUncheckedCreateNestedManyWithoutClassesInput
    my_classes?: my_classesUncheckedCreateNestedManyWithoutClassesInput
    review?: reviewUncheckedCreateNestedManyWithoutClassesInput
    wishlist?: wishlistUncheckedCreateNestedManyWithoutClassesInput
  }

  export type classesCreateOrConnectWithoutCategory_categoryToclasses_category1_idInput = {
    where: classesWhereUniqueInput
    create: XOR<classesCreateWithoutCategory_categoryToclasses_category1_idInput, classesUncheckedCreateWithoutCategory_categoryToclasses_category1_idInput>
  }

  export type classesCreateManyCategory_categoryToclasses_category1_idInputEnvelope = {
    data: Enumerable<classesCreateManyCategory_categoryToclasses_category1_idInput>
    skipDuplicates?: boolean
  }

  export type classesCreateWithoutCategory_categoryToclasses_category2_idInput = {
    name: string
    price?: number | null
    img?: string | null
    rate?: number | null
    description?: string | null
    students?: number | null
    sessions?: number | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    category_categoryToclasses_category1_id?: categoryCreateNestedOneWithoutClasses_categoryToclasses_category1_idInput
    category_categoryToclasses_category3_id?: categoryCreateNestedOneWithoutClasses_categoryToclasses_category3_idInput
    instructor: instructorCreateNestedOneWithoutClassesInput
    level?: levelCreateNestedOneWithoutClassesInput
    price_scope_classesToprice_scope?: price_scopeCreateNestedOneWithoutClassesInput
    class_img?: class_imgCreateNestedManyWithoutClassesInput
    contents?: contentsCreateNestedManyWithoutClassesInput
    my_classes?: my_classesCreateNestedManyWithoutClassesInput
    review?: reviewCreateNestedManyWithoutClassesInput
    wishlist?: wishlistCreateNestedManyWithoutClassesInput
  }

  export type classesUncheckedCreateWithoutCategory_categoryToclasses_category2_idInput = {
    id?: number
    name: string
    instructor_id: number
    price?: number | null
    img?: string | null
    rate?: number | null
    description?: string | null
    students?: number | null
    sessions?: number | null
    price_scope?: number | null
    category1_id?: number | null
    category3_id?: number | null
    level_id?: number | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    class_img?: class_imgUncheckedCreateNestedManyWithoutClassesInput
    contents?: contentsUncheckedCreateNestedManyWithoutClassesInput
    my_classes?: my_classesUncheckedCreateNestedManyWithoutClassesInput
    review?: reviewUncheckedCreateNestedManyWithoutClassesInput
    wishlist?: wishlistUncheckedCreateNestedManyWithoutClassesInput
  }

  export type classesCreateOrConnectWithoutCategory_categoryToclasses_category2_idInput = {
    where: classesWhereUniqueInput
    create: XOR<classesCreateWithoutCategory_categoryToclasses_category2_idInput, classesUncheckedCreateWithoutCategory_categoryToclasses_category2_idInput>
  }

  export type classesCreateManyCategory_categoryToclasses_category2_idInputEnvelope = {
    data: Enumerable<classesCreateManyCategory_categoryToclasses_category2_idInput>
    skipDuplicates?: boolean
  }

  export type classesCreateWithoutCategory_categoryToclasses_category3_idInput = {
    name: string
    price?: number | null
    img?: string | null
    rate?: number | null
    description?: string | null
    students?: number | null
    sessions?: number | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    category_categoryToclasses_category1_id?: categoryCreateNestedOneWithoutClasses_categoryToclasses_category1_idInput
    category_categoryToclasses_category2_id?: categoryCreateNestedOneWithoutClasses_categoryToclasses_category2_idInput
    instructor: instructorCreateNestedOneWithoutClassesInput
    level?: levelCreateNestedOneWithoutClassesInput
    price_scope_classesToprice_scope?: price_scopeCreateNestedOneWithoutClassesInput
    class_img?: class_imgCreateNestedManyWithoutClassesInput
    contents?: contentsCreateNestedManyWithoutClassesInput
    my_classes?: my_classesCreateNestedManyWithoutClassesInput
    review?: reviewCreateNestedManyWithoutClassesInput
    wishlist?: wishlistCreateNestedManyWithoutClassesInput
  }

  export type classesUncheckedCreateWithoutCategory_categoryToclasses_category3_idInput = {
    id?: number
    name: string
    instructor_id: number
    price?: number | null
    img?: string | null
    rate?: number | null
    description?: string | null
    students?: number | null
    sessions?: number | null
    price_scope?: number | null
    category1_id?: number | null
    category2_id?: number | null
    level_id?: number | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    class_img?: class_imgUncheckedCreateNestedManyWithoutClassesInput
    contents?: contentsUncheckedCreateNestedManyWithoutClassesInput
    my_classes?: my_classesUncheckedCreateNestedManyWithoutClassesInput
    review?: reviewUncheckedCreateNestedManyWithoutClassesInput
    wishlist?: wishlistUncheckedCreateNestedManyWithoutClassesInput
  }

  export type classesCreateOrConnectWithoutCategory_categoryToclasses_category3_idInput = {
    where: classesWhereUniqueInput
    create: XOR<classesCreateWithoutCategory_categoryToclasses_category3_idInput, classesUncheckedCreateWithoutCategory_categoryToclasses_category3_idInput>
  }

  export type classesCreateManyCategory_categoryToclasses_category3_idInputEnvelope = {
    data: Enumerable<classesCreateManyCategory_categoryToclasses_category3_idInput>
    skipDuplicates?: boolean
  }

  export type classesUpsertWithWhereUniqueWithoutCategory_categoryToclasses_category1_idInput = {
    where: classesWhereUniqueInput
    update: XOR<classesUpdateWithoutCategory_categoryToclasses_category1_idInput, classesUncheckedUpdateWithoutCategory_categoryToclasses_category1_idInput>
    create: XOR<classesCreateWithoutCategory_categoryToclasses_category1_idInput, classesUncheckedCreateWithoutCategory_categoryToclasses_category1_idInput>
  }

  export type classesUpdateWithWhereUniqueWithoutCategory_categoryToclasses_category1_idInput = {
    where: classesWhereUniqueInput
    data: XOR<classesUpdateWithoutCategory_categoryToclasses_category1_idInput, classesUncheckedUpdateWithoutCategory_categoryToclasses_category1_idInput>
  }

  export type classesUpdateManyWithWhereWithoutCategory_categoryToclasses_category1_idInput = {
    where: classesScalarWhereInput
    data: XOR<classesUpdateManyMutationInput, classesUncheckedUpdateManyWithoutClasses_categoryToclasses_category1_idInput>
  }

  export type classesScalarWhereInput = {
    AND?: Enumerable<classesScalarWhereInput>
    OR?: Enumerable<classesScalarWhereInput>
    NOT?: Enumerable<classesScalarWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    instructor_id?: IntFilter | number
    price?: FloatNullableFilter | number | null
    img?: StringNullableFilter | string | null
    rate?: FloatNullableFilter | number | null
    description?: StringNullableFilter | string | null
    students?: IntNullableFilter | number | null
    sessions?: IntNullableFilter | number | null
    price_scope?: IntNullableFilter | number | null
    category1_id?: IntNullableFilter | number | null
    category2_id?: IntNullableFilter | number | null
    category3_id?: IntNullableFilter | number | null
    level_id?: IntNullableFilter | number | null
    created_at?: DateTimeNullableFilter | Date | string | null
    updated_at?: DateTimeNullableFilter | Date | string | null
  }

  export type classesUpsertWithWhereUniqueWithoutCategory_categoryToclasses_category2_idInput = {
    where: classesWhereUniqueInput
    update: XOR<classesUpdateWithoutCategory_categoryToclasses_category2_idInput, classesUncheckedUpdateWithoutCategory_categoryToclasses_category2_idInput>
    create: XOR<classesCreateWithoutCategory_categoryToclasses_category2_idInput, classesUncheckedCreateWithoutCategory_categoryToclasses_category2_idInput>
  }

  export type classesUpdateWithWhereUniqueWithoutCategory_categoryToclasses_category2_idInput = {
    where: classesWhereUniqueInput
    data: XOR<classesUpdateWithoutCategory_categoryToclasses_category2_idInput, classesUncheckedUpdateWithoutCategory_categoryToclasses_category2_idInput>
  }

  export type classesUpdateManyWithWhereWithoutCategory_categoryToclasses_category2_idInput = {
    where: classesScalarWhereInput
    data: XOR<classesUpdateManyMutationInput, classesUncheckedUpdateManyWithoutClasses_categoryToclasses_category2_idInput>
  }

  export type classesUpsertWithWhereUniqueWithoutCategory_categoryToclasses_category3_idInput = {
    where: classesWhereUniqueInput
    update: XOR<classesUpdateWithoutCategory_categoryToclasses_category3_idInput, classesUncheckedUpdateWithoutCategory_categoryToclasses_category3_idInput>
    create: XOR<classesCreateWithoutCategory_categoryToclasses_category3_idInput, classesUncheckedCreateWithoutCategory_categoryToclasses_category3_idInput>
  }

  export type classesUpdateWithWhereUniqueWithoutCategory_categoryToclasses_category3_idInput = {
    where: classesWhereUniqueInput
    data: XOR<classesUpdateWithoutCategory_categoryToclasses_category3_idInput, classesUncheckedUpdateWithoutCategory_categoryToclasses_category3_idInput>
  }

  export type classesUpdateManyWithWhereWithoutCategory_categoryToclasses_category3_idInput = {
    where: classesScalarWhereInput
    data: XOR<classesUpdateManyMutationInput, classesUncheckedUpdateManyWithoutClasses_categoryToclasses_category3_idInput>
  }

  export type classesCreateWithoutClass_imgInput = {
    name: string
    price?: number | null
    img?: string | null
    rate?: number | null
    description?: string | null
    students?: number | null
    sessions?: number | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    category_categoryToclasses_category1_id?: categoryCreateNestedOneWithoutClasses_categoryToclasses_category1_idInput
    category_categoryToclasses_category2_id?: categoryCreateNestedOneWithoutClasses_categoryToclasses_category2_idInput
    category_categoryToclasses_category3_id?: categoryCreateNestedOneWithoutClasses_categoryToclasses_category3_idInput
    instructor: instructorCreateNestedOneWithoutClassesInput
    level?: levelCreateNestedOneWithoutClassesInput
    price_scope_classesToprice_scope?: price_scopeCreateNestedOneWithoutClassesInput
    contents?: contentsCreateNestedManyWithoutClassesInput
    my_classes?: my_classesCreateNestedManyWithoutClassesInput
    review?: reviewCreateNestedManyWithoutClassesInput
    wishlist?: wishlistCreateNestedManyWithoutClassesInput
  }

  export type classesUncheckedCreateWithoutClass_imgInput = {
    id?: number
    name: string
    instructor_id: number
    price?: number | null
    img?: string | null
    rate?: number | null
    description?: string | null
    students?: number | null
    sessions?: number | null
    price_scope?: number | null
    category1_id?: number | null
    category2_id?: number | null
    category3_id?: number | null
    level_id?: number | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    contents?: contentsUncheckedCreateNestedManyWithoutClassesInput
    my_classes?: my_classesUncheckedCreateNestedManyWithoutClassesInput
    review?: reviewUncheckedCreateNestedManyWithoutClassesInput
    wishlist?: wishlistUncheckedCreateNestedManyWithoutClassesInput
  }

  export type classesCreateOrConnectWithoutClass_imgInput = {
    where: classesWhereUniqueInput
    create: XOR<classesCreateWithoutClass_imgInput, classesUncheckedCreateWithoutClass_imgInput>
  }

  export type classesUpsertWithoutClass_imgInput = {
    update: XOR<classesUpdateWithoutClass_imgInput, classesUncheckedUpdateWithoutClass_imgInput>
    create: XOR<classesCreateWithoutClass_imgInput, classesUncheckedCreateWithoutClass_imgInput>
  }

  export type classesUpdateWithoutClass_imgInput = {
    name?: StringFieldUpdateOperationsInput | string
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    img?: NullableStringFieldUpdateOperationsInput | string | null
    rate?: NullableFloatFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    students?: NullableIntFieldUpdateOperationsInput | number | null
    sessions?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    category_categoryToclasses_category1_id?: categoryUpdateOneWithoutClasses_categoryToclasses_category1_idNestedInput
    category_categoryToclasses_category2_id?: categoryUpdateOneWithoutClasses_categoryToclasses_category2_idNestedInput
    category_categoryToclasses_category3_id?: categoryUpdateOneWithoutClasses_categoryToclasses_category3_idNestedInput
    instructor?: instructorUpdateOneRequiredWithoutClassesNestedInput
    level?: levelUpdateOneWithoutClassesNestedInput
    price_scope_classesToprice_scope?: price_scopeUpdateOneWithoutClassesNestedInput
    contents?: contentsUpdateManyWithoutClassesNestedInput
    my_classes?: my_classesUpdateManyWithoutClassesNestedInput
    review?: reviewUpdateManyWithoutClassesNestedInput
    wishlist?: wishlistUpdateManyWithoutClassesNestedInput
  }

  export type classesUncheckedUpdateWithoutClass_imgInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    instructor_id?: IntFieldUpdateOperationsInput | number
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    img?: NullableStringFieldUpdateOperationsInput | string | null
    rate?: NullableFloatFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    students?: NullableIntFieldUpdateOperationsInput | number | null
    sessions?: NullableIntFieldUpdateOperationsInput | number | null
    price_scope?: NullableIntFieldUpdateOperationsInput | number | null
    category1_id?: NullableIntFieldUpdateOperationsInput | number | null
    category2_id?: NullableIntFieldUpdateOperationsInput | number | null
    category3_id?: NullableIntFieldUpdateOperationsInput | number | null
    level_id?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contents?: contentsUncheckedUpdateManyWithoutClassesNestedInput
    my_classes?: my_classesUncheckedUpdateManyWithoutClassesNestedInput
    review?: reviewUncheckedUpdateManyWithoutClassesNestedInput
    wishlist?: wishlistUncheckedUpdateManyWithoutClassesNestedInput
  }

  export type categoryCreateWithoutClasses_categoryToclasses_category1_idInput = {
    name: string
    depth?: number | null
    parent_id?: number | null
    classes_categoryToclasses_category2_id?: classesCreateNestedManyWithoutCategory_categoryToclasses_category2_idInput
    classes_categoryToclasses_category3_id?: classesCreateNestedManyWithoutCategory_categoryToclasses_category3_idInput
  }

  export type categoryUncheckedCreateWithoutClasses_categoryToclasses_category1_idInput = {
    id?: number
    name: string
    depth?: number | null
    parent_id?: number | null
    classes_categoryToclasses_category2_id?: classesUncheckedCreateNestedManyWithoutCategory_categoryToclasses_category2_idInput
    classes_categoryToclasses_category3_id?: classesUncheckedCreateNestedManyWithoutCategory_categoryToclasses_category3_idInput
  }

  export type categoryCreateOrConnectWithoutClasses_categoryToclasses_category1_idInput = {
    where: categoryWhereUniqueInput
    create: XOR<categoryCreateWithoutClasses_categoryToclasses_category1_idInput, categoryUncheckedCreateWithoutClasses_categoryToclasses_category1_idInput>
  }

  export type categoryCreateWithoutClasses_categoryToclasses_category2_idInput = {
    name: string
    depth?: number | null
    parent_id?: number | null
    classes_categoryToclasses_category1_id?: classesCreateNestedManyWithoutCategory_categoryToclasses_category1_idInput
    classes_categoryToclasses_category3_id?: classesCreateNestedManyWithoutCategory_categoryToclasses_category3_idInput
  }

  export type categoryUncheckedCreateWithoutClasses_categoryToclasses_category2_idInput = {
    id?: number
    name: string
    depth?: number | null
    parent_id?: number | null
    classes_categoryToclasses_category1_id?: classesUncheckedCreateNestedManyWithoutCategory_categoryToclasses_category1_idInput
    classes_categoryToclasses_category3_id?: classesUncheckedCreateNestedManyWithoutCategory_categoryToclasses_category3_idInput
  }

  export type categoryCreateOrConnectWithoutClasses_categoryToclasses_category2_idInput = {
    where: categoryWhereUniqueInput
    create: XOR<categoryCreateWithoutClasses_categoryToclasses_category2_idInput, categoryUncheckedCreateWithoutClasses_categoryToclasses_category2_idInput>
  }

  export type categoryCreateWithoutClasses_categoryToclasses_category3_idInput = {
    name: string
    depth?: number | null
    parent_id?: number | null
    classes_categoryToclasses_category1_id?: classesCreateNestedManyWithoutCategory_categoryToclasses_category1_idInput
    classes_categoryToclasses_category2_id?: classesCreateNestedManyWithoutCategory_categoryToclasses_category2_idInput
  }

  export type categoryUncheckedCreateWithoutClasses_categoryToclasses_category3_idInput = {
    id?: number
    name: string
    depth?: number | null
    parent_id?: number | null
    classes_categoryToclasses_category1_id?: classesUncheckedCreateNestedManyWithoutCategory_categoryToclasses_category1_idInput
    classes_categoryToclasses_category2_id?: classesUncheckedCreateNestedManyWithoutCategory_categoryToclasses_category2_idInput
  }

  export type categoryCreateOrConnectWithoutClasses_categoryToclasses_category3_idInput = {
    where: categoryWhereUniqueInput
    create: XOR<categoryCreateWithoutClasses_categoryToclasses_category3_idInput, categoryUncheckedCreateWithoutClasses_categoryToclasses_category3_idInput>
  }

  export type instructorCreateWithoutClassesInput = {
    name: string
  }

  export type instructorUncheckedCreateWithoutClassesInput = {
    id?: number
    name: string
  }

  export type instructorCreateOrConnectWithoutClassesInput = {
    where: instructorWhereUniqueInput
    create: XOR<instructorCreateWithoutClassesInput, instructorUncheckedCreateWithoutClassesInput>
  }

  export type levelCreateWithoutClassesInput = {
    level: string
  }

  export type levelUncheckedCreateWithoutClassesInput = {
    id?: number
    level: string
  }

  export type levelCreateOrConnectWithoutClassesInput = {
    where: levelWhereUniqueInput
    create: XOR<levelCreateWithoutClassesInput, levelUncheckedCreateWithoutClassesInput>
  }

  export type price_scopeCreateWithoutClassesInput = {
    scope?: string | null
  }

  export type price_scopeUncheckedCreateWithoutClassesInput = {
    id?: number
    scope?: string | null
  }

  export type price_scopeCreateOrConnectWithoutClassesInput = {
    where: price_scopeWhereUniqueInput
    create: XOR<price_scopeCreateWithoutClassesInput, price_scopeUncheckedCreateWithoutClassesInput>
  }

  export type class_imgCreateWithoutClassesInput = {
    url: string
  }

  export type class_imgUncheckedCreateWithoutClassesInput = {
    id?: number
    url: string
  }

  export type class_imgCreateOrConnectWithoutClassesInput = {
    where: class_imgWhereUniqueInput
    create: XOR<class_imgCreateWithoutClassesInput, class_imgUncheckedCreateWithoutClassesInput>
  }

  export type class_imgCreateManyClassesInputEnvelope = {
    data: Enumerable<class_imgCreateManyClassesInput>
    skipDuplicates?: boolean
  }

  export type contentsCreateWithoutClassesInput = {
    content?: string | null
  }

  export type contentsUncheckedCreateWithoutClassesInput = {
    id?: number
    content?: string | null
  }

  export type contentsCreateOrConnectWithoutClassesInput = {
    where: contentsWhereUniqueInput
    create: XOR<contentsCreateWithoutClassesInput, contentsUncheckedCreateWithoutClassesInput>
  }

  export type contentsCreateManyClassesInputEnvelope = {
    data: Enumerable<contentsCreateManyClassesInput>
    skipDuplicates?: boolean
  }

  export type my_classesCreateWithoutClassesInput = {
    progress?: number
    users: usersCreateNestedOneWithoutMy_classesInput
  }

  export type my_classesUncheckedCreateWithoutClassesInput = {
    id?: number
    user_id: number
    progress?: number
  }

  export type my_classesCreateOrConnectWithoutClassesInput = {
    where: my_classesWhereUniqueInput
    create: XOR<my_classesCreateWithoutClassesInput, my_classesUncheckedCreateWithoutClassesInput>
  }

  export type my_classesCreateManyClassesInputEnvelope = {
    data: Enumerable<my_classesCreateManyClassesInput>
    skipDuplicates?: boolean
  }

  export type reviewCreateWithoutClassesInput = {
    rate: number
    users: usersCreateNestedOneWithoutReviewInput
  }

  export type reviewUncheckedCreateWithoutClassesInput = {
    id?: number
    user_id: number
    rate: number
  }

  export type reviewCreateOrConnectWithoutClassesInput = {
    where: reviewWhereUniqueInput
    create: XOR<reviewCreateWithoutClassesInput, reviewUncheckedCreateWithoutClassesInput>
  }

  export type reviewCreateManyClassesInputEnvelope = {
    data: Enumerable<reviewCreateManyClassesInput>
    skipDuplicates?: boolean
  }

  export type wishlistCreateWithoutClassesInput = {
    users: usersCreateNestedOneWithoutWishlistInput
  }

  export type wishlistUncheckedCreateWithoutClassesInput = {
    id?: number
    user_id: number
  }

  export type wishlistCreateOrConnectWithoutClassesInput = {
    where: wishlistWhereUniqueInput
    create: XOR<wishlistCreateWithoutClassesInput, wishlistUncheckedCreateWithoutClassesInput>
  }

  export type wishlistCreateManyClassesInputEnvelope = {
    data: Enumerable<wishlistCreateManyClassesInput>
    skipDuplicates?: boolean
  }

  export type categoryUpsertWithoutClasses_categoryToclasses_category1_idInput = {
    update: XOR<categoryUpdateWithoutClasses_categoryToclasses_category1_idInput, categoryUncheckedUpdateWithoutClasses_categoryToclasses_category1_idInput>
    create: XOR<categoryCreateWithoutClasses_categoryToclasses_category1_idInput, categoryUncheckedCreateWithoutClasses_categoryToclasses_category1_idInput>
  }

  export type categoryUpdateWithoutClasses_categoryToclasses_category1_idInput = {
    name?: StringFieldUpdateOperationsInput | string
    depth?: NullableIntFieldUpdateOperationsInput | number | null
    parent_id?: NullableIntFieldUpdateOperationsInput | number | null
    classes_categoryToclasses_category2_id?: classesUpdateManyWithoutCategory_categoryToclasses_category2_idNestedInput
    classes_categoryToclasses_category3_id?: classesUpdateManyWithoutCategory_categoryToclasses_category3_idNestedInput
  }

  export type categoryUncheckedUpdateWithoutClasses_categoryToclasses_category1_idInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    depth?: NullableIntFieldUpdateOperationsInput | number | null
    parent_id?: NullableIntFieldUpdateOperationsInput | number | null
    classes_categoryToclasses_category2_id?: classesUncheckedUpdateManyWithoutCategory_categoryToclasses_category2_idNestedInput
    classes_categoryToclasses_category3_id?: classesUncheckedUpdateManyWithoutCategory_categoryToclasses_category3_idNestedInput
  }

  export type categoryUpsertWithoutClasses_categoryToclasses_category2_idInput = {
    update: XOR<categoryUpdateWithoutClasses_categoryToclasses_category2_idInput, categoryUncheckedUpdateWithoutClasses_categoryToclasses_category2_idInput>
    create: XOR<categoryCreateWithoutClasses_categoryToclasses_category2_idInput, categoryUncheckedCreateWithoutClasses_categoryToclasses_category2_idInput>
  }

  export type categoryUpdateWithoutClasses_categoryToclasses_category2_idInput = {
    name?: StringFieldUpdateOperationsInput | string
    depth?: NullableIntFieldUpdateOperationsInput | number | null
    parent_id?: NullableIntFieldUpdateOperationsInput | number | null
    classes_categoryToclasses_category1_id?: classesUpdateManyWithoutCategory_categoryToclasses_category1_idNestedInput
    classes_categoryToclasses_category3_id?: classesUpdateManyWithoutCategory_categoryToclasses_category3_idNestedInput
  }

  export type categoryUncheckedUpdateWithoutClasses_categoryToclasses_category2_idInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    depth?: NullableIntFieldUpdateOperationsInput | number | null
    parent_id?: NullableIntFieldUpdateOperationsInput | number | null
    classes_categoryToclasses_category1_id?: classesUncheckedUpdateManyWithoutCategory_categoryToclasses_category1_idNestedInput
    classes_categoryToclasses_category3_id?: classesUncheckedUpdateManyWithoutCategory_categoryToclasses_category3_idNestedInput
  }

  export type categoryUpsertWithoutClasses_categoryToclasses_category3_idInput = {
    update: XOR<categoryUpdateWithoutClasses_categoryToclasses_category3_idInput, categoryUncheckedUpdateWithoutClasses_categoryToclasses_category3_idInput>
    create: XOR<categoryCreateWithoutClasses_categoryToclasses_category3_idInput, categoryUncheckedCreateWithoutClasses_categoryToclasses_category3_idInput>
  }

  export type categoryUpdateWithoutClasses_categoryToclasses_category3_idInput = {
    name?: StringFieldUpdateOperationsInput | string
    depth?: NullableIntFieldUpdateOperationsInput | number | null
    parent_id?: NullableIntFieldUpdateOperationsInput | number | null
    classes_categoryToclasses_category1_id?: classesUpdateManyWithoutCategory_categoryToclasses_category1_idNestedInput
    classes_categoryToclasses_category2_id?: classesUpdateManyWithoutCategory_categoryToclasses_category2_idNestedInput
  }

  export type categoryUncheckedUpdateWithoutClasses_categoryToclasses_category3_idInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    depth?: NullableIntFieldUpdateOperationsInput | number | null
    parent_id?: NullableIntFieldUpdateOperationsInput | number | null
    classes_categoryToclasses_category1_id?: classesUncheckedUpdateManyWithoutCategory_categoryToclasses_category1_idNestedInput
    classes_categoryToclasses_category2_id?: classesUncheckedUpdateManyWithoutCategory_categoryToclasses_category2_idNestedInput
  }

  export type instructorUpsertWithoutClassesInput = {
    update: XOR<instructorUpdateWithoutClassesInput, instructorUncheckedUpdateWithoutClassesInput>
    create: XOR<instructorCreateWithoutClassesInput, instructorUncheckedCreateWithoutClassesInput>
  }

  export type instructorUpdateWithoutClassesInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type instructorUncheckedUpdateWithoutClassesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type levelUpsertWithoutClassesInput = {
    update: XOR<levelUpdateWithoutClassesInput, levelUncheckedUpdateWithoutClassesInput>
    create: XOR<levelCreateWithoutClassesInput, levelUncheckedCreateWithoutClassesInput>
  }

  export type levelUpdateWithoutClassesInput = {
    level?: StringFieldUpdateOperationsInput | string
  }

  export type levelUncheckedUpdateWithoutClassesInput = {
    id?: IntFieldUpdateOperationsInput | number
    level?: StringFieldUpdateOperationsInput | string
  }

  export type price_scopeUpsertWithoutClassesInput = {
    update: XOR<price_scopeUpdateWithoutClassesInput, price_scopeUncheckedUpdateWithoutClassesInput>
    create: XOR<price_scopeCreateWithoutClassesInput, price_scopeUncheckedCreateWithoutClassesInput>
  }

  export type price_scopeUpdateWithoutClassesInput = {
    scope?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type price_scopeUncheckedUpdateWithoutClassesInput = {
    id?: IntFieldUpdateOperationsInput | number
    scope?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type class_imgUpsertWithWhereUniqueWithoutClassesInput = {
    where: class_imgWhereUniqueInput
    update: XOR<class_imgUpdateWithoutClassesInput, class_imgUncheckedUpdateWithoutClassesInput>
    create: XOR<class_imgCreateWithoutClassesInput, class_imgUncheckedCreateWithoutClassesInput>
  }

  export type class_imgUpdateWithWhereUniqueWithoutClassesInput = {
    where: class_imgWhereUniqueInput
    data: XOR<class_imgUpdateWithoutClassesInput, class_imgUncheckedUpdateWithoutClassesInput>
  }

  export type class_imgUpdateManyWithWhereWithoutClassesInput = {
    where: class_imgScalarWhereInput
    data: XOR<class_imgUpdateManyMutationInput, class_imgUncheckedUpdateManyWithoutClass_imgInput>
  }

  export type class_imgScalarWhereInput = {
    AND?: Enumerable<class_imgScalarWhereInput>
    OR?: Enumerable<class_imgScalarWhereInput>
    NOT?: Enumerable<class_imgScalarWhereInput>
    id?: IntFilter | number
    url?: StringFilter | string
    class_id?: IntFilter | number
  }

  export type contentsUpsertWithWhereUniqueWithoutClassesInput = {
    where: contentsWhereUniqueInput
    update: XOR<contentsUpdateWithoutClassesInput, contentsUncheckedUpdateWithoutClassesInput>
    create: XOR<contentsCreateWithoutClassesInput, contentsUncheckedCreateWithoutClassesInput>
  }

  export type contentsUpdateWithWhereUniqueWithoutClassesInput = {
    where: contentsWhereUniqueInput
    data: XOR<contentsUpdateWithoutClassesInput, contentsUncheckedUpdateWithoutClassesInput>
  }

  export type contentsUpdateManyWithWhereWithoutClassesInput = {
    where: contentsScalarWhereInput
    data: XOR<contentsUpdateManyMutationInput, contentsUncheckedUpdateManyWithoutContentsInput>
  }

  export type contentsScalarWhereInput = {
    AND?: Enumerable<contentsScalarWhereInput>
    OR?: Enumerable<contentsScalarWhereInput>
    NOT?: Enumerable<contentsScalarWhereInput>
    id?: IntFilter | number
    class_id?: IntFilter | number
    content?: StringNullableFilter | string | null
  }

  export type my_classesUpsertWithWhereUniqueWithoutClassesInput = {
    where: my_classesWhereUniqueInput
    update: XOR<my_classesUpdateWithoutClassesInput, my_classesUncheckedUpdateWithoutClassesInput>
    create: XOR<my_classesCreateWithoutClassesInput, my_classesUncheckedCreateWithoutClassesInput>
  }

  export type my_classesUpdateWithWhereUniqueWithoutClassesInput = {
    where: my_classesWhereUniqueInput
    data: XOR<my_classesUpdateWithoutClassesInput, my_classesUncheckedUpdateWithoutClassesInput>
  }

  export type my_classesUpdateManyWithWhereWithoutClassesInput = {
    where: my_classesScalarWhereInput
    data: XOR<my_classesUpdateManyMutationInput, my_classesUncheckedUpdateManyWithoutMy_classesInput>
  }

  export type reviewUpsertWithWhereUniqueWithoutClassesInput = {
    where: reviewWhereUniqueInput
    update: XOR<reviewUpdateWithoutClassesInput, reviewUncheckedUpdateWithoutClassesInput>
    create: XOR<reviewCreateWithoutClassesInput, reviewUncheckedCreateWithoutClassesInput>
  }

  export type reviewUpdateWithWhereUniqueWithoutClassesInput = {
    where: reviewWhereUniqueInput
    data: XOR<reviewUpdateWithoutClassesInput, reviewUncheckedUpdateWithoutClassesInput>
  }

  export type reviewUpdateManyWithWhereWithoutClassesInput = {
    where: reviewScalarWhereInput
    data: XOR<reviewUpdateManyMutationInput, reviewUncheckedUpdateManyWithoutReviewInput>
  }

  export type wishlistUpsertWithWhereUniqueWithoutClassesInput = {
    where: wishlistWhereUniqueInput
    update: XOR<wishlistUpdateWithoutClassesInput, wishlistUncheckedUpdateWithoutClassesInput>
    create: XOR<wishlistCreateWithoutClassesInput, wishlistUncheckedCreateWithoutClassesInput>
  }

  export type wishlistUpdateWithWhereUniqueWithoutClassesInput = {
    where: wishlistWhereUniqueInput
    data: XOR<wishlistUpdateWithoutClassesInput, wishlistUncheckedUpdateWithoutClassesInput>
  }

  export type wishlistUpdateManyWithWhereWithoutClassesInput = {
    where: wishlistScalarWhereInput
    data: XOR<wishlistUpdateManyMutationInput, wishlistUncheckedUpdateManyWithoutWishlistInput>
  }

  export type classesCreateWithoutContentsInput = {
    name: string
    price?: number | null
    img?: string | null
    rate?: number | null
    description?: string | null
    students?: number | null
    sessions?: number | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    category_categoryToclasses_category1_id?: categoryCreateNestedOneWithoutClasses_categoryToclasses_category1_idInput
    category_categoryToclasses_category2_id?: categoryCreateNestedOneWithoutClasses_categoryToclasses_category2_idInput
    category_categoryToclasses_category3_id?: categoryCreateNestedOneWithoutClasses_categoryToclasses_category3_idInput
    instructor: instructorCreateNestedOneWithoutClassesInput
    level?: levelCreateNestedOneWithoutClassesInput
    price_scope_classesToprice_scope?: price_scopeCreateNestedOneWithoutClassesInput
    class_img?: class_imgCreateNestedManyWithoutClassesInput
    my_classes?: my_classesCreateNestedManyWithoutClassesInput
    review?: reviewCreateNestedManyWithoutClassesInput
    wishlist?: wishlistCreateNestedManyWithoutClassesInput
  }

  export type classesUncheckedCreateWithoutContentsInput = {
    id?: number
    name: string
    instructor_id: number
    price?: number | null
    img?: string | null
    rate?: number | null
    description?: string | null
    students?: number | null
    sessions?: number | null
    price_scope?: number | null
    category1_id?: number | null
    category2_id?: number | null
    category3_id?: number | null
    level_id?: number | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    class_img?: class_imgUncheckedCreateNestedManyWithoutClassesInput
    my_classes?: my_classesUncheckedCreateNestedManyWithoutClassesInput
    review?: reviewUncheckedCreateNestedManyWithoutClassesInput
    wishlist?: wishlistUncheckedCreateNestedManyWithoutClassesInput
  }

  export type classesCreateOrConnectWithoutContentsInput = {
    where: classesWhereUniqueInput
    create: XOR<classesCreateWithoutContentsInput, classesUncheckedCreateWithoutContentsInput>
  }

  export type classesUpsertWithoutContentsInput = {
    update: XOR<classesUpdateWithoutContentsInput, classesUncheckedUpdateWithoutContentsInput>
    create: XOR<classesCreateWithoutContentsInput, classesUncheckedCreateWithoutContentsInput>
  }

  export type classesUpdateWithoutContentsInput = {
    name?: StringFieldUpdateOperationsInput | string
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    img?: NullableStringFieldUpdateOperationsInput | string | null
    rate?: NullableFloatFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    students?: NullableIntFieldUpdateOperationsInput | number | null
    sessions?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    category_categoryToclasses_category1_id?: categoryUpdateOneWithoutClasses_categoryToclasses_category1_idNestedInput
    category_categoryToclasses_category2_id?: categoryUpdateOneWithoutClasses_categoryToclasses_category2_idNestedInput
    category_categoryToclasses_category3_id?: categoryUpdateOneWithoutClasses_categoryToclasses_category3_idNestedInput
    instructor?: instructorUpdateOneRequiredWithoutClassesNestedInput
    level?: levelUpdateOneWithoutClassesNestedInput
    price_scope_classesToprice_scope?: price_scopeUpdateOneWithoutClassesNestedInput
    class_img?: class_imgUpdateManyWithoutClassesNestedInput
    my_classes?: my_classesUpdateManyWithoutClassesNestedInput
    review?: reviewUpdateManyWithoutClassesNestedInput
    wishlist?: wishlistUpdateManyWithoutClassesNestedInput
  }

  export type classesUncheckedUpdateWithoutContentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    instructor_id?: IntFieldUpdateOperationsInput | number
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    img?: NullableStringFieldUpdateOperationsInput | string | null
    rate?: NullableFloatFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    students?: NullableIntFieldUpdateOperationsInput | number | null
    sessions?: NullableIntFieldUpdateOperationsInput | number | null
    price_scope?: NullableIntFieldUpdateOperationsInput | number | null
    category1_id?: NullableIntFieldUpdateOperationsInput | number | null
    category2_id?: NullableIntFieldUpdateOperationsInput | number | null
    category3_id?: NullableIntFieldUpdateOperationsInput | number | null
    level_id?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    class_img?: class_imgUncheckedUpdateManyWithoutClassesNestedInput
    my_classes?: my_classesUncheckedUpdateManyWithoutClassesNestedInput
    review?: reviewUncheckedUpdateManyWithoutClassesNestedInput
    wishlist?: wishlistUncheckedUpdateManyWithoutClassesNestedInput
  }

  export type classesCreateWithoutInstructorInput = {
    name: string
    price?: number | null
    img?: string | null
    rate?: number | null
    description?: string | null
    students?: number | null
    sessions?: number | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    category_categoryToclasses_category1_id?: categoryCreateNestedOneWithoutClasses_categoryToclasses_category1_idInput
    category_categoryToclasses_category2_id?: categoryCreateNestedOneWithoutClasses_categoryToclasses_category2_idInput
    category_categoryToclasses_category3_id?: categoryCreateNestedOneWithoutClasses_categoryToclasses_category3_idInput
    level?: levelCreateNestedOneWithoutClassesInput
    price_scope_classesToprice_scope?: price_scopeCreateNestedOneWithoutClassesInput
    class_img?: class_imgCreateNestedManyWithoutClassesInput
    contents?: contentsCreateNestedManyWithoutClassesInput
    my_classes?: my_classesCreateNestedManyWithoutClassesInput
    review?: reviewCreateNestedManyWithoutClassesInput
    wishlist?: wishlistCreateNestedManyWithoutClassesInput
  }

  export type classesUncheckedCreateWithoutInstructorInput = {
    id?: number
    name: string
    price?: number | null
    img?: string | null
    rate?: number | null
    description?: string | null
    students?: number | null
    sessions?: number | null
    price_scope?: number | null
    category1_id?: number | null
    category2_id?: number | null
    category3_id?: number | null
    level_id?: number | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    class_img?: class_imgUncheckedCreateNestedManyWithoutClassesInput
    contents?: contentsUncheckedCreateNestedManyWithoutClassesInput
    my_classes?: my_classesUncheckedCreateNestedManyWithoutClassesInput
    review?: reviewUncheckedCreateNestedManyWithoutClassesInput
    wishlist?: wishlistUncheckedCreateNestedManyWithoutClassesInput
  }

  export type classesCreateOrConnectWithoutInstructorInput = {
    where: classesWhereUniqueInput
    create: XOR<classesCreateWithoutInstructorInput, classesUncheckedCreateWithoutInstructorInput>
  }

  export type classesCreateManyInstructorInputEnvelope = {
    data: Enumerable<classesCreateManyInstructorInput>
    skipDuplicates?: boolean
  }

  export type classesUpsertWithWhereUniqueWithoutInstructorInput = {
    where: classesWhereUniqueInput
    update: XOR<classesUpdateWithoutInstructorInput, classesUncheckedUpdateWithoutInstructorInput>
    create: XOR<classesCreateWithoutInstructorInput, classesUncheckedCreateWithoutInstructorInput>
  }

  export type classesUpdateWithWhereUniqueWithoutInstructorInput = {
    where: classesWhereUniqueInput
    data: XOR<classesUpdateWithoutInstructorInput, classesUncheckedUpdateWithoutInstructorInput>
  }

  export type classesUpdateManyWithWhereWithoutInstructorInput = {
    where: classesScalarWhereInput
    data: XOR<classesUpdateManyMutationInput, classesUncheckedUpdateManyWithoutClassesInput>
  }

  export type classesCreateWithoutLevelInput = {
    name: string
    price?: number | null
    img?: string | null
    rate?: number | null
    description?: string | null
    students?: number | null
    sessions?: number | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    category_categoryToclasses_category1_id?: categoryCreateNestedOneWithoutClasses_categoryToclasses_category1_idInput
    category_categoryToclasses_category2_id?: categoryCreateNestedOneWithoutClasses_categoryToclasses_category2_idInput
    category_categoryToclasses_category3_id?: categoryCreateNestedOneWithoutClasses_categoryToclasses_category3_idInput
    instructor: instructorCreateNestedOneWithoutClassesInput
    price_scope_classesToprice_scope?: price_scopeCreateNestedOneWithoutClassesInput
    class_img?: class_imgCreateNestedManyWithoutClassesInput
    contents?: contentsCreateNestedManyWithoutClassesInput
    my_classes?: my_classesCreateNestedManyWithoutClassesInput
    review?: reviewCreateNestedManyWithoutClassesInput
    wishlist?: wishlistCreateNestedManyWithoutClassesInput
  }

  export type classesUncheckedCreateWithoutLevelInput = {
    id?: number
    name: string
    instructor_id: number
    price?: number | null
    img?: string | null
    rate?: number | null
    description?: string | null
    students?: number | null
    sessions?: number | null
    price_scope?: number | null
    category1_id?: number | null
    category2_id?: number | null
    category3_id?: number | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    class_img?: class_imgUncheckedCreateNestedManyWithoutClassesInput
    contents?: contentsUncheckedCreateNestedManyWithoutClassesInput
    my_classes?: my_classesUncheckedCreateNestedManyWithoutClassesInput
    review?: reviewUncheckedCreateNestedManyWithoutClassesInput
    wishlist?: wishlistUncheckedCreateNestedManyWithoutClassesInput
  }

  export type classesCreateOrConnectWithoutLevelInput = {
    where: classesWhereUniqueInput
    create: XOR<classesCreateWithoutLevelInput, classesUncheckedCreateWithoutLevelInput>
  }

  export type classesCreateManyLevelInputEnvelope = {
    data: Enumerable<classesCreateManyLevelInput>
    skipDuplicates?: boolean
  }

  export type classesUpsertWithWhereUniqueWithoutLevelInput = {
    where: classesWhereUniqueInput
    update: XOR<classesUpdateWithoutLevelInput, classesUncheckedUpdateWithoutLevelInput>
    create: XOR<classesCreateWithoutLevelInput, classesUncheckedCreateWithoutLevelInput>
  }

  export type classesUpdateWithWhereUniqueWithoutLevelInput = {
    where: classesWhereUniqueInput
    data: XOR<classesUpdateWithoutLevelInput, classesUncheckedUpdateWithoutLevelInput>
  }

  export type classesUpdateManyWithWhereWithoutLevelInput = {
    where: classesScalarWhereInput
    data: XOR<classesUpdateManyMutationInput, classesUncheckedUpdateManyWithoutClassesInput>
  }

  export type classesCreateWithoutMy_classesInput = {
    name: string
    price?: number | null
    img?: string | null
    rate?: number | null
    description?: string | null
    students?: number | null
    sessions?: number | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    category_categoryToclasses_category1_id?: categoryCreateNestedOneWithoutClasses_categoryToclasses_category1_idInput
    category_categoryToclasses_category2_id?: categoryCreateNestedOneWithoutClasses_categoryToclasses_category2_idInput
    category_categoryToclasses_category3_id?: categoryCreateNestedOneWithoutClasses_categoryToclasses_category3_idInput
    instructor: instructorCreateNestedOneWithoutClassesInput
    level?: levelCreateNestedOneWithoutClassesInput
    price_scope_classesToprice_scope?: price_scopeCreateNestedOneWithoutClassesInput
    class_img?: class_imgCreateNestedManyWithoutClassesInput
    contents?: contentsCreateNestedManyWithoutClassesInput
    review?: reviewCreateNestedManyWithoutClassesInput
    wishlist?: wishlistCreateNestedManyWithoutClassesInput
  }

  export type classesUncheckedCreateWithoutMy_classesInput = {
    id?: number
    name: string
    instructor_id: number
    price?: number | null
    img?: string | null
    rate?: number | null
    description?: string | null
    students?: number | null
    sessions?: number | null
    price_scope?: number | null
    category1_id?: number | null
    category2_id?: number | null
    category3_id?: number | null
    level_id?: number | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    class_img?: class_imgUncheckedCreateNestedManyWithoutClassesInput
    contents?: contentsUncheckedCreateNestedManyWithoutClassesInput
    review?: reviewUncheckedCreateNestedManyWithoutClassesInput
    wishlist?: wishlistUncheckedCreateNestedManyWithoutClassesInput
  }

  export type classesCreateOrConnectWithoutMy_classesInput = {
    where: classesWhereUniqueInput
    create: XOR<classesCreateWithoutMy_classesInput, classesUncheckedCreateWithoutMy_classesInput>
  }

  export type usersCreateWithoutMy_classesInput = {
    name?: string | null
    email: string
    password: string
    img?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    review?: reviewCreateNestedManyWithoutUsersInput
    wishlist?: wishlistCreateNestedManyWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutMy_classesInput = {
    id?: number
    name?: string | null
    email: string
    password: string
    img?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    review?: reviewUncheckedCreateNestedManyWithoutUsersInput
    wishlist?: wishlistUncheckedCreateNestedManyWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutMy_classesInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutMy_classesInput, usersUncheckedCreateWithoutMy_classesInput>
  }

  export type classesUpsertWithoutMy_classesInput = {
    update: XOR<classesUpdateWithoutMy_classesInput, classesUncheckedUpdateWithoutMy_classesInput>
    create: XOR<classesCreateWithoutMy_classesInput, classesUncheckedCreateWithoutMy_classesInput>
  }

  export type classesUpdateWithoutMy_classesInput = {
    name?: StringFieldUpdateOperationsInput | string
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    img?: NullableStringFieldUpdateOperationsInput | string | null
    rate?: NullableFloatFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    students?: NullableIntFieldUpdateOperationsInput | number | null
    sessions?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    category_categoryToclasses_category1_id?: categoryUpdateOneWithoutClasses_categoryToclasses_category1_idNestedInput
    category_categoryToclasses_category2_id?: categoryUpdateOneWithoutClasses_categoryToclasses_category2_idNestedInput
    category_categoryToclasses_category3_id?: categoryUpdateOneWithoutClasses_categoryToclasses_category3_idNestedInput
    instructor?: instructorUpdateOneRequiredWithoutClassesNestedInput
    level?: levelUpdateOneWithoutClassesNestedInput
    price_scope_classesToprice_scope?: price_scopeUpdateOneWithoutClassesNestedInput
    class_img?: class_imgUpdateManyWithoutClassesNestedInput
    contents?: contentsUpdateManyWithoutClassesNestedInput
    review?: reviewUpdateManyWithoutClassesNestedInput
    wishlist?: wishlistUpdateManyWithoutClassesNestedInput
  }

  export type classesUncheckedUpdateWithoutMy_classesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    instructor_id?: IntFieldUpdateOperationsInput | number
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    img?: NullableStringFieldUpdateOperationsInput | string | null
    rate?: NullableFloatFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    students?: NullableIntFieldUpdateOperationsInput | number | null
    sessions?: NullableIntFieldUpdateOperationsInput | number | null
    price_scope?: NullableIntFieldUpdateOperationsInput | number | null
    category1_id?: NullableIntFieldUpdateOperationsInput | number | null
    category2_id?: NullableIntFieldUpdateOperationsInput | number | null
    category3_id?: NullableIntFieldUpdateOperationsInput | number | null
    level_id?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    class_img?: class_imgUncheckedUpdateManyWithoutClassesNestedInput
    contents?: contentsUncheckedUpdateManyWithoutClassesNestedInput
    review?: reviewUncheckedUpdateManyWithoutClassesNestedInput
    wishlist?: wishlistUncheckedUpdateManyWithoutClassesNestedInput
  }

  export type usersUpsertWithoutMy_classesInput = {
    update: XOR<usersUpdateWithoutMy_classesInput, usersUncheckedUpdateWithoutMy_classesInput>
    create: XOR<usersCreateWithoutMy_classesInput, usersUncheckedCreateWithoutMy_classesInput>
  }

  export type usersUpdateWithoutMy_classesInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    img?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    review?: reviewUpdateManyWithoutUsersNestedInput
    wishlist?: wishlistUpdateManyWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutMy_classesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    img?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    review?: reviewUncheckedUpdateManyWithoutUsersNestedInput
    wishlist?: wishlistUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type classesCreateWithoutPrice_scope_classesToprice_scopeInput = {
    name: string
    price?: number | null
    img?: string | null
    rate?: number | null
    description?: string | null
    students?: number | null
    sessions?: number | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    category_categoryToclasses_category1_id?: categoryCreateNestedOneWithoutClasses_categoryToclasses_category1_idInput
    category_categoryToclasses_category2_id?: categoryCreateNestedOneWithoutClasses_categoryToclasses_category2_idInput
    category_categoryToclasses_category3_id?: categoryCreateNestedOneWithoutClasses_categoryToclasses_category3_idInput
    instructor: instructorCreateNestedOneWithoutClassesInput
    level?: levelCreateNestedOneWithoutClassesInput
    class_img?: class_imgCreateNestedManyWithoutClassesInput
    contents?: contentsCreateNestedManyWithoutClassesInput
    my_classes?: my_classesCreateNestedManyWithoutClassesInput
    review?: reviewCreateNestedManyWithoutClassesInput
    wishlist?: wishlistCreateNestedManyWithoutClassesInput
  }

  export type classesUncheckedCreateWithoutPrice_scope_classesToprice_scopeInput = {
    id?: number
    name: string
    instructor_id: number
    price?: number | null
    img?: string | null
    rate?: number | null
    description?: string | null
    students?: number | null
    sessions?: number | null
    category1_id?: number | null
    category2_id?: number | null
    category3_id?: number | null
    level_id?: number | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    class_img?: class_imgUncheckedCreateNestedManyWithoutClassesInput
    contents?: contentsUncheckedCreateNestedManyWithoutClassesInput
    my_classes?: my_classesUncheckedCreateNestedManyWithoutClassesInput
    review?: reviewUncheckedCreateNestedManyWithoutClassesInput
    wishlist?: wishlistUncheckedCreateNestedManyWithoutClassesInput
  }

  export type classesCreateOrConnectWithoutPrice_scope_classesToprice_scopeInput = {
    where: classesWhereUniqueInput
    create: XOR<classesCreateWithoutPrice_scope_classesToprice_scopeInput, classesUncheckedCreateWithoutPrice_scope_classesToprice_scopeInput>
  }

  export type classesCreateManyPrice_scope_classesToprice_scopeInputEnvelope = {
    data: Enumerable<classesCreateManyPrice_scope_classesToprice_scopeInput>
    skipDuplicates?: boolean
  }

  export type classesUpsertWithWhereUniqueWithoutPrice_scope_classesToprice_scopeInput = {
    where: classesWhereUniqueInput
    update: XOR<classesUpdateWithoutPrice_scope_classesToprice_scopeInput, classesUncheckedUpdateWithoutPrice_scope_classesToprice_scopeInput>
    create: XOR<classesCreateWithoutPrice_scope_classesToprice_scopeInput, classesUncheckedCreateWithoutPrice_scope_classesToprice_scopeInput>
  }

  export type classesUpdateWithWhereUniqueWithoutPrice_scope_classesToprice_scopeInput = {
    where: classesWhereUniqueInput
    data: XOR<classesUpdateWithoutPrice_scope_classesToprice_scopeInput, classesUncheckedUpdateWithoutPrice_scope_classesToprice_scopeInput>
  }

  export type classesUpdateManyWithWhereWithoutPrice_scope_classesToprice_scopeInput = {
    where: classesScalarWhereInput
    data: XOR<classesUpdateManyMutationInput, classesUncheckedUpdateManyWithoutClassesInput>
  }

  export type classesCreateWithoutReviewInput = {
    name: string
    price?: number | null
    img?: string | null
    rate?: number | null
    description?: string | null
    students?: number | null
    sessions?: number | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    category_categoryToclasses_category1_id?: categoryCreateNestedOneWithoutClasses_categoryToclasses_category1_idInput
    category_categoryToclasses_category2_id?: categoryCreateNestedOneWithoutClasses_categoryToclasses_category2_idInput
    category_categoryToclasses_category3_id?: categoryCreateNestedOneWithoutClasses_categoryToclasses_category3_idInput
    instructor: instructorCreateNestedOneWithoutClassesInput
    level?: levelCreateNestedOneWithoutClassesInput
    price_scope_classesToprice_scope?: price_scopeCreateNestedOneWithoutClassesInput
    class_img?: class_imgCreateNestedManyWithoutClassesInput
    contents?: contentsCreateNestedManyWithoutClassesInput
    my_classes?: my_classesCreateNestedManyWithoutClassesInput
    wishlist?: wishlistCreateNestedManyWithoutClassesInput
  }

  export type classesUncheckedCreateWithoutReviewInput = {
    id?: number
    name: string
    instructor_id: number
    price?: number | null
    img?: string | null
    rate?: number | null
    description?: string | null
    students?: number | null
    sessions?: number | null
    price_scope?: number | null
    category1_id?: number | null
    category2_id?: number | null
    category3_id?: number | null
    level_id?: number | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    class_img?: class_imgUncheckedCreateNestedManyWithoutClassesInput
    contents?: contentsUncheckedCreateNestedManyWithoutClassesInput
    my_classes?: my_classesUncheckedCreateNestedManyWithoutClassesInput
    wishlist?: wishlistUncheckedCreateNestedManyWithoutClassesInput
  }

  export type classesCreateOrConnectWithoutReviewInput = {
    where: classesWhereUniqueInput
    create: XOR<classesCreateWithoutReviewInput, classesUncheckedCreateWithoutReviewInput>
  }

  export type usersCreateWithoutReviewInput = {
    name?: string | null
    email: string
    password: string
    img?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    my_classes?: my_classesCreateNestedManyWithoutUsersInput
    wishlist?: wishlistCreateNestedManyWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutReviewInput = {
    id?: number
    name?: string | null
    email: string
    password: string
    img?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    my_classes?: my_classesUncheckedCreateNestedManyWithoutUsersInput
    wishlist?: wishlistUncheckedCreateNestedManyWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutReviewInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutReviewInput, usersUncheckedCreateWithoutReviewInput>
  }

  export type classesUpsertWithoutReviewInput = {
    update: XOR<classesUpdateWithoutReviewInput, classesUncheckedUpdateWithoutReviewInput>
    create: XOR<classesCreateWithoutReviewInput, classesUncheckedCreateWithoutReviewInput>
  }

  export type classesUpdateWithoutReviewInput = {
    name?: StringFieldUpdateOperationsInput | string
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    img?: NullableStringFieldUpdateOperationsInput | string | null
    rate?: NullableFloatFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    students?: NullableIntFieldUpdateOperationsInput | number | null
    sessions?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    category_categoryToclasses_category1_id?: categoryUpdateOneWithoutClasses_categoryToclasses_category1_idNestedInput
    category_categoryToclasses_category2_id?: categoryUpdateOneWithoutClasses_categoryToclasses_category2_idNestedInput
    category_categoryToclasses_category3_id?: categoryUpdateOneWithoutClasses_categoryToclasses_category3_idNestedInput
    instructor?: instructorUpdateOneRequiredWithoutClassesNestedInput
    level?: levelUpdateOneWithoutClassesNestedInput
    price_scope_classesToprice_scope?: price_scopeUpdateOneWithoutClassesNestedInput
    class_img?: class_imgUpdateManyWithoutClassesNestedInput
    contents?: contentsUpdateManyWithoutClassesNestedInput
    my_classes?: my_classesUpdateManyWithoutClassesNestedInput
    wishlist?: wishlistUpdateManyWithoutClassesNestedInput
  }

  export type classesUncheckedUpdateWithoutReviewInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    instructor_id?: IntFieldUpdateOperationsInput | number
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    img?: NullableStringFieldUpdateOperationsInput | string | null
    rate?: NullableFloatFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    students?: NullableIntFieldUpdateOperationsInput | number | null
    sessions?: NullableIntFieldUpdateOperationsInput | number | null
    price_scope?: NullableIntFieldUpdateOperationsInput | number | null
    category1_id?: NullableIntFieldUpdateOperationsInput | number | null
    category2_id?: NullableIntFieldUpdateOperationsInput | number | null
    category3_id?: NullableIntFieldUpdateOperationsInput | number | null
    level_id?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    class_img?: class_imgUncheckedUpdateManyWithoutClassesNestedInput
    contents?: contentsUncheckedUpdateManyWithoutClassesNestedInput
    my_classes?: my_classesUncheckedUpdateManyWithoutClassesNestedInput
    wishlist?: wishlistUncheckedUpdateManyWithoutClassesNestedInput
  }

  export type usersUpsertWithoutReviewInput = {
    update: XOR<usersUpdateWithoutReviewInput, usersUncheckedUpdateWithoutReviewInput>
    create: XOR<usersCreateWithoutReviewInput, usersUncheckedCreateWithoutReviewInput>
  }

  export type usersUpdateWithoutReviewInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    img?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    my_classes?: my_classesUpdateManyWithoutUsersNestedInput
    wishlist?: wishlistUpdateManyWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutReviewInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    img?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    my_classes?: my_classesUncheckedUpdateManyWithoutUsersNestedInput
    wishlist?: wishlistUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type classesCreateWithoutWishlistInput = {
    name: string
    price?: number | null
    img?: string | null
    rate?: number | null
    description?: string | null
    students?: number | null
    sessions?: number | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    category_categoryToclasses_category1_id?: categoryCreateNestedOneWithoutClasses_categoryToclasses_category1_idInput
    category_categoryToclasses_category2_id?: categoryCreateNestedOneWithoutClasses_categoryToclasses_category2_idInput
    category_categoryToclasses_category3_id?: categoryCreateNestedOneWithoutClasses_categoryToclasses_category3_idInput
    instructor: instructorCreateNestedOneWithoutClassesInput
    level?: levelCreateNestedOneWithoutClassesInput
    price_scope_classesToprice_scope?: price_scopeCreateNestedOneWithoutClassesInput
    class_img?: class_imgCreateNestedManyWithoutClassesInput
    contents?: contentsCreateNestedManyWithoutClassesInput
    my_classes?: my_classesCreateNestedManyWithoutClassesInput
    review?: reviewCreateNestedManyWithoutClassesInput
  }

  export type classesUncheckedCreateWithoutWishlistInput = {
    id?: number
    name: string
    instructor_id: number
    price?: number | null
    img?: string | null
    rate?: number | null
    description?: string | null
    students?: number | null
    sessions?: number | null
    price_scope?: number | null
    category1_id?: number | null
    category2_id?: number | null
    category3_id?: number | null
    level_id?: number | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    class_img?: class_imgUncheckedCreateNestedManyWithoutClassesInput
    contents?: contentsUncheckedCreateNestedManyWithoutClassesInput
    my_classes?: my_classesUncheckedCreateNestedManyWithoutClassesInput
    review?: reviewUncheckedCreateNestedManyWithoutClassesInput
  }

  export type classesCreateOrConnectWithoutWishlistInput = {
    where: classesWhereUniqueInput
    create: XOR<classesCreateWithoutWishlistInput, classesUncheckedCreateWithoutWishlistInput>
  }

  export type usersCreateWithoutWishlistInput = {
    name?: string | null
    email: string
    password: string
    img?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    my_classes?: my_classesCreateNestedManyWithoutUsersInput
    review?: reviewCreateNestedManyWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutWishlistInput = {
    id?: number
    name?: string | null
    email: string
    password: string
    img?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    my_classes?: my_classesUncheckedCreateNestedManyWithoutUsersInput
    review?: reviewUncheckedCreateNestedManyWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutWishlistInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutWishlistInput, usersUncheckedCreateWithoutWishlistInput>
  }

  export type classesUpsertWithoutWishlistInput = {
    update: XOR<classesUpdateWithoutWishlistInput, classesUncheckedUpdateWithoutWishlistInput>
    create: XOR<classesCreateWithoutWishlistInput, classesUncheckedCreateWithoutWishlistInput>
  }

  export type classesUpdateWithoutWishlistInput = {
    name?: StringFieldUpdateOperationsInput | string
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    img?: NullableStringFieldUpdateOperationsInput | string | null
    rate?: NullableFloatFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    students?: NullableIntFieldUpdateOperationsInput | number | null
    sessions?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    category_categoryToclasses_category1_id?: categoryUpdateOneWithoutClasses_categoryToclasses_category1_idNestedInput
    category_categoryToclasses_category2_id?: categoryUpdateOneWithoutClasses_categoryToclasses_category2_idNestedInput
    category_categoryToclasses_category3_id?: categoryUpdateOneWithoutClasses_categoryToclasses_category3_idNestedInput
    instructor?: instructorUpdateOneRequiredWithoutClassesNestedInput
    level?: levelUpdateOneWithoutClassesNestedInput
    price_scope_classesToprice_scope?: price_scopeUpdateOneWithoutClassesNestedInput
    class_img?: class_imgUpdateManyWithoutClassesNestedInput
    contents?: contentsUpdateManyWithoutClassesNestedInput
    my_classes?: my_classesUpdateManyWithoutClassesNestedInput
    review?: reviewUpdateManyWithoutClassesNestedInput
  }

  export type classesUncheckedUpdateWithoutWishlistInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    instructor_id?: IntFieldUpdateOperationsInput | number
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    img?: NullableStringFieldUpdateOperationsInput | string | null
    rate?: NullableFloatFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    students?: NullableIntFieldUpdateOperationsInput | number | null
    sessions?: NullableIntFieldUpdateOperationsInput | number | null
    price_scope?: NullableIntFieldUpdateOperationsInput | number | null
    category1_id?: NullableIntFieldUpdateOperationsInput | number | null
    category2_id?: NullableIntFieldUpdateOperationsInput | number | null
    category3_id?: NullableIntFieldUpdateOperationsInput | number | null
    level_id?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    class_img?: class_imgUncheckedUpdateManyWithoutClassesNestedInput
    contents?: contentsUncheckedUpdateManyWithoutClassesNestedInput
    my_classes?: my_classesUncheckedUpdateManyWithoutClassesNestedInput
    review?: reviewUncheckedUpdateManyWithoutClassesNestedInput
  }

  export type usersUpsertWithoutWishlistInput = {
    update: XOR<usersUpdateWithoutWishlistInput, usersUncheckedUpdateWithoutWishlistInput>
    create: XOR<usersCreateWithoutWishlistInput, usersUncheckedCreateWithoutWishlistInput>
  }

  export type usersUpdateWithoutWishlistInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    img?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    my_classes?: my_classesUpdateManyWithoutUsersNestedInput
    review?: reviewUpdateManyWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutWishlistInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    img?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    my_classes?: my_classesUncheckedUpdateManyWithoutUsersNestedInput
    review?: reviewUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type my_classesCreateManyUsersInput = {
    id?: number
    class_id: number
    progress?: number
  }

  export type reviewCreateManyUsersInput = {
    id?: number
    rate: number
    class_id: number
  }

  export type wishlistCreateManyUsersInput = {
    id?: number
    class_id: number
  }

  export type my_classesUpdateWithoutUsersInput = {
    progress?: IntFieldUpdateOperationsInput | number
    classes?: classesUpdateOneRequiredWithoutMy_classesNestedInput
  }

  export type my_classesUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    class_id?: IntFieldUpdateOperationsInput | number
    progress?: IntFieldUpdateOperationsInput | number
  }

  export type my_classesUncheckedUpdateManyWithoutMy_classesInput = {
    id?: IntFieldUpdateOperationsInput | number
    class_id?: IntFieldUpdateOperationsInput | number
    progress?: IntFieldUpdateOperationsInput | number
  }

  export type reviewUpdateWithoutUsersInput = {
    rate?: FloatFieldUpdateOperationsInput | number
    classes?: classesUpdateOneRequiredWithoutReviewNestedInput
  }

  export type reviewUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    rate?: FloatFieldUpdateOperationsInput | number
    class_id?: IntFieldUpdateOperationsInput | number
  }

  export type reviewUncheckedUpdateManyWithoutReviewInput = {
    id?: IntFieldUpdateOperationsInput | number
    rate?: FloatFieldUpdateOperationsInput | number
    class_id?: IntFieldUpdateOperationsInput | number
  }

  export type wishlistUpdateWithoutUsersInput = {
    classes?: classesUpdateOneRequiredWithoutWishlistNestedInput
  }

  export type wishlistUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    class_id?: IntFieldUpdateOperationsInput | number
  }

  export type wishlistUncheckedUpdateManyWithoutWishlistInput = {
    id?: IntFieldUpdateOperationsInput | number
    class_id?: IntFieldUpdateOperationsInput | number
  }

  export type classesCreateManyCategory_categoryToclasses_category1_idInput = {
    id?: number
    name: string
    instructor_id: number
    price?: number | null
    img?: string | null
    rate?: number | null
    description?: string | null
    students?: number | null
    sessions?: number | null
    price_scope?: number | null
    category2_id?: number | null
    category3_id?: number | null
    level_id?: number | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type classesCreateManyCategory_categoryToclasses_category2_idInput = {
    id?: number
    name: string
    instructor_id: number
    price?: number | null
    img?: string | null
    rate?: number | null
    description?: string | null
    students?: number | null
    sessions?: number | null
    price_scope?: number | null
    category1_id?: number | null
    category3_id?: number | null
    level_id?: number | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type classesCreateManyCategory_categoryToclasses_category3_idInput = {
    id?: number
    name: string
    instructor_id: number
    price?: number | null
    img?: string | null
    rate?: number | null
    description?: string | null
    students?: number | null
    sessions?: number | null
    price_scope?: number | null
    category1_id?: number | null
    category2_id?: number | null
    level_id?: number | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type classesUpdateWithoutCategory_categoryToclasses_category1_idInput = {
    name?: StringFieldUpdateOperationsInput | string
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    img?: NullableStringFieldUpdateOperationsInput | string | null
    rate?: NullableFloatFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    students?: NullableIntFieldUpdateOperationsInput | number | null
    sessions?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    category_categoryToclasses_category2_id?: categoryUpdateOneWithoutClasses_categoryToclasses_category2_idNestedInput
    category_categoryToclasses_category3_id?: categoryUpdateOneWithoutClasses_categoryToclasses_category3_idNestedInput
    instructor?: instructorUpdateOneRequiredWithoutClassesNestedInput
    level?: levelUpdateOneWithoutClassesNestedInput
    price_scope_classesToprice_scope?: price_scopeUpdateOneWithoutClassesNestedInput
    class_img?: class_imgUpdateManyWithoutClassesNestedInput
    contents?: contentsUpdateManyWithoutClassesNestedInput
    my_classes?: my_classesUpdateManyWithoutClassesNestedInput
    review?: reviewUpdateManyWithoutClassesNestedInput
    wishlist?: wishlistUpdateManyWithoutClassesNestedInput
  }

  export type classesUncheckedUpdateWithoutCategory_categoryToclasses_category1_idInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    instructor_id?: IntFieldUpdateOperationsInput | number
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    img?: NullableStringFieldUpdateOperationsInput | string | null
    rate?: NullableFloatFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    students?: NullableIntFieldUpdateOperationsInput | number | null
    sessions?: NullableIntFieldUpdateOperationsInput | number | null
    price_scope?: NullableIntFieldUpdateOperationsInput | number | null
    category2_id?: NullableIntFieldUpdateOperationsInput | number | null
    category3_id?: NullableIntFieldUpdateOperationsInput | number | null
    level_id?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    class_img?: class_imgUncheckedUpdateManyWithoutClassesNestedInput
    contents?: contentsUncheckedUpdateManyWithoutClassesNestedInput
    my_classes?: my_classesUncheckedUpdateManyWithoutClassesNestedInput
    review?: reviewUncheckedUpdateManyWithoutClassesNestedInput
    wishlist?: wishlistUncheckedUpdateManyWithoutClassesNestedInput
  }

  export type classesUncheckedUpdateManyWithoutClasses_categoryToclasses_category1_idInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    instructor_id?: IntFieldUpdateOperationsInput | number
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    img?: NullableStringFieldUpdateOperationsInput | string | null
    rate?: NullableFloatFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    students?: NullableIntFieldUpdateOperationsInput | number | null
    sessions?: NullableIntFieldUpdateOperationsInput | number | null
    price_scope?: NullableIntFieldUpdateOperationsInput | number | null
    category2_id?: NullableIntFieldUpdateOperationsInput | number | null
    category3_id?: NullableIntFieldUpdateOperationsInput | number | null
    level_id?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type classesUpdateWithoutCategory_categoryToclasses_category2_idInput = {
    name?: StringFieldUpdateOperationsInput | string
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    img?: NullableStringFieldUpdateOperationsInput | string | null
    rate?: NullableFloatFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    students?: NullableIntFieldUpdateOperationsInput | number | null
    sessions?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    category_categoryToclasses_category1_id?: categoryUpdateOneWithoutClasses_categoryToclasses_category1_idNestedInput
    category_categoryToclasses_category3_id?: categoryUpdateOneWithoutClasses_categoryToclasses_category3_idNestedInput
    instructor?: instructorUpdateOneRequiredWithoutClassesNestedInput
    level?: levelUpdateOneWithoutClassesNestedInput
    price_scope_classesToprice_scope?: price_scopeUpdateOneWithoutClassesNestedInput
    class_img?: class_imgUpdateManyWithoutClassesNestedInput
    contents?: contentsUpdateManyWithoutClassesNestedInput
    my_classes?: my_classesUpdateManyWithoutClassesNestedInput
    review?: reviewUpdateManyWithoutClassesNestedInput
    wishlist?: wishlistUpdateManyWithoutClassesNestedInput
  }

  export type classesUncheckedUpdateWithoutCategory_categoryToclasses_category2_idInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    instructor_id?: IntFieldUpdateOperationsInput | number
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    img?: NullableStringFieldUpdateOperationsInput | string | null
    rate?: NullableFloatFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    students?: NullableIntFieldUpdateOperationsInput | number | null
    sessions?: NullableIntFieldUpdateOperationsInput | number | null
    price_scope?: NullableIntFieldUpdateOperationsInput | number | null
    category1_id?: NullableIntFieldUpdateOperationsInput | number | null
    category3_id?: NullableIntFieldUpdateOperationsInput | number | null
    level_id?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    class_img?: class_imgUncheckedUpdateManyWithoutClassesNestedInput
    contents?: contentsUncheckedUpdateManyWithoutClassesNestedInput
    my_classes?: my_classesUncheckedUpdateManyWithoutClassesNestedInput
    review?: reviewUncheckedUpdateManyWithoutClassesNestedInput
    wishlist?: wishlistUncheckedUpdateManyWithoutClassesNestedInput
  }

  export type classesUncheckedUpdateManyWithoutClasses_categoryToclasses_category2_idInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    instructor_id?: IntFieldUpdateOperationsInput | number
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    img?: NullableStringFieldUpdateOperationsInput | string | null
    rate?: NullableFloatFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    students?: NullableIntFieldUpdateOperationsInput | number | null
    sessions?: NullableIntFieldUpdateOperationsInput | number | null
    price_scope?: NullableIntFieldUpdateOperationsInput | number | null
    category1_id?: NullableIntFieldUpdateOperationsInput | number | null
    category3_id?: NullableIntFieldUpdateOperationsInput | number | null
    level_id?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type classesUpdateWithoutCategory_categoryToclasses_category3_idInput = {
    name?: StringFieldUpdateOperationsInput | string
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    img?: NullableStringFieldUpdateOperationsInput | string | null
    rate?: NullableFloatFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    students?: NullableIntFieldUpdateOperationsInput | number | null
    sessions?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    category_categoryToclasses_category1_id?: categoryUpdateOneWithoutClasses_categoryToclasses_category1_idNestedInput
    category_categoryToclasses_category2_id?: categoryUpdateOneWithoutClasses_categoryToclasses_category2_idNestedInput
    instructor?: instructorUpdateOneRequiredWithoutClassesNestedInput
    level?: levelUpdateOneWithoutClassesNestedInput
    price_scope_classesToprice_scope?: price_scopeUpdateOneWithoutClassesNestedInput
    class_img?: class_imgUpdateManyWithoutClassesNestedInput
    contents?: contentsUpdateManyWithoutClassesNestedInput
    my_classes?: my_classesUpdateManyWithoutClassesNestedInput
    review?: reviewUpdateManyWithoutClassesNestedInput
    wishlist?: wishlistUpdateManyWithoutClassesNestedInput
  }

  export type classesUncheckedUpdateWithoutCategory_categoryToclasses_category3_idInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    instructor_id?: IntFieldUpdateOperationsInput | number
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    img?: NullableStringFieldUpdateOperationsInput | string | null
    rate?: NullableFloatFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    students?: NullableIntFieldUpdateOperationsInput | number | null
    sessions?: NullableIntFieldUpdateOperationsInput | number | null
    price_scope?: NullableIntFieldUpdateOperationsInput | number | null
    category1_id?: NullableIntFieldUpdateOperationsInput | number | null
    category2_id?: NullableIntFieldUpdateOperationsInput | number | null
    level_id?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    class_img?: class_imgUncheckedUpdateManyWithoutClassesNestedInput
    contents?: contentsUncheckedUpdateManyWithoutClassesNestedInput
    my_classes?: my_classesUncheckedUpdateManyWithoutClassesNestedInput
    review?: reviewUncheckedUpdateManyWithoutClassesNestedInput
    wishlist?: wishlistUncheckedUpdateManyWithoutClassesNestedInput
  }

  export type classesUncheckedUpdateManyWithoutClasses_categoryToclasses_category3_idInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    instructor_id?: IntFieldUpdateOperationsInput | number
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    img?: NullableStringFieldUpdateOperationsInput | string | null
    rate?: NullableFloatFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    students?: NullableIntFieldUpdateOperationsInput | number | null
    sessions?: NullableIntFieldUpdateOperationsInput | number | null
    price_scope?: NullableIntFieldUpdateOperationsInput | number | null
    category1_id?: NullableIntFieldUpdateOperationsInput | number | null
    category2_id?: NullableIntFieldUpdateOperationsInput | number | null
    level_id?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type class_imgCreateManyClassesInput = {
    id?: number
    url: string
  }

  export type contentsCreateManyClassesInput = {
    id?: number
    content?: string | null
  }

  export type my_classesCreateManyClassesInput = {
    id?: number
    user_id: number
    progress?: number
  }

  export type reviewCreateManyClassesInput = {
    id?: number
    user_id: number
    rate: number
  }

  export type wishlistCreateManyClassesInput = {
    id?: number
    user_id: number
  }

  export type class_imgUpdateWithoutClassesInput = {
    url?: StringFieldUpdateOperationsInput | string
  }

  export type class_imgUncheckedUpdateWithoutClassesInput = {
    id?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
  }

  export type class_imgUncheckedUpdateManyWithoutClass_imgInput = {
    id?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
  }

  export type contentsUpdateWithoutClassesInput = {
    content?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type contentsUncheckedUpdateWithoutClassesInput = {
    id?: IntFieldUpdateOperationsInput | number
    content?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type contentsUncheckedUpdateManyWithoutContentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    content?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type my_classesUpdateWithoutClassesInput = {
    progress?: IntFieldUpdateOperationsInput | number
    users?: usersUpdateOneRequiredWithoutMy_classesNestedInput
  }

  export type my_classesUncheckedUpdateWithoutClassesInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    progress?: IntFieldUpdateOperationsInput | number
  }

  export type reviewUpdateWithoutClassesInput = {
    rate?: FloatFieldUpdateOperationsInput | number
    users?: usersUpdateOneRequiredWithoutReviewNestedInput
  }

  export type reviewUncheckedUpdateWithoutClassesInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    rate?: FloatFieldUpdateOperationsInput | number
  }

  export type wishlistUpdateWithoutClassesInput = {
    users?: usersUpdateOneRequiredWithoutWishlistNestedInput
  }

  export type wishlistUncheckedUpdateWithoutClassesInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
  }

  export type classesCreateManyInstructorInput = {
    id?: number
    name: string
    price?: number | null
    img?: string | null
    rate?: number | null
    description?: string | null
    students?: number | null
    sessions?: number | null
    price_scope?: number | null
    category1_id?: number | null
    category2_id?: number | null
    category3_id?: number | null
    level_id?: number | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type classesUpdateWithoutInstructorInput = {
    name?: StringFieldUpdateOperationsInput | string
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    img?: NullableStringFieldUpdateOperationsInput | string | null
    rate?: NullableFloatFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    students?: NullableIntFieldUpdateOperationsInput | number | null
    sessions?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    category_categoryToclasses_category1_id?: categoryUpdateOneWithoutClasses_categoryToclasses_category1_idNestedInput
    category_categoryToclasses_category2_id?: categoryUpdateOneWithoutClasses_categoryToclasses_category2_idNestedInput
    category_categoryToclasses_category3_id?: categoryUpdateOneWithoutClasses_categoryToclasses_category3_idNestedInput
    level?: levelUpdateOneWithoutClassesNestedInput
    price_scope_classesToprice_scope?: price_scopeUpdateOneWithoutClassesNestedInput
    class_img?: class_imgUpdateManyWithoutClassesNestedInput
    contents?: contentsUpdateManyWithoutClassesNestedInput
    my_classes?: my_classesUpdateManyWithoutClassesNestedInput
    review?: reviewUpdateManyWithoutClassesNestedInput
    wishlist?: wishlistUpdateManyWithoutClassesNestedInput
  }

  export type classesUncheckedUpdateWithoutInstructorInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    img?: NullableStringFieldUpdateOperationsInput | string | null
    rate?: NullableFloatFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    students?: NullableIntFieldUpdateOperationsInput | number | null
    sessions?: NullableIntFieldUpdateOperationsInput | number | null
    price_scope?: NullableIntFieldUpdateOperationsInput | number | null
    category1_id?: NullableIntFieldUpdateOperationsInput | number | null
    category2_id?: NullableIntFieldUpdateOperationsInput | number | null
    category3_id?: NullableIntFieldUpdateOperationsInput | number | null
    level_id?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    class_img?: class_imgUncheckedUpdateManyWithoutClassesNestedInput
    contents?: contentsUncheckedUpdateManyWithoutClassesNestedInput
    my_classes?: my_classesUncheckedUpdateManyWithoutClassesNestedInput
    review?: reviewUncheckedUpdateManyWithoutClassesNestedInput
    wishlist?: wishlistUncheckedUpdateManyWithoutClassesNestedInput
  }

  export type classesUncheckedUpdateManyWithoutClassesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    img?: NullableStringFieldUpdateOperationsInput | string | null
    rate?: NullableFloatFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    students?: NullableIntFieldUpdateOperationsInput | number | null
    sessions?: NullableIntFieldUpdateOperationsInput | number | null
    price_scope?: NullableIntFieldUpdateOperationsInput | number | null
    category1_id?: NullableIntFieldUpdateOperationsInput | number | null
    category2_id?: NullableIntFieldUpdateOperationsInput | number | null
    category3_id?: NullableIntFieldUpdateOperationsInput | number | null
    level_id?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type classesCreateManyLevelInput = {
    id?: number
    name: string
    instructor_id: number
    price?: number | null
    img?: string | null
    rate?: number | null
    description?: string | null
    students?: number | null
    sessions?: number | null
    price_scope?: number | null
    category1_id?: number | null
    category2_id?: number | null
    category3_id?: number | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type classesUpdateWithoutLevelInput = {
    name?: StringFieldUpdateOperationsInput | string
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    img?: NullableStringFieldUpdateOperationsInput | string | null
    rate?: NullableFloatFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    students?: NullableIntFieldUpdateOperationsInput | number | null
    sessions?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    category_categoryToclasses_category1_id?: categoryUpdateOneWithoutClasses_categoryToclasses_category1_idNestedInput
    category_categoryToclasses_category2_id?: categoryUpdateOneWithoutClasses_categoryToclasses_category2_idNestedInput
    category_categoryToclasses_category3_id?: categoryUpdateOneWithoutClasses_categoryToclasses_category3_idNestedInput
    instructor?: instructorUpdateOneRequiredWithoutClassesNestedInput
    price_scope_classesToprice_scope?: price_scopeUpdateOneWithoutClassesNestedInput
    class_img?: class_imgUpdateManyWithoutClassesNestedInput
    contents?: contentsUpdateManyWithoutClassesNestedInput
    my_classes?: my_classesUpdateManyWithoutClassesNestedInput
    review?: reviewUpdateManyWithoutClassesNestedInput
    wishlist?: wishlistUpdateManyWithoutClassesNestedInput
  }

  export type classesUncheckedUpdateWithoutLevelInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    instructor_id?: IntFieldUpdateOperationsInput | number
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    img?: NullableStringFieldUpdateOperationsInput | string | null
    rate?: NullableFloatFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    students?: NullableIntFieldUpdateOperationsInput | number | null
    sessions?: NullableIntFieldUpdateOperationsInput | number | null
    price_scope?: NullableIntFieldUpdateOperationsInput | number | null
    category1_id?: NullableIntFieldUpdateOperationsInput | number | null
    category2_id?: NullableIntFieldUpdateOperationsInput | number | null
    category3_id?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    class_img?: class_imgUncheckedUpdateManyWithoutClassesNestedInput
    contents?: contentsUncheckedUpdateManyWithoutClassesNestedInput
    my_classes?: my_classesUncheckedUpdateManyWithoutClassesNestedInput
    review?: reviewUncheckedUpdateManyWithoutClassesNestedInput
    wishlist?: wishlistUncheckedUpdateManyWithoutClassesNestedInput
  }

  export type classesCreateManyPrice_scope_classesToprice_scopeInput = {
    id?: number
    name: string
    instructor_id: number
    price?: number | null
    img?: string | null
    rate?: number | null
    description?: string | null
    students?: number | null
    sessions?: number | null
    category1_id?: number | null
    category2_id?: number | null
    category3_id?: number | null
    level_id?: number | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type classesUpdateWithoutPrice_scope_classesToprice_scopeInput = {
    name?: StringFieldUpdateOperationsInput | string
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    img?: NullableStringFieldUpdateOperationsInput | string | null
    rate?: NullableFloatFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    students?: NullableIntFieldUpdateOperationsInput | number | null
    sessions?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    category_categoryToclasses_category1_id?: categoryUpdateOneWithoutClasses_categoryToclasses_category1_idNestedInput
    category_categoryToclasses_category2_id?: categoryUpdateOneWithoutClasses_categoryToclasses_category2_idNestedInput
    category_categoryToclasses_category3_id?: categoryUpdateOneWithoutClasses_categoryToclasses_category3_idNestedInput
    instructor?: instructorUpdateOneRequiredWithoutClassesNestedInput
    level?: levelUpdateOneWithoutClassesNestedInput
    class_img?: class_imgUpdateManyWithoutClassesNestedInput
    contents?: contentsUpdateManyWithoutClassesNestedInput
    my_classes?: my_classesUpdateManyWithoutClassesNestedInput
    review?: reviewUpdateManyWithoutClassesNestedInput
    wishlist?: wishlistUpdateManyWithoutClassesNestedInput
  }

  export type classesUncheckedUpdateWithoutPrice_scope_classesToprice_scopeInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    instructor_id?: IntFieldUpdateOperationsInput | number
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    img?: NullableStringFieldUpdateOperationsInput | string | null
    rate?: NullableFloatFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    students?: NullableIntFieldUpdateOperationsInput | number | null
    sessions?: NullableIntFieldUpdateOperationsInput | number | null
    category1_id?: NullableIntFieldUpdateOperationsInput | number | null
    category2_id?: NullableIntFieldUpdateOperationsInput | number | null
    category3_id?: NullableIntFieldUpdateOperationsInput | number | null
    level_id?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    class_img?: class_imgUncheckedUpdateManyWithoutClassesNestedInput
    contents?: contentsUncheckedUpdateManyWithoutClassesNestedInput
    my_classes?: my_classesUncheckedUpdateManyWithoutClassesNestedInput
    review?: reviewUncheckedUpdateManyWithoutClassesNestedInput
    wishlist?: wishlistUncheckedUpdateManyWithoutClassesNestedInput
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}